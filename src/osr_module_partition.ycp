/**
 * File:
 *   osr_module_partition.ycp
 *
 * Module:
 *   Partition and filesystems checking module.
 *
 * Summary:
 *   YaST2 OS Repair. Automatic error detection & repair tool for Linux.
 *
 * Author:
 *   Michael Koehrmann <curry@suse.de>
 *
 * $Id$
 */

{
  textdomain "osr";

  //include "partitioning/partition_defines.ycp";

  include "osr/common_filesystem.ycp";

  // begin argument handling: in the initial phase the framework calls each module
  // with the argument ".init", don't delete!
  integer arg_c = size(Args());
  integer arg_n = 0;

  boolean init_mode = false;
  
  while ( arg_n < arg_c )
  {
      if ( Args(arg_n) == .init ) init_mode = true;
      else
      {
	  y2error("ERROR: unknown option %1", Args(arg_n) );
	  return `error;
      }
      arg_n = arg_n + 1;
  }
  // end argument handling
  
  //////////////////////////////////////////////////////////////////////
  //
  //  METHODS
  //
  //////////////////////////////////////////////////////////////////////
  
  /**
   *  Initialization of the module map that contains all important information
   *  for this module.
   *
   *  @return map The map that contains all information about the module osr_module_partition.
   */
  define OSRPartitionInit() ``{
      
      map osr_module_partition = $[];

      osr_module_partition = $[
		   // has to be the name of the file
		   "name"              :  "osr_module_partition",
		   "headline"          :  UI(_("Partitions and filesystems")),
		   "summary"           :  [],
		   "test_mode_summary" :  [
					   $["header" : "Partitions and filesystems", "description" : "O.k.", status : "detect_ok"],
					   $["header" : "Partitions and filesystems", "description" : "O.k.", status : "detect_ok"]
		   ],

		   // the sequence of the detection methods of this module
		   "detect_methods"    :  [
				    	   ``(OSRPartitionCheckDisks()),
					   ``(OSRPartitionMountPartitions())
		   ],

		   // the values this module requires from other modules of the rescue system
		   // use "yast2 osr .provides" to create the file "/tmp/osr_global_provides" to
		   // show which values are already provided
		   "requires"          :  [
					   "target_map",
					   "repair_target",
					   "disk_device_list"//,
					   //"root_partition",
					   //"kernel_path_list",
					   //"initrd_path_list"
		   ],

		   // the values this module will provide
		   "provides"          : $[
					   "root_partition"      : $["type" : "string", "value" : "/dev/hda1", "status" : "unknown"],
					   "target_partition_map": $["type" : "map", "value" : $[], "status" : "unknown"],
					   "target_scrpath_map"  : $["type" : "map", "value" : $[], "status" : "unknown"]
					   //"lilo_package_is_installed" : $[ "type" : "boolean", "value" : false, "status" : "unknown" ],
					   //"lilo_package_is_verified"  : $[ "type" : "boolean", "value" : false, "status" : "unknown" ],
					   //"lilo_conf_path"            : $[ "type" : "string", "value" : "/etc/lilo.conf", "status" : "unknown" ]
		   ],

		   // informations for the module progress bar
		   "progress_file"     : "/tmp/osr_module_partition_progress",
		   "progress_expect"   : 1000
      ];

      return osr_module_partition;
  }

  //////////////////////////////////////////////////////////////////////
  //
  //  DETECTION METHODS
  //
  //////////////////////////////////////////////////////////////////////

  /**
   *  Checks the harddisks. Attention: if there are SCSI-disks connected the SCSI-kernel-module
   *  has to be loaded first (TODO??).
   *
   *  Requires: %
   *  Provides: list target_partitions, path target_scrpath
   *
   *  @return map The result-map.
   */
  global define OSRPartitionCheckDisks() ``{

      boolean repair_question = false;
      string  error_message   = "";
      string  help_text       = "";
      string  status          = "";
      string  module_name     = "osr_module_partition";
      map     target_map      = $[];
      map     result_map      = $[];
      list    partition_list  = [];
      list    disk_list       = [];

      // "installMap" : $[..., "disks" : "/dev/hda /dev/sda", ...]
      disk_list = lookup(lookup(user_settings, "installMap", $[]), "disks", []);
      
      target_map = lookup(user_settings, "targets", $[]);

      if ((target_map == $[]) || (target_map == nil))
      {
	  status = OSRStatusDetectError();

	  OSRSummaryDetectError(
				module_name,
				_("Checking disks"),
				_("No disks found")
				);

	  return $["status" : status];
      }
      else
      {
	  status = OSRStatusDetectOK();

	  OSRSummaryDetectOK(
				module_name,
				_("Checking disks"),
				sformat(_("Disks found: %1, %2"), mergestring(disk_list, ", "), disk_list)
				);
      }

      // check all targets (all disks) for partition-entries
      foreach(`target, `values, target_map, ``{

	  list target_partitions = lookup(values, "partitions", []);
	  path target_scrpath    = lookup(values, "scrpath", .);

	  OSRProvideMap("target_partition_map", $[target : target_partitions]);
	  OSRProvideMap("target_scrpath_map", $[target : target_scrpath]);
	  
      	  if (size(target_partitions) == 0)
	  {
	      status = OSRStatusDetectError();

	      OSRSummaryDetectError(
				    module_name,
				    _("Checking partition tables"),
				    sformat(_("No partition table found for disk %1"), target)
				    );

	      error_message = sformat(_("No partition table found for disk %1.

Press Repair to revert the partition-table
from a former session."), target);

	      help_text = _("No partition table found.");

	      repair_question = OSRPopupRepair(_("Error detected"), error_message, help_text);

	      if (repair_question)
	      {
		  string  disk_name     = select(splitstring(target, "/"), (size(splitstring(target, "/"))-1));
		  string  ptbl_name     = "" + disk_name + ".ptbl";
		  boolean has_floppy    = lookup(user_settings, "has_floppy", true);
		  string  floppy_device = lookup(user_settings, "floppy_device", "/dev/fd0");

		  if (has_floppy)
		  {
		      UI::OpenDialog(`opt(`decorated), `Label(_("Loading system information...")));

		      // mount the floppy to /media/floppy/
		      boolean mounted = (WFM::Execute(.local.bash, "/bin/mount " + floppy_device + " /media/floppy -t auto") == 0);

		      // be careful: only read the file /media/floppy/osr_map.ycp if the floppy was mounted
		      // correctly!
		      if (mounted)
		      {
			  integer ptbl_check = SCR::Read(.target.size, "/media/floppy/" + ptbl_name);

			  if (ptbl_check != 512)
			  {
			      y2error("file %1 is not of the correct size.", "/media/floppy/" + ptbl_name);

			      OSRPopupDisplayQuick(sformat(_("The partition-table of disk %1
could not be read correctly from this floppy."), target), 1000);
			  }
			  else
			  {
			      UI::CloseDialog();

			      string command = sformat("dd if=/media/floppy/%1 of=%2 bs=1 count=64 skip=446 seek=446", ptbl_name, target);

			      UI::OpenDialog(`opt(`decorated), `Label(_("Reverting old partition-table...")));

			      integer revert = WFM::Execute(.local.bash, command);

			      if (revert == 0)
			      {
                                  // TODO: read the partition-table!
				  string partition_path = ".disk" + target_scrpath + ".partitions";
				  //string partition_path = ".disk." + disk_name + ".partitions";
				  list partition_table = SCR::Read(topath(partition_path));

				  //OSRPopupDisplayQuick(sformat("path: %1\nptbl: %2", partition_path, partition_table), 3000);

				  if ((partition_table != nil) && (partition_table != []))
				  {
				      // o.k.
				      status = OSRStatusRepairOK();

				      OSRSummaryRepairOK(
							 module_name,
							 _("Repairing partition-table"),
							 _("Reverted old partition-table")
							 );

				      OSRProvideMap("target_partition_map", $[target : partition_table]);

				      // construct an updated "targets"-map and store it in the map "user_settings"
				      map partition_map = $["partitions" : partition_table];
				      target_map        = add(target_map, target, partiton_map);
				      user_settings     = add(user_settings, "targets", target_map);

				      // umount the floppy after reading
				      WFM::Execute(.local.bash, "/bin/umount /media/floppy");
  
				      UI::CloseDialog();

				      OSRModuleProgressFill();

				      return $["status" : status];
				  }
			      }
			      else
			      {
				  y2error("Reverting of the partition-table was not successfull.");
			      }
			  }
		      }
		      // umount the floppy after reading
		      WFM::Execute(.local.bash, "/bin/umount /media/floppy");
  
		      UI::CloseDialog();
		  }



		  /*    
		  old_osr_map = OSRReadFloppy();

		  if ((old_osr_map == nil) || (old_osr_map == $[]))
		  {
		      status = OSRStatusRepairOmit();

		      OSRSummaryRepairOmit(
					   module_name,
					   _("Repairing partition-table"),
					   _("Old system-information was not loaded<br>
Partition-table not repaired")
					   );
		  }
		  else
		  {
		      map  old_provides   = lookup(old_osr_map, "global_provides", $[]);
		      map  old_targets    = lookup(old_provides, "target_map", $[]);
		      map  old_value      = lookup(old_targets, "value", $[]);
		      map  old_target_map = lookup(old_value, target, $[]);
		      list old_partitions = lookup(old_target_map, "partitions", $[]);

		      if ((old_partitions != nil) && (old_partitions != []))
		      {
			  // TODO: whats wrong here??
			  boolean fdisk_result = SCR::Write(.disk + target_scrpath + .partitions, old_partitions);

			  //OSRPopupDisplayQuick(sformat("fdisk: %1\nscrpath: %2\npartitions: %3", fdisk_result, target_scrpath, old_partitions), 3000);

			  list    current_partition = SCR::Read(.disk + target_scrpath + .partitions);
			  boolean partitioning_ok   = ((current_partition != nil) && (current_partition != []));
			  
			  if (fdisk_result && partitioning_ok)
			  {
			      status = OSRStatusRepairOK();

			      OSRSummaryRepairOK(
						 module_name,
						 sformat(_("Writing partition-table to disk <code>%1<code>"), target),
						 _("O.k.")
						 );
			  }
			  else
			  {
			      status = OSRStatusRepairError();

			      OSRSummaryRepairError(
						    module_name,
						    sformat(_("Writing partition-table to disk <code>%1<code>"), target),
						    _("Partition-table not written correctly")
						    );
			  }
		      }
		  }
		  */
		  
	      }
	      else
	      {
		  status = OSRStatusRepairOmit();

		  OSRSummaryRepairOmit(
				       module_name,
				       _("Repairing partition-table"),
				       _("Partition-table not repaired")
				       );
	      }
	  }
	  else
	  {
	      status = OSRStatusDetectOK();

	      OSRSummaryDetectOK(
				 module_name,
				 _("Checking partition tables"),
				 sformat(_("Partition tables found for disk <code>%1</code>"), target)
				 );
	  }
      });
      
      // set the value of the module-progress-bar to 100%
      OSRModuleProgress::Fill();
      
      return $["status" : status];
  };


  /**
   *
   *  @return map The result_map.
   */
  global define OSRPartitionMountPartitions() ``{

      boolean repair_question       = false;
      boolean error_detected        = false;
      integer progress_expect       = 40;
      string  module_name           = "osr_module_partition";
      string  help_text             = "";
      string  error_message         = "";
      string  progress_file         = "";
      string  progress_label        = _("Checking the partitions and filesystems");
      string  log_file              = "";
      string  status                = "";
      map     result_map            = $[];
      map     target_map            = $[];
      string  update_target         = "";
      list    partition_list        = [];
      list    linux_partition_list  = [];
      string  root_partition        = "";
      list    mount_possible_list   = [];
      
      module_map     = OSRGetModuleMap(module_name);
      log_file       = OSRLogFile::GetFile();
      progress_file  = lookup(module_map, "progress_file", "");

      // set the parameters for the module-progress-bar
      OSRModuleProgress::SetParams(progress_label, progress_file, progress_expect);

      root_partition = lookup (user_settings, "selectedRootPartition", "" );
      partition_list = lookup (user_settings, "validRootPartitions", [] );

      target_map     = OSRRequireMap("target_map");
      update_target  = OSRRequireString("update_target");

      if (size(partition_list) <= 0)
      {
	  //////////////////////////////////////////////////
	  //
	  // searching for valid Linux-partitions
	  //
	  //////////////////////////////////////////////////

	  linux_partition_list = GetLinuxPartitions(target_map);

	  if (size(linux_partition_list) <= 0)
	  {
	      status = OSRStatusDetectError();

	      OSRSummaryDetectError(
				    module_name,
				    UI(_("Searching for valid linux-partitions")),
				    UI(_("No valid partition-types found"))
				    );

	      //return ($["status" : status]);
	  }
	  else
	  {
	      status = OSRStatusDetectOK();
	      
	      OSRSummaryDetectOK(
				 module_name,
				 UI(_("Searching for valid linux-partitions")),
				 sformat(UI(_("Valid linux-partitions found:<br>
<code>%1</code>")), mergestring(linux_partition_list, ", "))
				 );

	  }

	  /////////////////////////////////////////////////////////
	  //
	  // searching for mountable partitions with /etc/fstab
	  //
	  /////////////////////////////////////////////////////////

	  mount_possible_list = GetMountablePartitions(linux_partition_list);

      	  user_settings = add(user_settings, "validRootPartitions", partition_list);
      }

      list mounted_partitions = GetMountedPartitions();
      //y2error("mounted_partitions: %1", mounted_partitions);

      if (size(mount_possible_list) > 0)
      {
	  status = OSRStatusDetectOK();
	  
	  OSRSummaryDetectOK(
			     module_name,
			     UI(_("Searching for mountable partitions")),
			     sformat("Mountable partitions found:<br>
<code>%1</code>", mergestring(mount_possible_list, ", "))
			     );
      }
      else
      {
	  status = OSRStatusDetectError();
	  
	  OSRSummaryDetectError(
				module_name,
				UI(_("Searching for mountable partitions")),
				UI(_("No mountable partitions found"))
				);
	  //return ($["status" : status]);
      }

      
      if (size(partition_list) <= 0)
      {
	  status = OSRStatusDetectError();
	  
	  OSRSummaryDetectError(
				module_name,
				UI(_("Searching for valid root-partitions")),
				UI(_("No valid root-partition found"))
				);
	  //return ($["status" : status]);
      }
      else if (size(partition_list) == 1)
      {
	  root_partition = select(partition_list, 0);

	  OSRProvideString("root_partition", root_partition);

	  status = OSRStatusDetectOK();
	  
	  OSRSummaryDetectOK(
			     module_name,
			     UI(_("Searching for valid root-partitions")),
			     sformat("One valid partition found: <code>%1</code>", root_partition)
			     );
      }
      else
      {
	  // several valid root-partitions found

	  status = OSRStatusDetectOK();
	  
	  OSRSummaryDetectOK(
			     module_name,
			     UI(_("Searching for valid root-partitions")),
			     sformat("Several valid root-partitions found:<br>
<code>%1</code>", mergestring(partition_list, ", "))
			     );


	  root_partition = OSRPopupSelectItem(
					      _("Select root-partition"),
					      _("There exist several valid root-partitions in your system.
You have to select one item in the list."),
					      partition_list,
					      "",
					      true
					      );
      }

      // There is a mounted root-partition. --> This frame have
      // been called by inst_sw_backup. So we have to unmount
      // the root-partition
      //OSRPartitionUnmountPartition( );
      
      user_settings = add(user_settings, "selectedRootPartition", "");

      if ( MountRoot(root_partition) )
      {
	  status = OSRStatusDetectOK();
	  
	  OSRSummaryDetectOK(
			     module_name,
			     sformat(UI(_("Mounting root-partition: <code>%1</code>")), root_partition),
			     UI(_("Mount succeeded"))
			     );

	  user_settings = add (user_settings, "selectedRootPartition", root_partition );
      }
      else
      {
	  status = OSRStatusDetectError();
	  
	  OSRSummaryDetectError(
				module_name,
				sformat(UI(_("Mounting root-partition: <code>%1</code>")), root_partition),
				UI(_("Mount not possible"))
				);
      }

      
      
      status = OSRStatusDetectOK();
      
      result_map = $["status" : status];

      // set the value of the module-progress-bar to 100%
      OSRModuleProgress::Fill();
      
      return result_map;

  }




  



  
  /**
   *
   *  @return map The result_map.
   */
  /*
  global define OSRPartitionCheckDisks() ``{

      map     module_map      = $[];
      string  log_file        = "";
      string  progress_file   = "";
      string  root_partition  = "";
      list    partition_list  = [];
      map     target_map      = $[];
      string  update_target   = "";
      string  status          = "";
      boolean repair_question = true;
      string  module_name     = "osr_module_partition";
      string  error_message   = "";
      string  help_text       = "";
      
      module_map     = OSRGetModuleMap(module_name);
      log_file       = OSRLogFile::GetFile();
      progress_file  = lookup(module_map, "progress_file");

      root_partition = lookup(user_settings, "selectedRootPartition", "" );
      partition_list = lookup(user_settings, "validRootPartitions", [] );

      target_map     = OSRRequireMap("target_map");
      update_target  = OSRRequireString("update_target");


      status = OSRStatusDetectOK();


      OSRSummaryDetectOK(
			 module_name,
			 _("Checking partition tables"),
			 sformat(_("Partition tables found for disk <code>%1</code>"), target)
			 );

      result_map = $[
		     "status" : status
      ];

      // set the value of the module-progress-bar to 100%
      OSRModuleProgress::Fill();
      
      return result_map;      
  }
  */

  //////////////////////////////////////////////////////////////////////
  //
  //  MAIN
  //
  //////////////////////////////////////////////////////////////////////

  // in init-mode only execute the init-function and return the module-map
  // to the framework, don't delete
  if (init_mode)
  {
      map module_map = OSRPartitionInit();

      return module_map; 
  }
  // end MAIN
}
