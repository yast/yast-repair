/**
 * File:
 *   osr_module_partition.ycp
 *
 * Module:
 *   Partition and filesystems checking module.
 *
 * Summary:
 *   YaST2 OS Repair. Automatic error detection & repair tool for Linux.
 *
 * Author:
 *   Michael Koehrmann <curry@suse.de>
 */

{
  textdomain "osr";
  
  // begin argument handling: in the initial phase the framework calls each module
  // with the argument ".init", don't delete!
  integer arg_c = size(Args());
  integer arg_n = 0;

  boolean init_mode = false;
  
  while ( arg_n < arg_c )
  {
      if ( Args(arg_n) == .init ) init_mode = true;
      else
      {
	  y2error("ERROR: unknown option %1", Args(arg_n) );
	  return `error;
      }
      arg_n = arg_n + 1;
  }
  // end argument handling

  //////////////////////////////////////////////////////////////////////
  //
  //  METHODS
  //
  //////////////////////////////////////////////////////////////////////
  
  /**
   *  Initialization of the module map that contains all important information
   *  for this module.
   *
   *  @return map The map that contains all information about the module osr_module_partition.
   */
  define OSRPartitionInit() ``{
      
      map osr_module_partition = $[];

      osr_module_partition = $[
		   // has to be the name of the file
		   "name"              :  "osr_module_partition",
		   "headline"          :  UI(_("Partitions and filesystems")),
		   "summary"           :  [],
		   "test_mode_summary" :  [
					   $["header" : "Partitions and filesystems", "description" : "O.k.", status : "detect_ok"],
					   $["header" : "Partitions and filesystems", "description" : "O.k.", status : "detect_ok"]
		   ],

		   // the sequence of the detection methods of this module
		   "detect_methods"    :  [
				    	   ``(OSRPartitionCheckDisks())
		   ],

		   // the values this module requires from other modules of the rescue system
		   // use "yast2 osr .provides" to create the file "/tmp/osr_global_provides" to
		   // show which values are already provided
		   "requires"          :  [
					   "disk_device_list"//,
					   //"root_partition",
					   //"kernel_path_list",
					   //"initrd_path_list"
		   ],

		   // the values this module will provide
		   "provides"          : $[
					   //"lilo_package_is_installed" : $[ "type" : "boolean", "value" : false, "status" : "unknown" ],
					   //"lilo_package_is_verified"  : $[ "type" : "boolean", "value" : false, "status" : "unknown" ],
					   //"lilo_conf_path"            : $[ "type" : "string", "value" : "/etc/lilo.conf", "status" : "unknown" ]
		   ],

		   // informations for the module progress bar
		   "progress_file"     : "/tmp/osr_module_partition_progress",
		   "progress_expect"   : 1000
      ];

      return osr_module_partition;
  }

  //////////////////////////////////////////////////////////////////////
  //
  //  DETECTION METHODS
  //
  //////////////////////////////////////////////////////////////////////
  
  /**
   *
   *  @return map The result_map.
   */
  global define OSRPartitionCheckDisks() ``{

      boolean repair_question  = false;
      boolean error_detected   = false;
      integer progress_expect  = 10;
      string  module_name      = "osr_module_partition";
      string  help_text        = "";
      string  error_message    = "";
      string  progress_file    = "";
      string  progress_label   = UI(_("Probing disks"));
      string  log_file         = "";
      string  status           = "";
      map     result_map       = $[];
      
      module_map    = OSRGetModuleMap(module_name);
      log_file      = OSRLogFileGet();
      progress_file = lookup(module_map, "progress_file");

      // set the parameters for the module-progress-bar
      OSRModuleProgressSetParams(progress_label, progress_file, progress_expect);

      // the following looks like this:
      // [$["bus":"IDE", "class_id":262, "dev_name":"/dev/hda", "device":"ST313021A",
      // "resource":$["cache":[$["size":512]],
      // "disk_log_geo": [$["cylinders":1583, "heads":255, "sectors":63]],
      // "disk_phys_geo":[$["cylinders":25232, "heads":16, "sectors":63]],
      // "size":[$["unit":"sectors", "x":25434228, "y":512]]],
      // "rev":"3.03", "sub_class_id":0, "unique_key":"6NKn.ajve1oLEn+C"],
      // $["bus":"SCSI", "class_id":262, "dev_name":"/dev/sda", "device":"LIGHTNING 730S",
      // "resource":$["disk_log_geo":[$["cylinders":699, "heads":64, "sectors":32]],
      // "size":[$["unit":"sectors", "x":1431760, "y":512]]], "rev":"241E", "sub_class_id":0,
      // "unique_key":"mgh8.lKftjjVg6ZD", "vendor":"QUANTUM"]]
      list disk_list = SCR(`Read(.probe.disk));
      SCR(`Write(.dumpto.tmp.disk_list, disk_list));

      // get all device-names from the disk-list
      list dev_names = [];
      foreach(`bus, disk_list, ``{
	  dev_names = add(dev_names, lookup(bus, "dev_name", ""));
      });
      //y2error("DEVNAMES: %1", dev_names);
      
      list dev_names2 = [];
      foreach(`device, dev_names, ``{
	  dev_names2 = add(dev_names2, select(splitstring(device, "/"), 2));
      });
      //y2error("DEVNAMES2: %1", dev_names2);

      list dev_names3 = [];
      foreach(`device, dev_names2, ``{
	  dev_names3 = add(dev_names3, topath(sformat(".disk.%1", device)));
      });
      //y2error("DEVNAMES3: %1", dev_names3);

      foreach(`device, dev_names3, ``{
	  list partitions = SCR(`Read(topath(sformat("%1.partitions", device))));
	  //y2error("PARTITIONS: %1", partitions);

	  // check the regions
	  foreach(`partition, partitions, ``{
	      list region = lookup(partition, "region", []);

	      // ...
	  });
      });
      
      // the following looks like this:
      // [$["fsid":131, "fstype":"Linux native",      "nr":1, "region":[0, 144],    "type":`primary],
      //  $["fsid":130, "fstype":"Linux swap",        "nr":2, "region":[144, 39],   "type":`primary],
      //  $["fsid":15,  "fstype":"Win95 Ext'd (LBA)", "nr":3, "region":[183, 1400], "type":`extended],
      //  $["fsid":131, "fstype":"Linux native",      "nr":5, "region":[183, 144],  "type":`logical]]
      list hda_partitions = SCR(`Read(.disk.hda.partitions));
      SCR(`Write(.dumpto.tmp.hda_partitions, hda_partitions));

      // the following looks like this:
      // [$["fsid":1, "fstype":"DOS", "nr":1, "region":[0, 699], "type":`primary]]
      list sda_partitions = SCR(`Read(.disk.sda.partitions));
      SCR(`Write(.dumpto.tmp.sda_partitions, sda_partitions));

      error_detected = false;
      
      // end section
      
      if (!error_detected)
      {
 	  status = OSRStatusDetectOK();

	  string summary_text = "";
	  foreach(`m, disk_list, ``{
	      summary_text = summary_text + sformat("<br><code>%1</code>: o.k.", lookup(m, "dev_name", ""));
	  });

	  OSRSummaryDetectOK(
			     module_name,
			     UI(_("Probing disks")),
			     sformat(UI(_("Getting information for all disk-devices%1")), summary_text)
			     );
      }
      else
      {
 	  status = OSRStatusDetectError();

	  // set the error message that is displayed in the popup OSRRepairPopup
	  error_message   = UI( _("An error was detected.\nPress Repair to fix the error.") );

	  // set the help-text to be displayed in the left RichText-widget of the main window
	  help_text       = UI( _("<p>ERROR.</p>"));
	  help_text       = help_text + UI( _("<p>Press <b>Repair</b>.</p>") );
	  
	  // launch the repair-popup
          repair_question = OSRPopupRepair(UI(_("Error detected")), error_message, help_text);

	  // set the text that is displayed in the right RichText-widget of the main window
	  //result_text = OSRSummaryItem(UI(_("TEMPLATE check 1")), UI(_("Error detected")), true);
	  OSRSummaryDetectError(module_name, UI(_("Probing disks")), UI(_("Error detected")));
			      
	  // if the user selected Repair set the sequence of repair methods
  	  if (repair_question)
	  {
	    if (!OSRPartitionRepair1())
	      {
		status = OSRStatusRepairError();
	      }
	    else
	      {
		status = OSRStatusRepairOK();
	      }

	    if (!OSRPartitionRepair2())
	      {
		status = OSRStatusRepairError();
	      }
	    else
	      {
		status = OSRStatusRepairOK();
	      }
	  }
	  else
	  {
	    status = OSRStatusRepairOmit();
	  }
      }
      
      result_map = $[
		     "status" : status
      ];

      // set the value of the module-progress-bar to 100%
      OSRModuleProgressFill();
      
      return result_map;
  }

  /**
   *
   *  @return map The result_map.
   */
  global define OSRPartitionCheck() ``{

      boolean repair_question  = false;
      boolean error_detected   = false;
      integer progress_expect  = 40;
      string  module_name      = "osr_module_partition";
      string  help_text        = "";
      string  error_message    = "";
      string  progress_file    = "";
      string  progress_label   = UI(_("Checking the partitions and filesystems"));
      string  log_file         = "";
      string  status           = "";
      map     result_map       = $[];

      module_map    = OSRGetModuleMap(module_name);
      log_file      = OSRLogFileGet();
      progress_file = lookup(module_map, "progress_file");

      // set the parameters for the module-progress-bar
      OSRModuleProgressSetParams(progress_label, progress_file, progress_expect);

      status = OSRStatusDetectOK();

      OSRSummaryDetectOK(
			 module_name,
			 UI(_("Checking partitions")),
			 UI(_("Optimally"))
			 );

      result_map = $[
		     "status" : status
      ];

      // set the value of the module-progress-bar to 100%
      OSRModuleProgressFill();
      
      return result_map;
  }

  //////////////////////////////////////////////////////////////////////
  //
  //  REPAIR METHODS
  //
  //////////////////////////////////////////////////////////////////////

  /**
   * 
   *  @return boolean True if the repair process was successful.
   */
  global define OSRProgressRepair() ``{

      integer result          = 0;
      integer progress_expect = 50;
      string  log_file        = "";
      string  command         = "";
      string  progress_label  = "Repairing the partitions and filesystems";
      string  module_name      = "osr_module_partition";
      boolean error_detected  = false;

      log_file = OSRLogFileGet();

      // setting up the progress bar
      OSRModuleProgressSetParams(progress_label, progress_file, progress_expect);

      OSRModuleProgressFill();
      
      return (result == 0);
  }

  //////////////////////////////////////////////////////////////////////
  //
  //  MAIN
  //
  //////////////////////////////////////////////////////////////////////

  // in init-mode only execute the init-function and return the module-map
  // to the framework, don't delete
  if (init_mode)
  {
      map module_map = OSRPartitionInit();

      return module_map; 
  }
  // end MAIN
}
