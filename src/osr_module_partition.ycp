/**
 * File:
 *   osr_module_partition.ycp
 *
 * Module:
 *   Partition and filesystems checking module.
 *
 * Summary:
 *   YaST2 OS Repair. Automatic error detection & repair tool for Linux.
 *
 * Author:
 *   Michael Koehrmann <curry@suse.de>
 *
 * $Id$
 */

{
  textdomain "osr";

  include "osr/common_filesystem.ycp";

  // begin argument handling: in the initial phase the framework calls each module
  // with the argument ".init", don't delete!
  integer arg_c = size(Args());
  integer arg_n = 0;

  boolean init_mode = false;
  
  while ( arg_n < arg_c )
  {
      if ( Args(arg_n) == .init ) init_mode = true;
      else
      {
	  y2error("ERROR: unknown option %1", Args(arg_n) );
	  return `error;
      }
      arg_n = arg_n + 1;
  }
  // end argument handling
  
  //////////////////////////////////////////////////////////////////////
  //
  //  METHODS
  //
  //////////////////////////////////////////////////////////////////////
  
  /**
   *  Initialization of the module map that contains all important information
   *  for this module.
   *
   *  @return map The map that contains all information about the module osr_module_partition.
   */
  define OSRPartitionInit() ``{
      
      map osr_module_partition = $[];

      osr_module_partition = $[
		   // has to be the name of the file
		   "name"              :  "osr_module_partition",
		   "headline"          :  _("Partitions and filesystems"),
		   "summary"           :  [],
		   "test_mode_summary" :  [
					   $["header" : "Partitions and filesystems", "description" : "O.k.", status : "detect_ok"],
					   $["header" : "Partitions and filesystems", "description" : "O.k.", status : "detect_ok"]
		   ],

		   // the sequence of the detection methods of this module
		   "detect_methods"    :  [
				    	   ``(OSRPartitionCheckDisks()),
					   ``(OSRPartitionCheckPartitions()),
					   ``(OSRPartitionMountRoot())
		   ],

		   // the values this module requires from other modules of the rescue system
		   // use "yast2 osr .provides" to create the file "/tmp/osr_global_provides" to
		   // show which values are already provided
		   "requires"          :  [
					   //"target_map",
					   //"disk_device_list"
		   ],

		   // the values this module will provide
		   "provides"          : $[
					   "root_partition"        : $["type" : "string", "value" : "/dev/hda1", "status" : "unknown"],
					   "valid_root_partitions" : $["type" : "list", "value" : [], "status" : "unknown"],
					   "target_partition_map"  : $["type" : "map", "value" : $[], "status" : "unknown"],
					   "target_scrpath_map"    : $["type" : "map", "value" : $[], "status" : "unknown"]
		   ],

		   // informations for the module progress bar
		   "progress_file"     : "/tmp/osr_module_partition_progress",
		   "progress_expect"   : 1000
      ];

      return osr_module_partition;
  };

  //////////////////////////////////////////////////////////////////////
  //
  //  DETECTION METHODS
  //
  //////////////////////////////////////////////////////////////////////
  
  /**
   *  Checks the harddisks. Attention: if there are SCSI disks connected the SCSI kernel module
   *  has to be loaded first (TODO??).
   *
   *  Requires: %
   *  Provides: map target_partition_map,
   *            map target_scrpath_map
   *
   *  @return map The result map.
   */
  global define OSRPartitionCheckDisks() ``{

      boolean repair_question = false;
      string  error_message   = "";
      string  help_text       = "";
      string  status          = "";
      string  module_name     = "osr_module_partition";
      map     target_map      = $[];
      map     result_map      = $[];
      list    disk_list       = [];
      
      target_map = lookup(user_settings, "targets", $[]);

      // get the names of detected harddisks and put them in the list -> ["/dev/hda", "/dev/sda"]
      disk_list = maplist(`k, `v, target_map, ``(k));

      if ((target_map == $[]) || (target_map == nil))
      {
	  status = OSRStatusDetectError();

	  OSRSummaryDetectError(
				module_name,
				_("Checking disks"),
				_("No disks found")
				);

	  // TODO: if no harddisk was found, exit the rescue system
	  return $["status" : status];
      }
      else
      {
	  status = OSRStatusDetectOK();

	  OSRSummaryDetectOK(
			     module_name,
			     _("Checking disks"),
			     sformat(_("Disks found: <code>%1</code>"), mergestring(disk_list, "</code>, <code>"))
			     );
      }

      // check all targets (all disks) for partition entries
      foreach(`target, `values, target_map, ``{

	  list target_partitions = lookup(values, "partitions", []);
	  path target_scrpath    = lookup(values, "scrpath", .);

	  OSRProvideMap("target_partition_map", $[target : target_partitions]);
	  OSRProvideMap("target_scrpath_map", $[target : target_scrpath]);
	  
      	  if (size(target_partitions) == 0)
	  {
	      status = OSRStatusDetectError();

	      OSRSummaryDetectError(
				    module_name,
				    _("Checking partition tables"),
				    sformat(_("No partition table found for disk %1"), target)
				    );

	      error_message = sformat(_("No partition table found for disk %1.

If you have a YaST2 OS Repair floppy with some
up-to-date system information from a former
rescue session, insert it in your drive and
press Repair.

Press Skip, and repair manually, if you have
a backup of the partition table of disk
%1.

Press Help, if you want to get to know how to
make a backup of a partition table manually
and how to revert it."), target);

	      help_text = sformat(_("
<h3>No partition table found for harddisk %1.</h3>

<p>Repair will search for a valid partition table of disk %1
on the inserted floppy disk. If YaST2 OS Repair can't find
one it will start the program gpart to guess the lost
partition table. You can decide if the information gpart
finds is valid or not...</p>

<p>\"gpart may be of some help when the primary partition table
was lost or destroyed but it can under no circumstances
replace proper disk/partition table backups. To save the
master boot record (MBR) including the primary partition
table to the file /tmp/hda.mbr type

<pre>
$ dd if=/dev/hda of=/tmp/hda.mbr bs=512 count=1
</pre>

exchanging /dev/hda with the block device name of the disk
in question. This should be done for all disks in the system.
To restore the primary partition table without overwriting
the MBR type

<pre>
$ dd if=/tmp/hda.mbr of=/dev/hda bs=1 count=64 skip=446 seek=446
</pre></p>

<p>Warning: make sure that all parameters are typed as shown
and that the disk device is correct. Failing to do so may
result in severe filesystem corruption. The saved file
should be stored in a safe place like a floppy disk.\"<p>

<p>From the manual page of gpart:<br>
\"It should be stressed that gpart does a very heuristic
job, never believe its output without any plausability
checks. It can be easily right in its guesswork but it can
also be terribly wrong. You have been warned.\"</p>"), target);

	      repair_question = OSRPopupRepair(_("Error detected"), error_message, help_text);

	      if (repair_question)
	      {
		  string  disk_name     = select(splitstring(target, "/"), (size(splitstring(target, "/"))-1));
		  string  ptbl_name     = "" + disk_name + ".ptbl";
		  boolean has_floppy    = lookup(user_settings, "has_floppy", true);
		  string  floppy_device = lookup(user_settings, "floppy_device", "/dev/fd0");

		  if (has_floppy)
		  {
		      y2milestone("Has floppy.");
		      
		      UI::OpenDialog(`opt(`decorated), `Label(_("Loading system information...")));

                      // loop: read the partition table from floppy
		      repeat
			  {
			      // mount the floppy to /media/floppy/
			      boolean mounted = (WFM::Execute(.local.bash,
							      "/bin/mount " + floppy_device + " /media/floppy -t auto") == 0);

			      // be careful: only read the file /media/floppy/osr_map.ycp if the floppy was mounted
			      // correctly!
			      if (mounted)
			      {
				  y2milestone("Mount of floppy was successful.");
				  
				  integer ptbl_check = SCR::Read(.target.size, "/media/floppy/" + ptbl_name);

				  if (ptbl_check == 512)
				  {
				      y2milestone("Partition table exists and its size is 512 bytes.");
				      
				      UI::CloseDialog();

				      string command = sformat("dd if=/media/floppy/%1 of=%2 bs=1 count=64 skip=446 seek=446",
							       ptbl_name, target);

				      UI::OpenDialog(`opt(`decorated), `Label(_("Reverting old partition table...")));

				      integer revert = WFM::Execute(.local.bash, command);

				      if (revert == 0)
				      {
					  y2milestone("Reverting the partition table was successful.");
					  
					  // read the partition table
					  string partition_path  = ".disk" + target_scrpath + ".partitions";
					  list   partition_table = SCR::Read(topath(partition_path));

					  if ((partition_table != nil) && (partition_table != []))
					  {
					      // o.k., partition table successfully reverted.
					      y2milestone("Reading the new partition table was successful.");

					      status = OSRStatusRepairOK();

					      OSRSummaryRepairOK(
								 module_name,
								 _("Repairing partition table"),
								 _("Reverted old partition table")
								 );

					      OSRProvideMap("target_partition_map", $[target : partition_table]);

					      // construct an updated "targets" map and store it in the global map "user_settings"
					      map partition_map = $["partitions" : partition_table];
					      target_map        = add(target_map, target, partition_map);
					      user_settings     = add(user_settings, "targets", target_map);

					      // umount the floppy after reading
					      WFM::Execute(.local.bash, "/bin/umount /media/floppy");
  
					      UI::CloseDialog();

					      OSRModuleProgressFill();

					      return $["status" : status];
					  }
					  else
					  {
					      y2error("Reverting of the partition table was not successfull.");

					      // umount the floppy after reading
					      WFM::Execute(.local.bash, "/bin/umount /media/floppy");

					      error_message = sformat(_("An old partition table was found for disk %1
but it could not be reverted successfully.

If you have a YaST2 OS Repair floppy with some
up-to-date system information from a former
rescue session, insert it in your drive and
press Repair.

Press Skip, and repair manually, if you have
a backup of the partition table of disk
%1.

Press Help, if you want to get to know how to
make a backup of a partition table manually
and how to revert it."), target);

					      repair_question = OSRPopupRepair(_("Reverting of the partition table not successful"),
									       error_message, help_text);
					  }  // if ((partition_table != nil) && (partition_table != []))

				      }
				      else
				      {
					  y2error("Reverting of the partition table was not successfull.");

					  // umount the floppy after reading
					  WFM::Execute(.local.bash, "/bin/umount /media/floppy");
					  
					  error_message = sformat(_("An old partition table was found for disk %1
but it could not be reverted successfully.

If you have a YaST2 OS Repair floppy with some
up-to-date system information from a former
rescue session, insert it in your drive and
press Repair.

Press Skip, and repair manually, if you have
a backup of the partition table of disk
%1.

Press Help, if you want to get to know how to
make a backup of a partition table manually
and how to revert it."), target);

					  repair_question = OSRPopupRepair(_("Reverting of the partition table not successful"),
									   error_message, help_text);
				      }  // if (revert == 0)
				  }
				  else
				  {
				      y2error("file %1 does not exist or is not of the correct size of 512 bytes.",
					      "/media/floppy/" + ptbl_name);

				      // umount the floppy after reading
				      WFM::Execute(.local.bash, "/bin/umount /media/floppy");
		      
				      error_message = sformat(_("It was not possible to find a valid
partition table for disk %1 on the floppy.

If you have a YaST2 OS Repair floppy with some
up-to-date system information from a former
rescue session, insert it in your drive and
press Repair.

Press Skip, and repair manually, if you have
a backup of the partition table of disk
%1.

Press Help, if you want to get to know how to
make a backup of a partition table manually
and how to revert it."), target);

				      repair_question = OSRPopupRepair(_("No valid partition table found on floppy"),
								       error_message, help_text);
				  }  // if (ptbl_check == 512)
			      }
			      else
			      {
				  y2error("Floppy could not be mounted.");

				  error_message = sformat(_("Either no floppy disk was inserted into
the drive or the inserted floppy is not
correctly formatted.

If you have a YaST2 OS Repair floppy with some
up-to-date system information from a former
rescue session, insert it in your drive and
press Repair.

Press Skip, and repair manually, if you have
a backup of the partition table of disk
%1.

Press Help, if you want to get to know how to
make a backup of a partition table manually
and how to revert it."), target);

				  repair_question = OSRPopupRepair(_("Floppy could not be mounted"), error_message, help_text);

			      }  // if (mounted)
			  }
		      until(!repair_question);
		      
		      // umount the floppy after reading
		      WFM::Execute(.local.bash, "/bin/umount /media/floppy");
  
		      UI::CloseDialog();
		  }

		  // TODO: launch gpart, if the partition table could not be reverted
	      }
	      else
	      {
		  status = OSRStatusRepairOmit();

		  OSRSummaryRepairOmit(
				       module_name,
				       _("Repairing partition table"),
				       _("partition table not repaired")
				       );
	      }
	  }
	  else
	  {
	      status = OSRStatusDetectOK();

	      OSRSummaryDetectOK(
				 module_name,
				 _("Checking partition tables"),
				 sformat(_("Partition tables found for disk <code>%1</code>"), target)
				 );
	  }
      });  // foreach(`target, `values, target_map, ...
      
      // set the value of the module progress bar to 100%
      OSRModuleProgress::Fill();
      
      return $["status" : status];
  };

  /**
   *  Checks the detected partitions for valid filesystems, mounts them and searches for
   *  filesystem tables (/etc/fstab) on the partitions.
   *
   *  Requires: %
   *  Provides: list valid_root_partitions,
   *            string root_partition
   *
   *  @return map The result_map.
   */
  global define OSRPartitionCheckPartitions() ``{

      boolean repair_question           = false;
      integer progress_expect           = 40;
      string  module_name               = "osr_module_partition";
      string  help_text                 = "";
      string  error_message             = "";
      string  progress_file             = "";
      string  progress_label            = _("Checking the partitions and filesystems");
      string  log_file                  = "";
      string  status                    = "";
      map     result_map                = $[];
      map     target_map                = $[];
      list    linux_partition_list      = [];
      string  root_partition            = "";
      list    mount_possible_list       = [];
      list    mounted_partitions        = [];
      list    valid_root_partition_list = [];

      module_map     = OSRGetModuleMap(module_name);
      log_file       = OSRLogFile::GetFile();
      progress_file  = lookup(module_map, "progress_file", "");

      // set the parameters for the module progress bar
      OSRModuleProgress::SetParams(progress_label, progress_file, progress_expect);

      target_map = lookup(user_settings, "targets", $[]);

      /////////////////////////////////////////////////////////
      //
      // search for currently mounted partitions
      //
      /////////////////////////////////////////////////////////

      mounted_partitions = GetMountedPartitions();

      if (size(mounted_partitions) <= 0)
      {
	  // no mounted partitions: not implicitly an error!
	  status = OSRStatusDetectOK();
	  
	  OSRSummaryDetectOK(
			     module_name,
			     _("Searching for currently mounted partitions"),
			     _("No mounted partitions found")
			     );
      }
      else
      {
	  // create a mount-like output
	  list mounted_output = maplist(`entry, mounted_partitions,
					``("<code>" + lookup(entry, "name", "") +
					   "</code> on <code>" + lookup(entry, "mountpoint", "") +
					   "</code> type " + lookup(entry, "fstype", "") +
					   "</code> " + lookup(entry, "perm", "")));
	  
	  status = OSRStatusDetectOK();
	  
	  OSRSummaryDetectOK(
			     module_name,
			     _("Searching for currently mounted partitions"),
			     sformat(_("Mounted partitions found:<br>%1"), mergestring(mounted_output, "<br>"))
			     );
      }

      //////////////////////////////////////////////////
      //
      // search for valid Linux partitions
      //
      //////////////////////////////////////////////////

      // get the partitions with a valid linux partition id from the target_map
      linux_partition_list = GetLinuxPartitions(target_map);

      if (size(linux_partition_list) <= 0)
      {
	  status = OSRStatusDetectError();

	  OSRSummaryDetectError(
				module_name,
				_("Searching for valid linux partitions"),
				_("No valid partition types found")
				);
	  // TODO: display and exit, start installation or partitioning instead

	  //return ($["status" : status]);
      }
      else
      {
	  status = OSRStatusDetectOK();
	      
	  OSRSummaryDetectOK(
			     module_name,
			     _("Searching for valid linux partitions"),
			     sformat(_("Valid linux partitions found:<br><code>%1</code>"),
				     mergestring(linux_partition_list, ", "))
			     );
      }

      /////////////////////////////////////////////////////////
      //
      // search for mountable partitions
      //
      /////////////////////////////////////////////////////////

      mount_possible_list = GetMountablePartitions(linux_partition_list);
            
      //y2error("mounted_partitions: %1", mounted_partitions);

      if (size(mount_possible_list) > 0)
      {
	  status = OSRStatusDetectOK();
	  
	  OSRSummaryDetectOK(
			     module_name,
			     _("Searching for mountable partitions"),
			     sformat("Mountable partitions found:<br><code>%1</code>",
				     mergestring(mount_possible_list, ", "))
			     );
      }
      else
      {
	  status = OSRStatusDetectError();
	  
	  OSRSummaryDetectError(
				module_name,
				_("Searching for mountable partitions"),
				_("No mountable partitions found")
				);

	  // TODO: display and exit, start installation or partitioning instead
	  
	  //return ($["status" : status]);
      }

      /////////////////////////////////////////////////////////////////
      //
      // search for valid root partitions with a filesystem table
      //
      /////////////////////////////////////////////////////////////////

      valid_root_partition_list = GetValidRootPartitions(mount_possible_list);

      OSRProvideList("valid_root_partitions", valid_root_partition_list);

      if (size(valid_root_partition_list) <= 0)
      {
	  status = OSRStatusDetectError();
	  
	  OSRSummaryDetectError(
				module_name,
				_("Searching for valid root partitions"),
				_("No valid root partition found")
				);

	  // TODO: display and exit, start installation instead
	  
	  //return ($["status" : status]);
      }
      else if (size(valid_root_partition_list) == 1)
      {
	  root_partition = select(valid_root_partition_list, 0);

	  OSRProvideString("root_partition", root_partition);

	  status = OSRStatusDetectOK();
	  
	  OSRSummaryDetectOK(
			     module_name,
			     _("Searching for valid root partitions"),
			     sformat("One valid partition found: <code>%1</code>", root_partition)
			     );
      }
      else
      {
	  // several valid root partitions found
	  status = OSRStatusDetectOK();
	  
	  OSRSummaryDetectOK(
			     module_name,
			     _("Searching for valid root partitions"),
			     sformat("Several valid root partitions found:<br><code>%1</code>",
				     mergestring(valid_root_partition_list, ", "))
			     );

	  // launch a popup with a RadioButtonGroup - one button for each item in the list -
	  // and let the user select the root partition
	  root_partition = OSRPopupSelectItem(
					      _("Select root partition"),
					      _("There exist several valid root partitions in your system.
You have to select one item in the list."),
					      valid_root_partition_list,
					      "",
					      true
					      );
	  
	  OSRProvideString("root_partition", root_partition);
      }
      
      status = OSRStatusDetectOK();
      
      result_map = $["status" : status];

      // set the value of the module progress bar to 100%
      OSRModuleProgress::Fill();
      
      return result_map;
  };


  /**
   *  Mount the root partition and all reachable, local and valid partitions from the
   *  detected filesystem table "/etc/fstab".
   *
   *  Requires: list valid_root_partitions,
   *            string root_partition
   *  Provides: 
   *
   *  @return map The result_map.
   */
  global define OSRPartitionMountRoot() ``{

      string  status                = "";
      string  module_name           = "osr_module_partition";
      list    valid_root_partitions = [];
      string  root_partition        = "";
      boolean mount_successful      = true;
      list    fstab                 = [];
      string  message               = "";
      map     root_partition_map    = $[];
      list    mounted_partitions    = [];
      
      // get all valid root partitions
      valid_root_partitions = OSRRequireList("valid_root_partitions");

      // get the selected root partition
      root_partition = OSRRequireString("root_partition");

      // check the root partition with fsck
      if (IsExt2fs(root_partition))
      {
	  status = OSRStatusDetectOK();
	  
	  OSRSummaryDetectOK(
			     module_name,
			     sformat(_("Checking filesystem of root partition: <code>%1</code>"), root_partition),
			     _("Filesystem type: Ext2fs")
			     );

	  // CheckExt2fs returns the exit code of the e2fsck command
	  integer check_ext2fs = CheckExt2fs(root_partition);
	  
	  if (check_ext2fs == 0)
	  {
	      status = OSRStatusDetectOK();
	  
	      OSRSummaryDetectOK(
				 module_name,
				 sformat(_("Checking filesystem of root partition: <code>%1</code>"), root_partition),
				 _("Filesystem is o.k.")
				 );
	  }
	  else
	  {
	      status = OSRStatusDetectError();
	  
	      OSRSummaryDetectError(
				    module_name,
				    sformat(_("Checking filesystem of root partition: <code>%1</code>"), root_partition),
				    _("Filesystem is corrupted")
				    );
	  }
      }
      else if (IsReiserfs(root_partition))
      {
	  status = OSRStatusDetectOK();
	  
	  OSRSummaryDetectOK(
			     module_name,
			     sformat(_("Checking filesystem of root partition: <code>%1</code>"), root_partition),
			     _("Filesystem type: Reiserfs")
			     );

	  // CheckReiserfs returns the exit code of the reiserfsck command
	  integer check_reisrfs = CheckReiserfs(root_partition, "");
	  
          if (check_reiserfs == 0)
	  {
	      status = OSRStatusDetectOK();
	  
	      OSRSummaryDetectOK(
				 module_name,
				 sformat(_("Checking filesystem of root partition: <code>%1</code>"), root_partition),
				 _("Filesystem is o.k.")
				 );
	  }
	  else
	  {
	      status = OSRStatusDetectError();
	  
	      OSRSummaryDetectError(
				    module_name,
				    sformat(_("Checking filesystem of root partition: <code>%1</code>"), root_partition),
				    _("Filesystem is corrupted")
				    );
	  }
      }
      
      // if there is one: mount it
      // if there are several: select-popup
      // if there is none: display and exit

      // get the fstab, use the agent .etc.fstab1

      // check all entries in the fstab
      // are they local, existing, mountable...?

      // check all entries in the fstab with fsck
      // mount all valid entries in the fstab

      //y2milestone("selected partition: %1", partition );

      /*
      root_partition_map = GetMountedRootPartition();

      if (lookup(root_partition_map, "name", "") == partition)
      {
	  y2debug("The specified partition \"%1\" is the currently mounted partition: %2", partition, root_partition_map);

	  //return true;
      }
      */

      // check if the specified partition is already mounted to "/mnt", mount only if it is not already done.
      if (!IsMountedTo(root_partition, "/mnt"))
      {
	  // Mount selected partition to /mnt
	  mount_successful = SCR::Execute(.target.mount, [root_partition,"/mnt"]);

	  if (mount_successful)
	  {
	      status = OSRStatusDetectOK();
	  
	      OSRSummaryDetectOK(
				 module_name,
				 _("Mounting the root partition"),
				 _("Root partition successfully mounted to <code>/mnt</code>")
				 );
	  }
	  else
	  {
	      status = OSRStatusDetectError();
	  
	      OSRSummaryDetectError(
				 module_name,
				 _("Mounting the root partition"),
				 _("Root partition was not successfully mounted to <code>/mnt</code>")
				 );
	  }
	  
      }
      else
      {
	  status = OSRStatusDetectOK();
	  
	  OSRSummaryDetectOK(
			     module_name,
			     _("Mounting the root partition"),
			     _("Root partition is already mounted to <code>/mnt</code>")
			     );

	  mount_successful = true;
      }
      
      //if ( !test_mode )
      //{
          if (mount_successful)
	  {
	      // searching for the file /etc/fstab
	      list mountpoint_list = GetMountpoints(root_partition);

	      // select one of the mountpoints from the list, not important which one of them is chosen
	      string mountpoint = select(mountpoint_list, 0, "");
	      
	      // TODO: is this true? what if booting from cdrom?
	      integer fstab_size = SCR::Read(.target.size, "" + mountpoint + "/etc/fstab");

	      if (fstab_size == nil)
	      {
		  y2error("Agent-error, SCR::Read(.target.size, \"%1\") returns nil", "" + mountpoint + "/etc/fstab");
	      }
	      else if (fstab_size < 0)
	      {
		  y2error("No fstab found at %1", "" + mountpoint + "/etc/fstab");
	      }
	      else if (fstab_size == 0)
	      {
		  y2debug("The file %1 exists but is empty??", "" + mountpoint + "/etc/fstab");
	      }
	      else
	      {
		  y2debug("Fstab found, size of the file %1: %2", "" + mountpoint + "/etc/fstab", fstab_size);
	      }

	      /*
	      UI::OpenDialog(`opt(`decorated), `Label(sformat("Searching /etc/fstab\nfile-size: %1", fstab_size)));
	      sleep(2000);
	      UI::CloseDialog();
	      */
	      
	      // Reading the fstab from the mounted root partition
	      fstab = SCR::Read(.etc.fstab1, ["" + mountpoint + "/etc/fstab"]);
	      
	      if (fstab == nil)
	      {
		  y2error("Something's wrong with the .etc.fstab1-agent");
		  message = _("No fstab found!!");

		  status = OSRStatusDetectError();
	  
		  OSRSummaryDetectError(
				     module_name,
				     _("Searching filesystem table"),
				     _("The fstab agent reported an error")
				     );

	      }
	      else if (size(fstab) == 0)
	      {
		  y2error("No fstab found !!");
		  message = _("No fstab found!!");

		  status = OSRStatusDetectError();
	  
		  OSRSummaryDetectError(
					module_name,
					_("Searching filesystem table"),
					_("No filesystem table found")
					);

	      }
	      else
	      {
		  status = OSRStatusDetectOK();
	  
		  OSRSummaryDetectOK(
				     module_name,
				     _("Searching filesystem table"),
				     _("Filesystem table found")
				     );
	  
		  y2milestone("fstab :%1 ", fstab );

		  // mount resp. swapon all partitions mentioned in the fstab
		  foreach( `fstab_entry, fstab, ``{
		  
		      string vfstype = lookup(fstab_entry, "vfstype", "");
		      string mntops  = lookup(fstab_entry, "mntops", "");
		      string spec    = lookup(fstab_entry, "spec", "");
		      string file    = lookup(fstab_entry, "file", "");

		      // mounting the "normal" filesystems
		      // attention: "nfs"-filesystems are not mounted here!
		      if ((vfstype == "ext" || vfstype == "ext2" || vfstype == "minix" || vfstype == "reiserfs" ||
			   vfstype == "xiafs" || vfstype == "hpfs" || vfstype == "vfat") &&
			  (file != "/") && (!issubstring(mntops,"noauto")))
		      {
			  if (MountFstabEntry(fstab_entry))
			  {
			      status = OSRStatusDetectOK();

			      OSRSummaryDetectOK(
						 module_name,
						 sformat(_("Mounting partition %1 to %2"), spec, file),
						 _("Mounting succeeded")
						 );
			  }
			  else
			  {
			      status = OSRStatusDetectError();

			      OSRSummaryDetectError(
						    module_name,
						    sformat(_("Mounting partition %1 to %2"), spec, file),
						    _("Mounting failed")
						    );

			  }
		      }

		      // include swap-partitions
		      if ((vfstype == "swap")  && (file == "swap"))
		      {
			  // check if the swap partition is already swapped on

			  // proc_swaps looks like:
			  // [$["file":"/dev/sda1", "priority":"42", "size":"52200", "type":"partition", "used":"21336"]]
			  list proc_swaps = SCR::Read(.proc.swaps);

			  // Check if the specified swap-partition is already "swapped", if true don't swapon.
			  // filter(...) returns a list of all "swapped" partitions where the name equals to the specified partition
			  if (size(filter(`swap_partition, proc_swaps, ``(lookup(swap_partition, "file", "") == spec))) > 0)
			  {
			      y2debug("Swap-partition \"%1\" is already swapped-on!", spec);

			      status = OSRStatusDetectOK();

			      OSRSummaryDetectOK(
						 module_name,
						 sformat(_("Adding partition %1 to swap"), spec),
						 sformat(_("Partition %1 already added to swap"), spec)
						 );
			  }
			  else
			  {
			      if (SwaponFstabEntry(fstab_entry))
			      {
				  status = OSRStatusDetectOK();

				  OSRSummaryDetectOK(
						     module_name,
						     sformat(_("Adding partition %1 to swap"), spec),
						     _("Swapon succeeded")
						     );
			      }
			      else
			      {
				  status = OSRStatusDetectError();

				  OSRSummaryDetectError(
							module_name,
							sformat(_("Adding partition %1 to swap"), spec),
							_("Swapon failed")
							);
			      }
			  }
		      }
		  });
	      }
	  }
	  else
	  {
	      message = _("Partitions could not be mounted.
Check log-file : /var/log/y2log.");
	      y2error("Could not mount root-partition to /mnt");
	  } // end: if (mount_successful)
	  
	  //} //end: if (test_mode)
            
      status = OSRStatusDetectOK();
      
      result_map = $["status" : status];

      // set the value of the module progress bar to 100%
      OSRModuleProgress::Fill();
      
      return result_map;

  };
  
  //////////////////////////////////////////////////////////////////////
  //
  //  MAIN
  //
  //////////////////////////////////////////////////////////////////////

  // in init mode only execute the init function and return the module map
  // to the framework, don't delete
  if (init_mode)
  {
      map module_map = OSRPartitionInit();

      return module_map; 
  }
  // end MAIN
}
