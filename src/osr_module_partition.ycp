/**
 * File:
 *   osr_module_partition.ycp
 *
 * Module:
 *   Partition and filesystems checking module.
 *
 * Summary:
 *   YaST2 OS Repair. Automatic error detection & repair tool for Linux.
 *
 * Author:
 *   Michael Koehrmann <curry@suse.de>
 *
 * $Id$
 */

{
  textdomain "osr";

  include "osr/common_filesystem.ycp";

  // begin argument handling: in the initial phase the framework calls each module
  // with the argument ".init", don't delete!
  integer arg_c = size(Args());
  integer arg_n = 0;

  boolean init_mode = false;

  while ( arg_n < arg_c )
  {
      if ( Args(arg_n) == .init )
      {
	  init_mode = true;

	  y2milestone("Argument: %1", Args(arg_n));
      }
      else
      {
	  y2error("ERROR: unknown option %1", Args(arg_n) );

	  return $[];
      }
      arg_n = arg_n + 1;
  }
  // end argument handling
  
  //////////////////////////////////////////////////////////////////////
  //
  //  METHODS
  //
  //////////////////////////////////////////////////////////////////////
  
  /**
   *  Initialization of the module map that contains all important information
   *  for this module.
   *
   *  @return map The map that contains all information about the module osr_module_partition.
   */
  define OSRPartitionInit() ``{
      
      map osr_module_partition = $[];

      osr_module_partition = $[
		   // has to be the name of the file
		   "name"              :  "osr_module_partition",
		   "headline"          :  _("Partitions and filesystems"),
		   "summary"           :  [],
		   "test_mode_summary" :  [
					   $["header" : "Partitions and filesystems", "description" : "O.k.", status : "detect_ok"],
					   $["header" : "Partitions and filesystems", "description" : "O.k.", status : "detect_ok"]
		   ],

		   // the sequence of the detection methods of this module
		   "detect_methods"    :  [
				    	   ``(OSRPartitionCheckDisks()),
					   ``(OSRPartitionCheckPartitions()),
					   ``(OSRPartitionMountRoot())
		   ],

		   // the values this module requires from other modules of the rescue system
		   // use "yast2 osr .provides" to create the file "/tmp/osr_global_provides" to
		   // show which values are already provided
		   "requires"          :  [
					   "has_floppy",
					   "floppy_device"
		   ],

		   // the values this module will provide
		   "provides"          : $[
					   "just_mounted"          : $["type" : "list", "value" : [], "status" : "unknown"],
					   "probe_disk_list"       : $["type" : "list", "value" : [], "status" : "unknown"],
					   "root_partition"        : $["type" : "string", "value" : "/dev/hda1", "status" : "unknown"],
					   "root_mountpoint"       : $["type" : "string", "value" : "/mnt", "status" : "unknown"],
					   "valid_root_partitions" : $["type" : "list", "value" : [], "status" : "unknown"],
					   "target_partition_map"  : $["type" : "map", "value" : $[], "status" : "unknown"],
					   "target_scrpath_map"    : $["type" : "map", "value" : $[], "status" : "unknown"],
					   "valid_swap_partitions" : $["type" : "list", "value" : [], "status" : "unknown"],
					   "valid_target_list"     : $["type" : "list", "value" : [], "status" : "unknown"],
					   "swapable_partitions"   : $["type" : "list", "value" : [], "status" : "unknown"]
		   ],

		   // informations for the module progress bar
		   "progress_file"     : OSRGetTmpDir() + "/osr_module_partition_progress",
		   "progress_expect"   : 1000
      ];

      return osr_module_partition;
  };

  //////////////////////////////////////////////////////////////////////
  //
  //  DETECTION METHODS
  //
  //////////////////////////////////////////////////////////////////////
  
  /**
   *  Checks the harddisks. Attention: if there are SCSI disks connected the SCSI kernel module
   *  has to be loaded first (TODO??).
   *
   *  Provides: map target_partition_map,
   *            map target_scrpath_map,
   *            list disk_device_list,
   *            list probe_disk_list,
   *            list valid_target_list
   *
   *  Requires: string floppy_device,
   *            boolean has_floppy
   *
   *  @return map The result map.
   */
  global define OSRPartitionCheckDisks() ``{

      boolean repair_question    = false;
      string  error_message      = "";
      string  help_text          = "";
      string  status             = "";
      string  severity           = "";
      string  module_name        = "osr_module_partition";
      map     target_map         = $[];
      map     result_map         = $[];
      list    disk_list          = [];
      string  progress_label     = _("Checking disks");
      string  progress_file      = "";
      integer progress_expect    = 120;
      integer progress_increment = 0;
      list    valid_target_list  = [];

      progress_file = lookup(module_map, "progress_file", "");

      // setting up the progress bar
      OSRModuleProgress::SetParams(progress_label, progress_file, progress_expect);
      
      target_map = lookup(user_settings, "targets", $[]);

      // TODO: use the module_progress_bar

      // get the names of detected harddisks and put them in the list -> ["/dev/hda", "/dev/sda"]
      disk_list = maplist(`k, `v, target_map, ``(k));

      OSRProvideList("disk_device_list", disk_list);

      // compute the increment of the progress bar
      progress_increment = ((progress_expect / size(disk_list)) / 2);

      ///////////////////////////////////////////////////////////////////////////////////
      //
      //  Check all disks for entries in their map
      //
      ///////////////////////////////////////////////////////////////////////////////////
      
      if ((size(target_map) == 0) || (target_map == nil))
      {
	  status   = OSRStatusDetectError();
	  severity = OSRErrorSeverityBlocking();

	  OSRSummaryDetectError(
				module_name,
				_("Searching for harddisks"),
				_("No harddisks detected")
				);

	  error_message = _("YaST2 OS Repair could not detect any harddisks
in your system. Probably you have to load the
correct kernel modules.

YaST2 OS Repair halts now.");

	  // display the error message, only a OK pushbutton
	  UI::MessagePopup(error_message);
	  
	  // if no harddisk was found, exit the rescue system
	  return $[
		   "status"        : status,
		   "severity"      : severity
	  ];
      }
      else if (size(target_map) == 1)
      {
	  status = OSRStatusDetectOK();

	  OSRSummaryDetectOK(
			     module_name,
			     _("Searching for harddisks"),
			     // "%1": will be replaced with a string like "/dev/hda" or "/dev/sda"
			     sformat(_("One harddisk detected: %1"), select(disk_list, 0))
			     );
      }
      else if (size(target_map) > 1)
      {
	  status = OSRStatusDetectOK();

	  OSRSummaryDetectOK(
			     module_name,
			     _("Searching for harddisks"),
			     // "%1": will be replaced with a string like "/dev/hda, /dev/hdb, /dev/sda"
			     sformat(_("Several harddisks detected: %1"), mergestring(disk_list, ", "))
			     );

	  /*
	  // TODO: let the user select which ones of the harddisks to be used
	  list selected_target_list = [];

	  while (size(selected_target_list) = 0)
	  {
	      selected_target_list = OSRPopupCheckBoxGroup(_(), _(), );

	  }
	  */
      }

      // probe all harddisks save the list
      list probe_disk_list = SCR::Read(.probe.disk);

      if ((probe_disk_list != nil) && (probe_disk_list != []))
      {
	  OSRProvideList("probe_disk_list", probe_disk_list);
      }

      ///////////////////////////////////////////////////////////////////////////////////
      //
      //  Iterate all harddisks, check for partitions
      //
      ///////////////////////////////////////////////////////////////////////////////////

      // check all targets (all disks) for partition entries
      foreach(`target, `values, target_map, ``{
	  
	  list    target_partitions = lookup(values, "partitions", []);
	  path    target_scrpath    = lookup(values, "scrpath", .);
	  boolean repair_succeeded  = false;

	  OSRModuleProgress::Add(progress_increment);

	  if (size(target_partitions) > 0)
	  {
	      OSRProvideMap("target_partition_map", $[target : target_partitions]);
	  }

	  if (target_scrpath != .)
	  {
	      OSRProvideMap("target_scrpath_map", $[target : target_scrpath]);
	  }
	  
      	  if (size(target_partitions) == 0)
	  {
	      status = OSRStatusDetectError();

	      OSRSummaryDetectError(
				    module_name,
				    _("Checking partition tables"),
				    // "%1": will be replaced with "/dev/hda", "/dev/sda", ...
				    sformat(_("No partition table found for disk %1"), target)
				    );

	      // "%1"; will be replaced with "/dev/hda", "/dev/sda", ...
	      error_message = sformat(_("No partition table found for disk %1.

If you have a YaST2 OS Repair floppy with some
up-to-date system information from a former
rescue session, insert it in your drive and
press Repair.

Press Skip and repair manually if you have
a backup of the partition table of disk
%1.

Press Help if you want to get to know how to
make a backup of a partition table manually
and how to revert it."), target);

	      help_text = sformat(_("
<h3>No partition table found for harddisk %1.</h3>

<p>Repair will search for a valid partition table of disk %1
on the inserted floppy disk. If YaST2 OS Repair can't find
one it will start the program gpart to guess the lost
partition table. You can decide if the information gpart
finds is valid or not...</p>

<p>\"gpart may be of some help when the primary partition table
was lost or destroyed but it can under no circumstances
replace proper disk/partition table backups. To save the
master boot record (MBR) including the primary partition
table to the file /tmp/hda.mbr type

<pre>
$ dd if=/dev/hda of=/tmp/hda.mbr bs=512 count=1
</pre>

exchanging /dev/hda with the block device name of the disk
in question. This should be done for all disks in the system.
To restore the primary partition table without overwriting
the MBR type

<pre>
$ dd if=/tmp/hda.mbr of=/dev/hda bs=1 count=64 skip=446 seek=446
</pre></p>

<p>Warning: make sure that all parameters are typed as shown
and that the disk device is correct. Failing to do so may
result in severe filesystem corruption. The saved file
should be stored in a safe place like a floppy disk.\"<p>

<p>From the manual page of gpart:<br>
\"It should be stressed that gpart does a very heuristic
job, never believe its output without any plausability
checks. It can be easily right in its guesswork but it can
also be terribly wrong. You have been warned.\"</p>"), target);

	      ///////////////////////////////////////////////////////////////////////////////////
	      //
	      //  Repair partition table with backup from floppy
	      //
	      ///////////////////////////////////////////////////////////////////////////////////

	      repair_question  = OSRPopupRepair(_("Error detected"), error_message, help_text);
	      repair_succeeded = false;

	      // repair
	      while (repair_question && !repair_succeeded)
	      {
		  // e.g. if target = "/dev/hda": disk_name = "hda"
		  // TODO: use another function: get_device_name()     partition_defines.ycp
		  string  disk_name     = select(splitstring(target, "/"), (size(splitstring(target, "/"))-1));

		  // the name of the primary partition table saved to floppy, e.g. "hda.ptbl"
		  string  ptbl_name     = disk_name + ".ptbl";

		  string  floppy_device = OSRRequireString("floppy_device");
		  boolean has_floppy    = OSRRequireBoolean("has_floppy");

		  if (has_floppy)
		  {
		      // Umount everything from "/media/floppy" or from deeper directories
		      // before mounting the floppy.
/*
		      if (UmountAllFrom("/media/floppy"))
		      {
			  y2milestone("All devices were successfully umounted from /media/floppy.");
		      }
*/
		      // mount the floppy to /media/floppy/
		      boolean mounted = (OSRExecuteCommand(.local.bash,
							   "/bin/mount " + floppy_device + " /media/floppy -t auto") == 0);

		      // be careful: only read the file /media/floppy/osr_map.ycp if the floppy was mounted
		      // correctly!
		      if (mounted)
		      {
			  y2milestone("Mount of floppy was successful.");
				  
			  integer ptbl_check = SCR::Read(.target.size, "/media/floppy/" + ptbl_name);

			  if (ptbl_check == 512)
			  {
			      y2milestone("Partition table exists and its size is 512 bytes.");
				      
			      UI::OpenDialog(`opt(`decorated), `Label(_("Reverting old partition table...")));

			      // copy the backup of the primary partition table to the target device
			      string command = sformat("dd if=/media/floppy/%1 of=%2 bs=1 count=64 skip=446 seek=446",
						       ptbl_name, target);
			      integer revert = OSRExecuteCommand(.local.bash, command);

			      if (revert == 0)
			      {
				  y2milestone("Reverting the partition table was successful.");
					  
				  // read the partition table for checking if it is o.k.
				  string partition_path  = ".disk" + target_scrpath + ".partitions";
				  list   partition_table = SCR::Read(topath(partition_path));

				  if ((partition_table != nil) && (partition_table != []))
				  {
				      // o.k., partition table successfully reverted.
				      y2milestone("Reading the new partition table was successful.");

				      repair_succeeded = true;

				      status = OSRStatusRepairOK();

				      OSRSummaryRepairOK(
							 module_name,
							 sformat(_("Repairing partition table of disk %1"), target),
							 _("Reverted old partition table")
							 );

				      OSRProvideMap("target_partition_map", $[target : partition_table]);

			      	      // add the name of the current harddisk to the list of valid targets
				      valid_target_list = add(valid_target_list, target);

				      // construct an updated "targets" map and store it in the global map "user_settings"
				      map partition_map = $["partitions" : partition_table];
				      target_map        = add(target_map, target, partition_map);
				      user_settings     = add(user_settings, "targets", target_map);

				      // umount everything from "/media/floppy" or from deeper directories after reading
				      if (UmountAllFrom("/media/floppy"))
				      {
					  y2milestone("All devices were successfully umounted from /media/floppy.");
				      }

				      UI::CloseDialog();

				      OSRModuleProgress::Fill();

				      return $[
					       "status" : status
				      ];
				  }
					  
			      }  // if (revert == 0)

			      UI::CloseDialog();
				      
			  }  // if (ptbl_check == 512)
		  
			  if (!repair_succeeded)
			  {
			      y2error("Reverting the primary partition table was not successfull.");

			      // umount the floppy after reading
			      OSRExecuteCommand(.local.bash, "/bin/umount /media/floppy");

			      error_message = sformat(_("An old partition table was found for disk %1
but it could not be reverted successfully.

If you have a YaST2 OS Repair floppy with some
up-to-date system information from a former
rescue session, insert it in your drive and
press Repair.

Press Skip and repair manually if you have
a backup of the partition table of disk
%1.

Press Help if you want to get to know how to
make a backup of a partition table manually
and how to revert it."), target);

			      repair_question = OSRPopupRepair(_("Reverting the primary partition table not successful"),
							       error_message, help_text);
			  }
				  
		      }  // if (mounted)
		      else
		      {
			  y2error("Floppy could not be mounted.");

			  error_message = sformat(_("Either no floppy disk was inserted into
the drive or the inserted floppy is not
correctly formatted.

If you have a YaST2 OS Repair floppy with some
up-to-date system information from a former
rescue session, insert it in your drive and
press Repair.

Press Skip and repair manually if you have
a backup of the partition table of disk
%1.

Press Help if you want to get to know how to
make a backup of a partition table manually
and how to revert it."), target);

			  // ask again
			  repair_question  = OSRPopupRepair(_("Error detected"), error_message, help_text);
		      }
		      
		  }  // if (has_floppy)
		  else
		  {
		      // this can't be repaired without a floppy drive, so the user must not be asked again
		      // to repair via floppy
		      // TODO: read from other medium than floppy (later)
		      repair_question  = false;
		      repair_succeeded = false;

		      // TODO: display that no floppy drive was detected

		      MessagePopup(_("YaST2 OS Repair could not detect a floppy
drive in your system. A backup copy of the
primary partition table could not be read."));
		  }

	      }	 // while(repair_question && !repair_succeeded)
		  

	      if (!repair_question && !repair_succeeded)
	      {
		  // repair omitted

		  status = OSRStatusRepairOmit();

		  OSRSummaryRepairOmit(
				       module_name,
				       sformat(_("Repairing partition table of disk %1"), target),
				       _("Partition table not repaired")
				       );
		  
	      }

              ///////////////////////////////////////////////////////////////////////////////////
	      //
	      //  Repair partition table with gpart
	      //
	      ///////////////////////////////////////////////////////////////////////////////////

	      if (!repair_succeeded)
	      {
		  
		  // "%1": will be replaced with "/dev/hda" or "/dev/sda" ...
		  error_message = sformat(_("The primary partition table of disk %1
is still not repaired. If you want to
let gpart guess your partition table
press Repair.

Press Skip to avoid repairing the
partition table with gpart."), target);

		  // TODO
		  help_text = _("");
	      
		  repair_question = OSRPopupRepair(_("Error detected"), error_message, help_text);

		  // repair
		  while (repair_question && !repair_succeeded)
		  {
		      /*
		      // search for the geometry of the defect harddisk:
		      // 1. the actual geometry (can be broken if the partition table is)
		      // 2. an old geometry saved in osr_map.ycp on floppy if the harddisks were not exchanged

		      // if one geometry was found: start gpart -C c,s,h <harddisk>, display the result and ask for writing
		      // if several geometries were found, execute gpart on everyone of them, display the results, let the user select
		      // if no geometries were found: start gpart <harddisk>, display the result and ask for writing

		      // get the result from SCR::Read(.probe.disk) to get the harddisk geometry
		      list probe_disk_list = OSRRequireList("probe_disk_list");

		      // select the map of the defective harddisk from the list, should look like this map:
		      // $[
		      //   "bus":"SCSI", "class_id":262, "dev_name":"/dev/sda", "device":"LIGHTNING 730S",
		      //   "resource":$["disk_log_geo":[$["cylinders":699, "heads":64, "sectors":32]],
		      //   "size":[$["unit":"sectors", "x":1431760, "y":512]]], "rev":"241E", "sub_class_id":0,
		      //   "unique_key":"4t_9.3y87AyIJK4C", "vendor":"QUANTUM"
		      //  ]
		      map  target_disk_map = find(`k, probe_disk_list, ``(lookup(k, "dev_name", "") == target));
		      list disk_log_geo    = lookup(lookup(target_disk_map, "resource", $[]), "disk_log_geo", []);
		      map  geometry        = select(disk_log_geo, 0, $[]);
		      */
		      
		      // start gpart, display to the user
		      // ask the user which one of the detected partitions should be activated (1-4): OSRPopupRadioButtonGroup()
		      // start gpart -W ...
		      // check again with SCR::Read(.disk.sda.partitions)

		      string gpart_command = "gpart " + target;
		      map    gpart_result  = OSRExecuteCommandOutput(.target.bash_output, gpart_command);

		      if (lookup(gpart_result, "exit", -1) == 0)
		      {
			  // display the results in a window
			  OSRPopupLongTextView(_("Gpart output"), lookup(gpart_result, "stdout", ""), 20, 100);

			  // parse the gpart result
			  string gpart_out      = lookup(gpart_result, "stdout", "");
			  string partitions_out = substring(gpart_out,
							    find(gpart_out, "\nPrimary partition(1)"),
							    (size(gpart_out) - find(gpart_out, "\nPrimary partition(1)")));

			  string partition1 = substring(partitions_out,
							find(partitions_out, "\nPrimary partition(1)"),
							(find(partitions_out, "\nPrimary partition(2)") -
							 find(partitions_out, "\nPrimary partition(1)")));

			  string partition2 = substring(partitions_out,
							find(partitions_out, "\nPrimary partition(2)"),
							(find(partitions_out, "\nPrimary partition(3)") -
							 find(partitions_out, "\nPrimary partition(2)")));

			  string partition3 = substring(partitions_out,
							find(partitions_out, "\nPrimary partition(3)"),
							(find(partitions_out, "\nPrimary partition(4)") -
							 find(partitions_out, "\nPrimary partition(3)")));

			  string partition4 = substring(partitions_out,
							find(partitions_out, "\nPrimary partition(4)"),
							(size(partitions_out) -
							 find(partitions_out, "\nPrimary partition(4)")));

			  list gpart_partitions = [partition1, partition2, partition3, partition4];

			  // the list of partitions that can be activated
			  list activatable_partitions = [];

			  // this list holds the strings for the OSRPopupRadioButtonGroupText window
			  list selection_display = [];
			  
			  integer index = 0;
			  while ((index >= 0) && (index < size(gpart_partitions)))
			  {
			      string p = select(gpart_partitions, index, "");

			      // split the output for each partition at the newlines
			      list p_list = splitstring(p, "\n");

			      string item_text = "";
			      
			      foreach(`line, p_list, ``{

				  if (issubstring(line, "type: "))
				  {
				      integer size_of_line = size(sformat("%1", line));
				      integer directly_after_type = find(line, "type: ") + size("type: ");
				      integer to_the_end = size_of_line - (find(line, "type: "));

				      item_text = substring(line, directly_after_type, to_the_end);
				  }
			      });

			      //string item_text = substring(p, find(p, "type: ") + size("type: "), find(p, ")));

			      list item_list = [sformat("%1", index + 1), item_text];

			      //y2error("%1", item_list);

			      selection_display = add(selection_display, item_list);
			      
			      // TODO: which partitions should not be activated?? 0x05 0x0f
			      // add all partitions to the list of activatable partitions that are not swap (0x82), unused (0x00),...
			      if (!issubstring(p, "(0x82)") && !issubstring(p, "(0x00)"))
			      {
				  activatable_partitions = add(activatable_partitions, sformat("%1", (index + 1)));
			      }
			      index = index + 1;
			  }

			  // create the string for the proposal which one of the partitions should be activated.
			  string proposal_string  = "";
			  string default_proposal = "";
			  if (size(activatable_partitions) == 0)
			  {
			      // no proposals
			      proposal_string = _("YaST2 OS Repair proposes no partition to be
activated.");
			  }
			  else if (size(activatable_partitions) == 1)
			  {
			      proposal_string = sformat(_("YaST2 OS Repair proposes partition number %1
to be activated."), select(activatable_partitions, 0, ""));

			      default_proposal = select(activatable_partitions, 0, "");
			  }
			  else if (size(activatable_partitions) == 0)
			  {
			      proposal_string = sformat(_("YaST2 OS Repair proposes one of the partitions
%1 to be activated."), mergestring(activatable_partitions, ", "));

			      default_proposal = select(activatable_partitions, 0, "");
			  }

			  // let the user select which partition to be activated
			  string active_partition = OSRPopupRadioButtonGroupText(
									   _("Gpart: Select the active partition"),
									   sformat(_("The program gpart will mark the selected partition
as active.

%1

Press Cancel if gpart should not write the guessed
result to the primary partition table.
"), proposal_string),
									   selection_display,
									   /*
									   [
									    
									    ["1", _("First primary partition")],
									    ["2", _("Second primary partition")],
									    ["3", _("Third primary partition")],
									    ["4", _("Fourth primary partition")]
									    ],
									   */
									   default_proposal,
									   "cancel",
									   false
									   );

			  // check if the user pressed cancel -> don't start gpart
			  if (active_partition == "cancel")
			  {
			      OSRPopupDisplayQuick(_("Gpart was not started"), 1000);
			  }
			  else
			  {
			      // should look like this: echo n\n2\ny | gpart -W /dev/sda /dev/sda
			      gpart_command = sformat("echo n\n%1\ny | gpart -W %2 %2", active_partition, target);

			      // execute gpart
			      gpart_result  = OSRExecuteCommandOutput(.target.bash_output, gpart_command);

			      if (lookup(gpart_result, "exit", -1) == 0)
			      {
				  y2milestone("Reverting the partition table was successful.");

				  repair_succeeded = true;
					  
				  // read the partition table for checking if it is o.k.
				  string partition_path  = ".disk" + target_scrpath + ".partitions";
				  list   partition_table = SCR::Read(topath(partition_path));

				  if ((partition_table != nil) && (partition_table != []))
				  {
				      // o.k., partition table successfully reverted.
				      y2milestone("Reading the new partition table was successful.");

				      repair_succeeded = true;

				      status = OSRStatusRepairOK();

				      OSRSummaryRepairOK(
							 module_name,
							 sformat(_("Repairing partition table of disk %1"), target),
							 _("Reverted old partition table")
							 );

				      // add the name of the current harddisk to the list of valid targets
				      valid_target_list = add(valid_target_list, target);

				      OSRProvideMap("target_partition_map", $[target : partition_table]);

				      // construct an updated "targets" map and store it in the global map "user_settings"
				      map partition_map = $["partitions" : partition_table];
				      target_map        = add(target_map, target, partition_map);
				      user_settings     = add(user_settings, "targets", target_map);

				      OSRModuleProgress::Fill();

				      return $[
					       "status" : status
				      ];
				  }

			      }
			  }
		      }
		  
		      if (!repair_succeeded)
		      {
			  /*
			  status = OSRStatusRepairError();

			  OSRSummaryRepairError(
					     module_name,
					     sformat(_("Repair partition table of disk %1"), target),
					     _("Partition table not repaired")
					     );
			  */
			  repair_question  = OSRPopupRepair(_("Error detected"), error_message, help_text);
		      }
		  
		  }   // while (repair_question && !repair_succeeded)

		  if (!repair_question)
		  {
		      // repair omitted
		      status = OSRStatusRepairOmit();

		      OSRSummaryRepairOmit(
					   module_name,
					   sformat(_("Repairing partition table of disk %1"), target),
					   _("Partition table not repaired")
					   );

		  }
	      
	      }  // if (!repair_succeeded)	      
	  }
	  else
	  {
	      // everything is o.k.
	      
	      OSRModuleProgress::Add(progress_increment);

	      // add the name of the current harddisk to the list of valid targets
	      valid_target_list = add(valid_target_list, target);
	  }
      });  // foreach(`target, `values, target_map, ...

      ///////////////////////////////////////////////////////////////////////////////////
      //
      //  Check if at least one harddisk with a valid partition table exists
      //
      ///////////////////////////////////////////////////////////////////////////////////

      if (size(valid_target_list) == 0)
      {
	  status   = OSRStatusDetectError();
	  severity = OSRErrorSeverityBlocking();

	  OSRSummaryDetectError(
				module_name,
				_("Checking harddisks"),
				_("No disk contains valid primary partition table")
				);

	  error_message = _("YaST2 OS Repair could not detect any hard
disks that contain a valid primary partition
table in your system.

YaST2 OS Repair halts now.");

	  // display the error message, only a OK pushbutton
	  UI::MessagePopup(error_message);
	  
	  // if no harddisk was found, exit the rescue system
	  return $[
		   "status"        : status,
		   "severity"      : severity
	  ];

      }
      else if (size(valid_target_list) == 1)
      {
	  // at least one valid target found
	  y2milestone("Valid targets: %1", valid_target_list);

	  status = OSRStatusDetectOK();

	  OSRSummaryDetectOK(
			     module_name,
			     _("Checking partition tables"),
			     sformat(_("Partition tables found for disk %1"), select(valid_target_list, 0, ""))
			     );
	  
      }
      else if (size(valid_target_list) > 0)
      {
	  // at least one valid target found
	  y2milestone("Valid targets: %1", valid_target_list);
	  
	  status = OSRStatusDetectOK();

	  OSRSummaryDetectOK(
			     module_name,
			     _("Checking partition tables"),
			     sformat(_("Partition tables found for the disks %1"), mergestring(valid_target_list, ", "))
			     );

      }
      
      OSRProvideList("valid_target_list", valid_target_list);
      
      // set the value of the module progress bar to 100%
      OSRModuleProgress::Fill();
      
      return $["status" : status];


      // TODO: blockdev --rereadpt /dev/sda nachdem eine ptbl neu angelegt wurde!
  };

  /**
   *  Checks the detected partitions for valid filesystems, mounts them and searches for
   *  filesystem tables (/etc/fstab) on the partitions.
   *
   *  Provides: list valid_root_partitions,
   *            string root_partition,
   *            list valid_swap_partitions,
   *            list swapable_partitions
   *
   *  @return map The result_map.
   */
  global define OSRPartitionCheckPartitions() ``{

      boolean repair_question           = false;
      integer progress_expect           = 60;
      string  module_name               = "osr_module_partition";
      string  help_text                 = "";
      string  error_message             = "";
      string  progress_file             = "";
      string  progress_label            = _("Checking the partitions and filesystems");
      string  status                    = "";
      map     result_map                = $[];
      map     target_map                = $[];
      list    linux_partition_list      = [];
      string  root_partition            = "";
      list    mount_possible_list       = [];
      list    mounted_partitions        = [];
      list    valid_root_partition_list = [];
      
      module_map     = OSRGetModuleMap(module_name);
      progress_file  = lookup(module_map, "progress_file", "");

      // set the parameters for the module progress bar
      OSRModuleProgress::SetParams(progress_label, progress_file, progress_expect);

      target_map = lookup(user_settings, "targets", $[]);

      // Umount all partitions from "/mnt" or from deeper directories (e.g. "/mnt/usr", "/mnt/usr/local", ...)
      // before mounting anything to "/mnt".
      if (UmountAllFrom("/mnt"))
      {
	  y2debug("All partitions were successfully umounted from /mnt...");
      }

      OSRModuleProgress::Add(10);

      /////////////////////////////////////////////////////////
      //
      // install available kernel modules for the filesystems
      //
      /////////////////////////////////////////////////////////

      list fs_kernel_modules = ["reiserfs", "ext3", "jfs", "jbd", "xor", "raid0", "raid1", "raid5"];

      map  loaded_kernel_modules = OSRExecuteCommandOutput(.target.bash, "/sbin/lsmod");

      list already_installed_modules      = [];
      list successfully_installed_modules = [];
      list not_installed_modules          = [];

      list loaded_modules_list = splitstring(lookup(loaded_kernel_modules, "stdout", ""), "\n");

      // iterate all listed kernel modules
      foreach(`fs_module, fs_kernel_modules, ``{

	  boolean is_substring = false;
	  
	  foreach(`line, loaded_modules_list, ``{

	      if (issubstring(line, fs_module))
	      {
		  is_substring = true;
	      }
	  });

	  // check if the current module is already loaded
	  if (is_substring)
	  {
	      already_installed_modules = add(already_installed_modules, fs_module);
	  }
	  else
	  {
	      if (SCR::Execute(.target.insmod, fs_module, ""))
	      {
		  successfully_installed_modules = add(successfully_installed_modules, fs_module);
	      }
	      else
	      {
		  not_installed_modules = add(not_installed_modules, fs_module);
	      }
	  }
      });

      if (size(already_installed_modules) > 0)
      {
	  OSRSummaryDetectOK(
			     module_name,
			     _("Installing kernel modules for filesystem support"),
			     sformat(_("Kernel modules already installed: %1"), mergestring(already_installed_modules, ", "))
			     );
      }

      if (size(successfully_installed_modules) > 0)
      {
	  OSRSummaryDetectOK(
			     module_name,
			     _("Installing kernel modules for filesystem support"),
			     sformat(_("Kernel modules sucessfully installed: %1"), mergestring(successfully_installed_modules, ", "))
			     );
      }

      if (size(not_installed_modules) > 0)
      {
	  OSRSummaryDetectProblem(
			     module_name,
			     _("Installing kernel modules for filesystem support"),
			     sformat(_("Not successfully installed kernel modules: %1"), mergestring(not_installed_modules, ", "))
			     );
      }
      
      OSRModuleProgress::Add(10);

      /////////////////////////////////////////////////////////
      //
      // search for currently mounted partitions
      //
      /////////////////////////////////////////////////////////

      mounted_partitions = GetMountedPartitions();

      OSRModuleProgress::Add(10);
      
      if (size(mounted_partitions) <= 0)
      {
	  // no mounted partitions: not implicitly an error!
	  status = OSRStatusDetectOK();
	  
	  OSRSummaryDetectOK(
			     module_name,
			     _("Searching for currently mounted partitions"),
			     _("No mounted partitions found")
			     );
      }
      else
      {
	  // create a mount-like output
	  list mounted_output = maplist(`entry, mounted_partitions,
					``("" + lookup(entry, "name", "") +
					   " on " + lookup(entry, "mountpoint", "") +
					   " type " + lookup(entry, "fstype", "") +
					   " " + lookup(entry, "perm", "")));
	  
	  status = OSRStatusDetectOK();
	  
	  OSRSummaryDetectOK(
			     module_name,
			     _("Searching for currently mounted partitions"),
			     sformat(_("Mounted partitions found:<br>%1"), mergestring(mounted_output, "<br>"))
			     );
      }

      //////////////////////////////////////////////////
      //
      // search for valid Linux partitions
      //
      //////////////////////////////////////////////////

      // get the partitions with a valid linux partition id from the target_map
      linux_partition_list = GetLinuxPartitions(target_map);

      OSRModuleProgress::Add(10);
      
      if (size(linux_partition_list) <= 0)
      {
	  status = OSRStatusDetectError();
	  severity = OSRErrorSeverityBlocking();

	  OSRSummaryDetectError(
				module_name,
				_("Searching for valid linux partitions"),
				_("No valid partition types found")
				);
	  
	  // TODO: display and exit, start installation or partitioning instead

	  return $[
		   "status" : status,
		   "severity" : severity
	  ];
      }
      else
      {
	  status = OSRStatusDetectOK();
	      
	  OSRSummaryDetectOK(
			     module_name,
			     _("Searching for valid linux partitions"),
			     sformat(_("Valid linux partitions found:<br>%1"),
				     mergestring(linux_partition_list, ", "))
			     );
      }

      /////////////////////////////////////////////////////////
      //
      // search for mountable partitions
      //
      /////////////////////////////////////////////////////////

      mount_possible_list = GetMountablePartitions(linux_partition_list);

      OSRModuleProgress::Add(10);

      if (size(mount_possible_list) > 0)
      {
	  status = OSRStatusDetectOK();
	  
	  OSRSummaryDetectOK(
			     module_name,
			     _("Searching for mountable partitions"),
			     sformat("Mountable partitions found:<br>%1",
				     mergestring(mount_possible_list, ", "))
			     );
      }
      else
      {
	  status = OSRStatusDetectError();
	  severity = OSRErrorSeverityBlocking();
	  
	  OSRSummaryDetectError(
				module_name,
				_("Searching for mountable partitions"),
				_("No mountable partitions found")
				);

	  // TODO: display and exit, start installation or partitioning instead
	  
	  return $[
		   "status" : status,
		   "severity" : severity
	  ];
      }

      /////////////////////////////////////////////////////////////////
      //
      // search for valid root partitions with a filesystem table
      //
      /////////////////////////////////////////////////////////////////

      valid_root_partition_list = GetValidRootPartitions(mount_possible_list);
      
      OSRModuleProgress::Add(10);

      if (size(valid_root_partition_list) <= 0)
      {
	  status = OSRStatusDetectError();
	  severity = OSRErrorSeverityBlocking();
	  
	  OSRSummaryDetectError(
				module_name,
				_("Searching for valid root partitions"),
				_("No valid root partition found")
				);

	  // TODO: display and exit, start installation instead
	  // eventually: if no fstab found search for the /etc/ directory
	  // -> this has to be the root partition but the fstab is missing,
	  // probably it is possible to autocreate a new one

	  // /dev, /etc, /proc, /sbin, /bin, /lib: wenn mind. 4 der 6 dirs auf der partition vorhanden, dann
	  // sollte weiterdetected werden.
	  
	  return $[
		   "status" : status,
		   "severity" : severity
	  ];
      }
      else if (size(valid_root_partition_list) == 1)
      {
	  OSRProvideList("valid_root_partitions", valid_root_partition_list);

	  root_partition = select(valid_root_partition_list, 0);

	  OSRProvideString("root_partition", root_partition);

	  status = OSRStatusDetectOK();
	  
	  OSRSummaryDetectOK(
			     module_name,
			     _("Searching for valid root partitions"),
			     sformat("One valid partition found: %1", root_partition)
			     );
      }
      else
      {
	  OSRProvideList("valid_root_partitions", valid_root_partition_list);

	  // several valid root partitions found
	  status = OSRStatusDetectOK();
	  
	  OSRSummaryDetectOK(
			     module_name,
			     _("Searching for valid root partitions"),
			     sformat("Several valid root partitions found:<br>%1",
				     mergestring(valid_root_partition_list, ", "))
			     );

	  // launch a popup with a RadioButtonGroup - one button for each item in the list -
	  // and let the user select the root partition
	  root_partition = OSRPopupRadioButtonGroup(
					      _("Select root partition"),
					      _("There exist several valid root partitions in your system.
You have to select one item in the list."),
					      valid_root_partition_list,
					      "",
					      true
					      );
	  
	  OSRProvideString("root_partition", root_partition);
      }

      /////////////////////////////////////////////////////////////////
      //
      // search for valid swap partitions
      //
      /////////////////////////////////////////////////////////////////

      list swap_partition_list = GetSwapPartitions(target_map);

      OSRModuleProgress::Add(10);
      
      if (size(swap_partition_list) <= 0)
      {
	  status = OSRStatusDetectProblem();

	  OSRSummaryDetectProblem(
				module_name,
				_("Searching for valid swap partitions"),
				_("No valid partition types found")
				);
      }
      else
      {
	  status = OSRStatusDetectOK();
	      
	  OSRSummaryDetectOK(
			     module_name,
			     _("Searching for valid swap partitions"),
			     sformat(_("Valid swap partitions found:<br>%1"),
				     mergestring(swap_partition_list, ", "))
			     );

	  OSRProvideList("valid_swap_partitions", swap_partition_list);
      }

      /////////////////////////////////////////////////////////////////
      //
      // search for "swap-able" partitions
      //
      /////////////////////////////////////////////////////////////////

      list swapable_partition_list = GetSwapablePartitions(swap_partition_list);

      OSRModuleProgress::Add(10);
      
      if (size(swapable_partition_list) <= 0)
      {
	  status = OSRStatusDetectProblem();

	  OSRSummaryDetectProblem(
				module_name,
				_("Searching for swap-able partitions"),
				_("No swap-able partitions found")
				);
      }
      else
      {
	  status = OSRStatusDetectOK();
	      
	  OSRSummaryDetectOK(
			     module_name,
			     _("Searching for swap-able partitions"),
			     sformat(_("Swap-able partitions found:<br>%1"),
				     mergestring(swapable_partition_list, ", "))
			     );

	  OSRProvideList("swapable_partitions", swapable_partition_list);
      }

      status = OSRStatusDetectOK();
      
      result_map = $[
		     "status" : status,
		     "severity" : severity
      ];

      // set the value of the module progress bar to 100%
      OSRModuleProgress::Fill();
      
      return result_map;
  };


  /**
   *  Mount the root partition and all reachable, local and valid partitions from the
   *  detected filesystem table "/etc/fstab".
   *
   *  Requires: list valid_root_partitions,
   *            string root_partition
   *  Provides: list just_mounted,
   *            string root_mountpoint
   *
   *  @return map The result_map.
   */
  global define OSRPartitionMountRoot() ``{

      // if there is one: mount it
      // if there are several: select-popup
      // if there is none: display and exit

      // get the fstab, use the agent .etc.fstab1

      // check all entries in the fstab
      // are they local, existing, mountable...?

      // check all entries in the fstab with fsck
      // mount all valid entries in the fstab

      string  status                  = "";
      string  severity                = "";
      string  module_name             = "osr_module_partition";
      list    valid_root_partitions   = [];
      string  root_partition          = "";
      boolean mount_successful        = true;
      list    fstab                   = [];
      string  message                 = "";
      map     root_partition_map      = $[];
      list    mountpoint_list         = [];
      string  root_partition_type     = "";
      list    just_mounted            = [];
      string  root_mountpoint         = "/mnt";
      string  fstab_standard_path     = "/etc/fstab";
      string  progress_label          = _("Mounting root and additional partitions");
      string  progress_file           = "";
      integer progress_expect         = 200;

      progress_file = lookup(module_map, "progress_file", "");

      // setting up the progress bar
      OSRModuleProgress::SetParams(progress_label, progress_file, progress_expect);

      // get all valid root partitions
      valid_root_partitions = OSRRequireList("valid_root_partitions");

      // get the selected root partition
      root_partition = OSRRequireString("root_partition");

      OSRModuleProgress::Add(10);

      ///////////////////////////////////////////////////////////////////////////////
      //
      //  check filesystem type of the root partition
      //
      ///////////////////////////////////////////////////////////////////////////////

      // get the fstype: "ext2", "reiserfs", ...
      root_partition_type = GetFilesystemType(root_partition);

      OSRModuleProgress::Add(10);
      
      if (root_partition_type == "unknown")
      {
	  status = OSRStatusDetectProblem();
	  
	  OSRSummaryDetectProblem(
				module_name,
				sformat(_("Detecting filesystem type of root partition %1"), root_partition),
				_("Filesystem type is unknown")
				);
      }
      else
      {
	  status = OSRStatusDetectOK();
	  
	  OSRSummaryDetectOK(
			     module_name,
			     sformat(_("Detecting filesystem type of root partition %1"), root_partition),
			     sformat(_("Filesystem type: %1"), root_partition_type)
			     );
      }

      ///////////////////////////////////////////////////////////////////////////////
      //
      //  check the filesystem of the root partition
      //
      ///////////////////////////////////////////////////////////////////////////////

      if (root_partition_type != "unknown")
      {
	  list    mountpoint_list = GetMountpoints(root_partition);
	  integer check_fs        = 0;

	  OSRModuleProgress::Add(10);
      
	  // start fsck only if the partition is not currently mounted
	  if (size(mountpoint_list) == 0)
	  {  
	      if (root_partition_type == "ext2")
	      {
		  // CheckExt2fs returns the exit code of the e2fsck command
		  check_fs = CheckExt2fs(root_partition);

		  OSRModuleProgress::Add(10);
	      }
	      else if (root_partition_type == "reiserfs")
	      {
		  // CheckReiserfs returns the exit code of the reiserfsck command
		  check_fs = CheckReiserfs(root_partition, "");

		  OSRModuleProgress::Add(10);
	      }

	      // TODO: check ext3, jfs, xfs

	      if (check_fs == 0)
	      {
		  status = OSRStatusDetectOK();

		  OSRSummaryDetectOK(
				     module_name,
				     sformat(_("Checking filesystem of root partition %1"), root_partition),
				     _("Filesystem is o.k.")
				     );
	      }
	      else
	      {
		  status = OSRStatusDetectProblem();

		  OSRSummaryDetectProblem(
					module_name,
					sformat(_("Checking filesystem of root partition %1"), root_partition),
					sformat(_("Filesystem is corrupted<br>fsck exits with code %1"), check_fs)
					);

		  // TODO: fsck reports an error but the partition is mountable, as we know???
		  // go on and try to mount the root partition

		  // TODO: not only --fix-fixable, also critical repairs, user interaction
	      }
	  }
      }

      ///////////////////////////////////////////////////////////////////////////////
      //
      //  mount the root partition to /mnt
      //
      ///////////////////////////////////////////////////////////////////////////////

      // check if the specified partition is already mounted to "/mnt", mount only if it is not already done.
      if (!IsMountedTo(root_partition, root_mountpoint))
      {
	  OSRModuleProgress::Add(10);

	  // Mount selected partition to /mnt
	  mount_successful = SCR::Execute(.target.mount, [root_partition, root_mountpoint]);

	  if (mount_successful)
	  {
	      // add the mounted partition to the list, this has to be known for being able to
	      // umount all partitions that were mounted by the rescue system
	      just_mounted = add(just_mounted, $[ "partition" : root_partition, "mountpoint" : root_mountpoint ]);

	      OSRProvideString("root_mountpoint", root_mountpoint);
	      
	      status = OSRStatusDetectOK();
	  
	      OSRSummaryDetectOK(
				 module_name,
				 sformat(_("Mounting root partition %1 to %2"), root_partition, root_mountpoint),
				 _("Root partition successfully mounted")
				 );
	  }
	  else
	  {
	      status = OSRStatusDetectError();
	  
	      OSRSummaryDetectError(
				 module_name,
				 sformat(_("Mounting root partition %1 to %2"), root_partition, root_mountpoint),
				 sformat(_("Root partition not successfully mounted to %1"), root_mountpoint)
				 );

	      // TODO: select another root partition
	  }
      }
      else
      {
	  OSRModuleProgress::Add(10);

	  OSRProvideString("root_mountpoint", root_mountpoint);

	  status = OSRStatusDetectOK();
	  
	  OSRSummaryDetectOK(
			     module_name,
			     sformat(_("Mounting root partition %1 to %2"), root_partition, root_mountpoint),
			     sformat(_("Root partition is already mounted to %1"), root_mountpoint)
			     );

	  mount_successful = true;
      }

      ///////////////////////////////////////////////////////////////////////////////
      //
      //  get the fstab
      //
      ///////////////////////////////////////////////////////////////////////////////
      
      if (mount_successful)
      {
	  integer fstab_size = SCR::Read(.target.size, "" + root_mountpoint + fstab_standard_path);

	  OSRModuleProgress::Add(10);

	  if (fstab_size == nil)
	  {
	      y2error("Agent-error, SCR::Read(.target.size, \"%1\") returns nil", "" + root_mountpoint + fstab_standard_path);
	  }
	  else if (fstab_size < 0)
	  {
	      y2error("No fstab found at %1", "" + root_mountpoint + fstab_standard_path);
	  }
	  else if (fstab_size == 0)
	  {
	      y2debug("The file %1 exists but is empty??", "" + root_mountpoint + fstab_standard_path);
	  }
	  else
	  {
	      y2debug("Fstab found, size of the file %1: %2", "" + root_mountpoint + fstab_standard_path, fstab_size);
	  }
	      
	  // Reading the fstab from the mounted root partition
	  fstab = SCR::Read(.etc.fstab1, ["" + root_mountpoint + fstab_standard_path]);

	  OSRModuleProgress::Add(10);
	  
	  if (fstab == nil)
	  {
	      y2error("Something's wrong with the .etc.fstab1-agent");

	      status = OSRStatusDetectError();
	  
	      OSRSummaryDetectError(
				    module_name,
				    sformat(_("Searching filesystem table %1"), root_mountpoint + fstab_standard_path),
				    _("The fstab agent reported an error")
				    );
	      // TODO: fstab repair, not-fstab
	  }
	  else if (size(fstab) == 0)
	  {
	      y2error("No fstab found !!");

	      status = OSRStatusDetectError();
	  
	      OSRSummaryDetectError(
				    module_name,
				    sformat(_("Searching filesystem table %1"), root_mountpoint + fstab_standard_path),
				    _("No filesystem table found")
				    );

	      // TODO: fstab repair, not-fstab
	  }
	  else
	  {
	      status = OSRStatusDetectOK();
	  
	      OSRSummaryDetectOK(
				 module_name,
				    sformat(_("Searching filesystem table %1"), root_mountpoint + fstab_standard_path),
				 _("Filesystem table found")
				 );
	  
	      y2milestone("fstab :%1 ", fstab );

	  }
      }

      ///////////////////////////////////////////////////////////////////////////////
      //
      //  foreach entry in the fstab:
      //  - detect the filesystem type
      //  - check the filesystem with fsck
      //  - mount the partition to /mnt/<fstab-value>
      //  - include the partition as swap if it is of type swap
      //
      ///////////////////////////////////////////////////////////////////////////////

      if (size(fstab) > 0)
      {
	  // compute the value of the progress increment
	  integer progress_increment = (((OSRModuleProgress::GetLength() - OSRModuleProgress::GetValue()) / size(fstab)) / 3);
	  
	  // mount resp. swapon all partitions mentioned in the fstab
	  foreach( `fstab_entry, fstab, ``{
		  
	      string vfstype     = lookup(fstab_entry, "vfstype", "");
	      string mntops      = lookup(fstab_entry, "mntops", "");
	      string spec        = lookup(fstab_entry, "spec", "");
	      string file        = lookup(fstab_entry, "file", "");
	      string real_fstype = "";

	      OSRModuleProgress::Add(progress_increment);

	      ///////////////////////////////////////////////////////////////////////////////
	      //
	      //  detect the filesystem type
	      //
	      ///////////////////////////////////////////////////////////////////////////////

              // TODO: problem with mounting an entry

	      // TODO: wenn es nicht /var, (/opt), /usr, ist, dann von "default" auf "noauto" setzen, falls es hier Probleme gibt
	      
	      // mounting the "normal" filesystems
	      // attention: "nfs"-filesystems are not mounted here!
	      if ((vfstype == "ext" || vfstype == "ext2" || vfstype == "minix" || vfstype == "reiserfs" ||
		   vfstype == "xiafs" || vfstype == "hpfs" || vfstype == "vfat") &&
		  (file != "/") && (!issubstring(mntops,"noauto")))
	      {
		  // for checking if the current partition is already mounted because in this case
		  // it is not possible to fsck it
		  list mountpoint_list = GetMountpoints(spec);

		  OSRModuleProgress::Add(progress_increment);

		  // detect the filesystem type of the current partition with the tools "dumpreiserfs" and "dumpe2fs"
		  real_fstype = GetFilesystemType(spec);

		  OSRModuleProgress::Add(progress_increment);

		  // check if the "real" fstype and the entry in the fstab for this partition differ
		  if (real_fstype != vfstype)
		  {
		      // TODO: change entry in the fstab
		      
		      y2error("Entry in fstab for fstype of partition %1 and real fstype differ, fstab: %2, real: %3",
			      spec, vfstype, real_fstype);
		  }

		  if (real_fstype == "unknown")
		  {
		      status = OSRStatusDetectProblem();
	  
		      OSRSummaryDetectProblem(
					    module_name,
					    sformat(_("Detecting filesystem type of partition %1"), spec),
					    _("Filesystem type is unknown")
					    );
		  }
		  else
		  {
		      status = OSRStatusDetectOK();
	  
		      OSRSummaryDetectOK(
					 module_name,
					 sformat(_("Detecting filesystem type of partition %1"), spec),
					 sformat(_("Filesystem type: %1"), real_fstype)
					 );
		  }

		  ///////////////////////////////////////////////////////////////////////////////
		  //
		  //  check the filesystem with fsck
		  //
		  ///////////////////////////////////////////////////////////////////////////////

		  // start fsck only if the partition is not currently mounted
		  if (size(mountpoint_list) == 0)
		  {  
		      if (real_fstype == "ext2")
		      {
			  // CheckExt2fs returns the exit code of the e2fsck command
			  check_fs = CheckExt2fs(spec);
		      }
		      else if (real_fstype == "reiserfs")
		      {
			  // CheckReiserfs returns the exit code of the reiserfsck command
			  check_fs = CheckReiserfs(spec, "");
		      }

		      // TODO: check also ext3, xfs, jfs

		      OSRModuleProgress::Add(progress_increment);

		      if (check_fs == 0)
		      {
			  status = OSRStatusDetectOK();

			  OSRSummaryDetectOK(
					     module_name,
					     sformat(_("Checking filesystem of partition %1"), spec),
					     _("Filesystem is o.k.")
					     );
		      }
		      else
		      {
			  status = OSRStatusDetectError();

			  OSRSummaryDetectError(
						module_name,
						sformat(_("Checking filesystem of partition %1"), spec),
						sformat(_("Filesystem is corrupted<br>fsck exits with code %1"), check_fs)
						);
		      }
		  }
		  
		  ///////////////////////////////////////////////////////////////////////////////
		  //
		  //  mount the partition to /mnt/...
		  //
		  ///////////////////////////////////////////////////////////////////////////////

		  // if the mount-options contain "ro", it is not possible to mount the specified partition to /mnt/...
		  if (issubstring(mntops,"ro,") || issubstring(mntops,",ro") || mntops == "ro")
		  {

		      // TODO: mount it readonly, this is not an error, (if it is /var, change entry in fstab to rw)

		      /*
		      status = OSRStatusDetectError();

		      OSRSummaryDetectError(
					    module_name,
					    sformat(_("Mounting %1 to %2"), spec, root_mountpoint + file),
					    sformat(_("Partition %1 is read-only<br>Mounting not proceeded"), spec)
					    );
		      */
		      
                      // TODO: ask the user to change the fstab-entry
		      
		      //y2error("Mounting %1 on %2 is only possible for permissions \"ro\" after reboot.", spec, root_mountpoint + file);
		      //y2error("Please change /etc/fstab");
//		      success = false;
		  }
		  else
		  {
		      // mount current partition to /mnt/...
		      boolean mount_partition = SCR::Execute(.target.mount, [spec, root_mountpoint + file]);

		      OSRModuleProgress::Add(progress_increment);

		      if (mount_partition == nil)
		      {
			  status = OSRStatusDetectError();

			  OSRSummaryDetectError(
					     module_name,
					     sformat(_("Mounting %1 to %2"), spec, root_mountpoint + file),
					     _("Mounting failed")
					     );

			  y2error("Mounting of %1 to %2 not possible.", spec, root_mountpoint + file);
//			  success = false;
		      }
		      else if (!mount_partition)
		      {
			  status = OSRStatusDetectError();

			  OSRSummaryDetectError(
					     module_name,
					     sformat(_("Mounting %1 to %2"), spec, root_mountpoint + file),
					     _("Mounting failed")
					     );

			  y2error("mounting %1 to %2 failed", spec, root_mountpoint + file);
//			  success = false;
		      }
		      else
		      {
			  // add the mountpoint of the mounted partition to the list, this has to be known for being able to
                          // umount all partitions that were mounted by the rescue system
			  just_mounted = add(just_mounted, $[ "partition" : spec, "mountpoint" : root_mountpoint + file ]);
			  
			  status = OSRStatusDetectOK();

			  OSRSummaryDetectOK(
					     module_name,
					     sformat(_("Mounting %1 to %2"), spec, root_mountpoint + file),
					     _("Mounting succeeded")
					     );

			  y2milestone("mounting succeeded: %1 to %2", spec, root_mountpoint + file);
//			  success = true;
		      }
		  }
	      }

	      ///////////////////////////////////////////////////////////////////////////////
	      //
	      //  include the partition as swap if it is of type swap
	      //
	      ///////////////////////////////////////////////////////////////////////////////

	      if ((vfstype == "swap")  && (file == "swap"))
	      {
		  // check if the swap partition is already swapped on, proc_swaps looks like:
		  // [$["file":"/dev/sda1", "priority":"42", "size":"52200", "type":"partition", "used":"21336"]]
		  list proc_swaps = SCR::Read(.proc.swaps);

		  OSRModuleProgress::Add(progress_increment);
		  
		  // Check if the specified swap-partition is already "swapped", if true don't swapon.
		  // filter(...) returns a list of all "swapped" partitions where the name equals to the specified partition
		  if (size(filter(`swap_partition, proc_swaps, ``(lookup(swap_partition, "file", "") == spec))) > 0)
		  {
		      y2debug("Swap-partition \"%1\" is already swapped-on!", spec);

		      status = OSRStatusDetectOK();

		      OSRSummaryDetectOK(
					 module_name,
					 sformat(_("Adding partition %1 to swap"), spec),
					 sformat(_("Partition %1 already added to swap"), spec)
					 );
		  }
		  else
		  {
		      if (SwaponFstabEntry(fstab_entry))
		      {
			  status = OSRStatusDetectOK();

			  OSRSummaryDetectOK(
					     module_name,
					     sformat(_("Adding partition %1 to swap"), spec),
					     _("Swapon succeeded")
					     );
		      }
		      else
		      {
			  status = OSRStatusDetectError();

			  OSRSummaryDetectError(
						module_name,
						sformat(_("Adding partition %1 to swap"), spec),
						_("Swapon failed")
						);
		      }
		  }
	      }
	  });
      }

      OSRProvideList("just_mounted", just_mounted);
      
      status = OSRStatusDetectOK();
      
      result_map = $["status" : status];

      // set the value of the module progress bar to 100%
      OSRModuleProgress::Fill();
      
      return result_map;
      
  }; // global define OSRPartitionMountRoot()
  
  //////////////////////////////////////////////////////////////////////
  //
  //  MAIN
  //
  //////////////////////////////////////////////////////////////////////

  // in init mode only execute the init function and return the module map
  // to the framework, don't delete
  if (init_mode)
  {
      map module_map = OSRPartitionInit();

      return module_map; 
  }
  // end MAIN
}
