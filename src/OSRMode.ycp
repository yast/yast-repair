/**
 * File:	OSRMode.ycp
 * Module:	repair
 * Summary:	Special OSR mode
 * Authors:	Johannes Buchhold <jbuch@suse.de>
 *
 * $Id$
 *
 * Provide osr mode information.
 */

{
    module "OSRMode";

    import "Mode";
    import "OSRLogFile";
    import "Stage";
    import "Report";

    textdomain "repair";

    /**
     * Automatic detection and repair, no user-interaction but GUI.
     */
    global boolean automatic	= false;

    /**
     * No real error-detection or repair, only demonstration, GUI.
     */
    global boolean demo		= false;

    /**
     *  Only detection, no repair, GUI.
     */
    global boolean detection	= false;

    /**
     *  No GUI, no user-interaction, input-values come from a map.
     */
    global boolean script	= false;

    /**
     * Prints the values provided by the detection-modules to the
     */
    global boolean provides	  = false;

    global boolean save		  = false;

    /**
     * Get the execution-mode, description:
     * Stage::initial ()  == true -> Initial boot per CD-Rom or NFS
     * Stage::cont ()     == true -> Continue installation
     * Stage::initial ()e == false) && (Stage::cont () == false) -> Running Linux-system
     */
    global define boolean IsValid() {

	if (!Stage::initial () && !Stage::cont () )
	{
	    y2milestone("Starting the rescue-system from the running Linux-system!");
	    OSRLogFile::Add("Starting the rescue-system from the running Linux-system!\n");
	}
	else if (Stage::initial () && !Stage::cont ())
	{
	    y2milestone("Starting the rescue-system directly after boot from cdrom or per nfs");
	    OSRLogFile::Add("Starting the rescue-system directly after boot from cdrom or per nfs\n");
	}
	else if (!Stage::initial () && Stage::cont ())
	{
	    y2milestone("NOT starting the rescue-system! Continue installation first!");
	    OSRLogFile::Add("NOT starting the rescue-system! Continue installation first!\n");

	    // error popup
	    Report::Error(_("
Finish installation before
starting the YaST2 repair system.

YaST2 halts now.
"));
	    return false;
	}
	else
	{
	    y2warning("Something's wrong: initial_mode == %1 and continue_mode == %2, but cannot both be true!",
		      Stage::initial (), Stage::cont ());
	}
	return true;
    }

    //---------------------------------------------------------------
    // init function, return value is true if some mode was set
    global define boolean Init () {

	boolean ret	= false;
	integer arg_count = size(WFM::Args());
	integer arg_no = 0;

	if ( size(WFM::Args()) > 1 )
	{
	    y2error("Too many arguments: size(%1) == %2, no more than one allowed.",
		    WFM::Args(), size(WFM::Args()) );
	}
	else
	{
	    while ( arg_no < size(WFM::Args()) )
	    {
		y2debug("option #%1: %2", arg_no, WFM::Args(arg_no) );

		if ( WFM::Args(arg_no) == "automatic" )
		{
		    automatic	= true;
		    ret		= true;
		    OSRLogFile::Add("Running in automatic mode.\n");
		}
		else if ( WFM::Args(arg_no) ==  "provides" )
		{
		    provides	= true;
		    ret		= true;
		    OSRLogFile::Add("Running in automatic mode.\n");
		}
		else if ( WFM::Args(arg_no) == "detection" ||  WFM::Args(arg_no) == "detect"  )
		{
		    detection	= true;
		    ret		= true;
		    OSRLogFile::Add("Running in detection mode.\n");
		}
		else if ( WFM::Args(arg_no) == "script" )
		{
		    script	= true;
		    ret		= true;
		    OSRLogFile::Add("Running in script mode.\n");
		}
		else if ( WFM::Args(arg_no) == "save" )
		{
		    y2milestone("Save mode");
		    save	= true;
		    ret		= true;
		}
		else
		{
		    y2error("Unknown option %1.", WFM::Args(arg_no) );
		}
		arg_no = arg_no + 1;
	    }
	}
	return ret;
    }
}
