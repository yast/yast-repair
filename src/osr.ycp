/**
 *  File:
 *    osr.ycp
 *
 *  Module:
 *    YaST2 OS Repair - automatic error detection & repair tool for Linux.
 *
 *  Summary:
 *    This file provides the framework of the YaST2 OS Repair tool. It contains some
 *    main functions that control the detection and repair process and some additional
 *    functions which form the interface for the detection and repair modules.
 *
 *  Author:
 *    Michael Koehrmann <curry@suse.de>
 */

/***
 *
 *  YaST2 OS Repair
 *
 */

{
  textdomain "osr";

  include "ui/common_popups.ycp";
  include "ui/wizard_dialog.ycp";
  include "osr/osr_system.ycp";
  include "osr/osr_api.ycp";
  include "osr/osr_summary.ycp";
  include "osr/osr_popup.ycp";

  import "osr/OSRModuleProgress";
  import "osr/OSRGlobalProgress";
  import "osr/OSRLogFile";

  ////////////////////////////////////////////////////////////////////////////////
  //
  //  GLOBAL VARIABLES
  //
  ////////////////////////////////////////////////////////////////////////////////
  
  // This map contains all informations for the whole YaST2 OS Repair-system, except
  // the lists of detection-methods. The .. is that the functions are executed if
  // the osr_map is written to a file.
  map osr_map              = $[];

  // This map contains the old informations from a previous session. The old value has to
  // be saved to a floppy-device and can be loaded at the beginning of each session.
  map old_osr_map          = $[];

  // A map with all lists of detect-methods. The function-names have to be enclosed in
  // double-quoted braces!
  // osr_detect_method_map = $[
  //     "osr_module_init"      : [ ``(OSRInitConvertUserSettings()), ``(OSRInitCheckFstab()) ],
  //     "osr_module_partition" : [ ``(OSRPartitionCheck()), ``(OSRPartitionCheckDisks()) ],
  //     "osr_module_lilo"      : [ ... ] ]
  map osr_detect_method_map = $[];

  // if YaST2 OS Repair runs
  // - from CD-ROM or per NFS, get the user_settings from installation.ycp
  // - the installed Linux-system, get the user_settings from file
  map user_settings = user_settings;
  
  if ((size(user_settings) == nil) || (size(user_settings) == 0))
  {
      // TODO: compute the user_settings (like installation.ycp)
      user_settings = SCR::Read(.target.ycp, "/var/lib/YaST2/user_settings");
  }

  ////////////////////////////////////////////////////////////////////////////////
  //
  //  ARGUMENT HANDLING
  //
  ////////////////////////////////////////////////////////////////////////////////

  integer arg_n = 0;

  boolean normal_mode    = true;       // The normal mode with GUI and user-interaction.
  boolean automatic_mode = false;      // Automatic detection and repair, no user-interaction but GUI.
  boolean demo_mode      = false;      // No real error-detection or repair, only demonstration, GUI.
  boolean detection_mode = false;      // Only detection, no repair, GUI.
  boolean script_mode    = false;      // No GUI, no user-interaction, input-values come from a map.
  boolean provides_mode  = false;      // Prints the values provided by the detection-modules to the
                                       // file /tmp/osr_global_provides.

  if      ( size(Args()) == 0 ) normal_mode = true;
  else if ( size(Args()) > 1 )
  {
      y2error("ERROR: too many arguments: %1, no more than one allowed.", size(Args()) );
      return `error;
  }
  else
  {
      while ( arg_n < size(Args()) )
      {
	  if      ( Args(arg_n) == .automatic ) automatic_mode = true;
	  else if ( Args(arg_n) == .auto      ) automatic_mode = true;
	  else if ( Args(arg_n) == .demo      ) demo_mode      = true;
	  else if ( Args(arg_n) == .detection ) detection_mode = true;
	  else if ( Args(arg_n) == .detect    ) detection_mode = true;
	  else if ( Args(arg_n) == .normal    ) normal_mode    = true;
	  else if ( Args(arg_n) == .script    ) script_mode    = true;
	  else if ( Args(arg_n) == .provides  ) provides_mode  = true;
	  else
	  {
	      y2error("ERROR: unknown option %1", Args(arg_n) );
	      return `error;
	  }
	  arg_n = arg_n + 1;
      }
  }

  // a map that contains the boolean values of all execution-modes
  map mode_map = $[
		   "automatic_mode" : automatic_mode,
		   "demo_mode"      : demo_mode,
		   "detection_mode" : detection_mode,
		   "normal_mode"    : normal_mode,
		   "script_mode"    : script_mode,
		   "provides_mode"  : provides_mode
  ];

  // store the map of modes to the global map
  osr_map = add(osr_map, "mode_map", mode_map);

  ////////////////////////////////////////////////////////////////////////////////
  //
  //  METHODS
  //
  ////////////////////////////////////////////////////////////////////////////////

  /**
   *  This method initializes the YaST2 OS Repair system. It is started at first and
   *  builds the main window, the global osr_map and a lot of other data.
   *
   *  For internal use only.
   *
   *  @return boolean True if the initialization progress succeeded.
   */
  define OSRInit() ``{

      // TODO: specify if the rescue-system is executed from CD-ROM, NFS, from a running Linux-system, ...
      //SCR::Read(.proc.mounts);


      // TODO: get the execution-mode
      string execution_mode = "linux";
      
      osr_map = $[
		  "execution_mode"               : execution_mode,
		  "module_sequence"              : [],               // sequence of execution of the detection-modules
		  "module_list"                  : [],               // the whole list of detection-modules
		  "log_file"                     : "/tmp/osr.log",   // default log-file-path
		  "has_download_progress_widget" : true,             // boolean, DownloadProgress-widget exists for current UI
		  "read_old_osr_map"             : false,            // boolean, old osr_map is already read from floppy
		  "osr_map_stored"               : false             // boolean, osr_map is already stored to floppy
      ];
      
      string log_file = "";

      string header = "";
      
      header = _("YaST2 OS Repair");

      if (demo_mode)
      {
	  header = _("YaST2 OS Repair: demo mode");
      }
      else if (automatic_mode)
      {
	  header = _("YaST2 OS Repair: automatic mode");
      }

      
      /*
      string header   = "";
      
      if (execution_mode == "linux")
      {

      }
      else if (execution_mode == "cdrom")
      {
      UI::ChangeWidget(`id(`abort), `Label, _("&Abort"));
      }
      else if (execution_mode == "nfs")
      {
      UI::ChangeWidget(`id(`abort), `Label, _("&Abort"));
      }
      else
      {
	  y2error("unknown execution_mode: %1", execution_mode);
      }

      if (!script_mode)
      {
	  header = _("YaST2 OS Repair");

	  if (demo_mode)
	  {
	      header = _("YaST2 OS Repair: demo mode");
	  }
	  else if (automatic_mode)
	  {
	      header = _("YaST2 OS Repair: automatic mode");
	  }
      
	  // display the main window to indicate progress

	  if (execution_mode == "linux")
	  {
	      UI(``{
		  OpenDialog(`opt(`defaultsize),
			     `VBox(`Image(`suseheader, "SuSE"),
				   `HBox(`HWeight(30, `RichText(`id(`help), "")),
					 `HWeight(70, `VBox(
							    `Left(`Heading(`id(`title), `opt(`hstretch),
									   WFM::header + _("\nInitialization..."))),
							    `HVCenter(`ReplacePoint(`id(`contents), `Empty())),
							    `HBox(
								  // Back pushbutton: the user input is ignored and the last dialog is called
								  `PushButton(`id(`back), `opt(`disabled), _("&Back")),
								  `HStretch(),

								  // Skip pushbutton
								  //`PushButton(`id(`skip), `opt(`disabled), _("&Skip")),
								  //`HStretch(),

								  // Abort pushbutton
								  `PushButton(`id(`abort), `opt(`disabled), _("&Abort")),
								  `HStretch(),

								  // Next pushbutton
								  `PushButton(`id(`next), `opt(`disabled), _("&Next"))
								  )
							    )
						  )
					 )
				   )
			     );
		  ChangeWidget(`id(`abort), `Enabled, false);
	      });
	  }

	  if (!UI::HasSpecialWidget(`DownloadProgress))
	  {
	      //osr_map = add(osr_map, "has_download_progress_widget", false);

	      if (!automatic_mode)
	      {
		  // show error message
		  UI::ErrorPopup(_("Some special widgets are not available."));

		  return false;
	      }
	  }
      }
      */

      // get the list of modules from the client osr_module_list.ycp,
      // the returned list has to look like this:
      // [`osr_module_init(), `osr_module_partition, `osr_module_lilo()]
      list osr_module_list = [];
      osr_module_list      = CallFunction(`osr_module_list());
      
      // add .init to the symbols
      list temp_list = [];
      foreach(`n, osr_module_list, ``{temp_list = add(temp_list, add(n, .init));});
      osr_module_list = temp_list;

      // get the name of the global log-file and set it up
      // TODO
      /*
      log_file = OSRLogFile::GetFile();
      
      if (!OSRLogFile::Setup(log_file))
      {
	  //return false;
      }
      */
      OSRLogFile::SetFile("osr.log");
      
      integer index    = 0;
      
      // execute the init-functions of all modules in the module-list
      while((index >= 0) && (index < size(osr_module_list)))
      {
	  map    result_map            = $[];
	  map    provides_map          = $[];
	  string module_name           = "";
	  list   module_detect_methods = [];

	  // the result of evaluation is the module_map
	  result_map     = CallFunction(select(osr_module_list, index));

	  if ((result_map == nil) || (result_map == $[]))
	  {
	      OSRPopupDisplayQuick(
				   sformat(UI_("An error occurred during execution
of the init-functions of module: %1

YaST2 OS Repair halts now.",
				     select(osr_module_list, index)
				     )),
				   2000
				   );
	      
	      y2error("An error occurred during execution of the init-functions of module: %1",
		      select(osr_module_list, index));
	      
	      return false;
	  }
	  
	  // the map that contains all information about which module provides which value
	  provides_map = lookup(result_map, "provides", $[]);

	  // the name of the current module
	  module_name = lookup(result_map, "name", "");

	  // the list of detect-methods of the current module
	  module_detect_methods = lookup(result_map, "detect_methods", $[]);

	  // delete the detect_methods from the result_map (it should not appear in the osr_map)
	  result_map = filter(`k, `v, result_map, ``(k != "detect_methods"));

	  // add the detect-methods of the current module to the global detect-methods-map
	  osr_detect_method_map = add(osr_detect_method_map, module_name, module_detect_methods);
	  
	  // add the module_map to the global osr_map
	  osr_map = add(osr_map, module_name, result_map);
	  
	  // add the provides map to the global osr_map
	  osr_map = add(osr_map, "global_provides" ,provides_map);

	  // a list that contains the names of all modules: ["osr_module_init", "osr_module_lilo", ...]
	  list module_list = lookup(osr_map, "module_list", []);

	  // get the current module-name, put it to the module-list and store it in the global map
	  module_list = add(module_list, lookup(result_map, "name", ""));
	  osr_map     = add(osr_map, "module_list", module_list);
	  
	  // increase the index counter
	  index = index + 1;
      }

      // create the sequence list, provides- and requirement-resolver
      if (OSRComputeModuleSequence())
      {
	  y2debug("OSRInit: all dependencies between the modules successfully solved.");
      }
      else
      {
	  y2error("ERROR OSRInit: not all dependencies between the modules successfully solved!");

	  if (!automatic_mode)
	  {
	      // show error message and close the main window
	      UI::ErrorPopup(_("Not all dependencies between the modules
were successfully solved.

YaST2 OS Repair halts now."));
	  }
	  return false;
      }
      
      if (!script_mode)
      {
      
	  UI::ChangeWidget(`id(`title), `Value, header + _("\nInitialization succeeded"));

	  integer osr_module_progress_length = OSRModuleProgress::length;
	  integer osr_global_progress_length = OSRGlobalProgress::length;

	  // Build window contents
	  UI(``{
	      term    download_progress      = `Empty();
	      term    progress_bar           = `Empty();
	      term    buttons_right          = `Empty();
	      term    rich_text              = `Empty();
	      term    contents               = `Empty();
	      string  help_text              = "";

	      /*
		buttons_right = `HSquash(`Top(`VBox(`PushButton(`id(`repair),`opt(`disabled),_("&Repair")),`PushButton(`id(`help_button),
		`opt(`hstretch),_("&Help")))));
	      */

	      // only use a DownloadProgress-widget if it is supported by the UI-interpreter
	      // (e.g. QT: supported, ncurses: NOT supported)
	      if (UI::HasSpecialWidget(`DownloadProgress))
	      {
		  download_progress = `DownloadProgress(
							`id(`module_progress_bar),
							_("Module check"),
							"/tmp/module_progress_bar",
						        WFM::osr_module_progress_length
							);
	      }

	      progress_bar = `ProgressBar(
					  `id(`global_progress_bar),
					  "System check",
					  WFM::osr_global_progress_length
					  );

	      rich_text = `RichText(
				    `id(`rich_text_info),
				    ""
				    );
	  
	      // Contents of the dialog	  
	      contents = `VBox(
			       `VSpacing(0.3),
			       `HBox(
				     rich_text,
				     buttons_right
				     ),
			       `HBox(
				     download_progress
				     ),
			       `HBox(
				     progress_bar
				     ),
			       `VSpacing(0.5)
			       );
	  	  
	      // Help text (HTML-like) START
	      help_text =  _("<p><b>YaST2 OS Repair</b> now checks your system.</p>");
	      help_text = help_text +  _("<p>This can take some time depending on the system conditions.</p>");

	      SetWizardContents(
				_("YaST2 OS Repair - System check"),
				contents,
				help_text,
				false,         // have_back_button
				false          // have_next_button
				);
	  });

	  // set the increment value for the global progress bar
	  OSRGlobalProgress::ComputeIncrement(lookup(osr_map, "module_sequence", []), osr_detect_method_map);
      }

      //SCR(`Write(.dumpto.tmp.osr_map, osr_map));
      
      return true;
  }

  /**
   *  With this function a new module entry is added to the list module_list in the
   *  global osr_map.
   *
   *  For internal use only.
   *
   *  @param string entry The new entry as a string.
   *  @return map The osr_map with the new entry in the module_list.
   */
  define OSRAddToModuleList(string entry) ``{

      list temp_list = [];

      // get the old module_list from the osr_map
      temp_list = lookup(osr_map, "module_list", []);

      // add the new entry to the list
      temp_list = add(temp_list, entry);

      // return the addition of the new module_list to the osr_map
      return add(osr_map, "module_list", temp_list);
  }
  
  
  /**
   *  This is the main detection method. It looks for the module_sequence and
   *  executes all detection methods from the forthcoming modules.
   *
   *  For internal use only.
   *
   *  @return boolean True if the detection progress succeeded.
   */
  define OSRDetect() ``{

      integer index_modules   = 0;
      integer index_detect    = 0;
      string  module_name     = "";
      string  status          = "";
      list    detect_methods  = [];
      list    module_sequence = [];
      map     result_map      = $[];
      map     module_map      = $[];

      module_sequence = lookup(osr_map, "module_sequence", []);

      if ( size(module_sequence) <= 0 )
      {
	  y2error("OSRDetect ERROR: list module_sequence is empty: %1", module_sequence);
	  return false;
      }

      while ( index_modules < size(module_sequence) )
      {
	  module_name    = select(module_sequence, index_modules, "");
          module_map     = lookup(osr_map, module_name, $[]);
	  detect_methods = lookup(osr_detect_method_map, module_name, []);
	  
	  // reset some values to empty before re-entry into the loop!
	  index_detect   = 0;
	  result_map     = $[];
	  status         = "";
	      
	  // execute all detect-functions of the specified module
	  while((index_detect >= 0) && (index_detect < size(detect_methods)))
	  {
	      // evaluate the functions and get the result_map
	      result_map      = eval(select(detect_methods, index_detect));

	      // get some information from the result_map
	      status          = lookup(result_map, "status", "");
	      
	      if (status == "detect_ok")
	      {
		  // if no error detected go to the next detection-method
		  OSRGlobalProgress::Increase();
		  index_detect = index_detect + 1;
	      }
	      else if (status == "detect_error")
	      {
		  // if an error was detected but no repair method started
		  // restart the current detection method
	      }
	      else if (status == "repair_ok")
	      {
		  // if all detected errors were repaired restart the current
		  // detection method
	      }
	      else if (status == "repair_error")
	      {
		  // if the repair-method was not successfull restart the current
		  // detection method
	      }
	      else if (status == "repair_omit")
	      {
		  // if the user omitted repairing go to the next detection method
		  OSRGlobalProgress::Increase();
		  index_detect = index_detect + 1;
	      }
	      else
	      {
		y2error("not a valid status: %1", status);
	      }
	  }

	  // deposit the result map in the global osr_map
	  //module_map = add(module_map, "result_map", result_map);
	  //osr_map    = add(osr_map, module_name, module_map);

	  OSRModuleProgress::Fill();
	  
	  // go to the next module
	  index_modules = index_modules + 1;
      }

      // fill up the global-progress-bar to 100%, this can be neccessary because of
      // arithmetic rounding problems
      OSRGlobalProgress::Fill();
      
      return true;
  }

  /**
   *  Return true if user id is 0 (user is root).
   *
   *  For internal use only.
   *
   *  @see .runtime.username
   *  @return boolean True if the osr module was run by root.
   */
  define OSRAmIRoot() ``{

      string user_name = "";

      user_name = SCR::Read(.runtime.username);

      return (user_name == "root");
      
      /*
      map     ret          = $[];
      string  command      = "";
      string  user_name    = "";
      integer exit_code    = 0;

      command   = "/usr/bin/whoami";
      
      // format of ret should be $["exit":0, "stderr":"", "stdout":"root\n"]
      ret       = SCR (`Execute(.target.bash_output, command));

      exit_code = lookup(ret, "exit",   1);
      user_name = lookup(ret, "stdout", "");
      
      //y2debug("WHOAMI: %1", ret);
	
      if (exit_code == 0)
      {
	  return (user_name == "root\n");
      }

      // otherwise there was a trouble running whoami so we assume we are root
      // so user can continue
      // ???
      return true;
      */
  }

  ////////////////////////////////////////////////////////////////////////////////
  //
  //  MAIN
  //
  ////////////////////////////////////////////////////////////////////////////////

  if (provides_mode)
  {
      integer index                = 0;
      map     global_provides_map  = $[];
      list    osr_module_list      = [];

      osr_module_list = SCR::Read (.target.ycp, "/usr/lib/YaST2/osr_module_list.ycp");

      // add .init to the symbols
      list temp_list = [];
      foreach(`n, osr_module_list, ``{temp_list = add(temp_list, add(n, .init));});
      osr_module_list = temp_list;

      // execute the init-functions of all modules in the module-list
      while((index >= 0) && (index < size(osr_module_list)))
      {
	  map    result_map   = $[];
	  map    provides_map = $[];
	  string module_name  = "";

          // the result of evaluation is the module_map
	  result_map     = CallFunction(select(osr_module_list, index));
	  provides_map   = lookup(result_map, "provides", $[]);

	  // add the module_map to the global osr_map
	  module_name    = lookup(result_map, "name", "");
	  osr_map        = add(osr_map, module_name, result_map);

	  // add the provides map to the global osr_map
          global_provides_map = lookup(osr_map, "global_provides", $[]);
	  global_provides_map = add(global_provides_map, module_name, provides_map);
	  osr_map             = add(osr_map, "global_provides", global_provides_map);

	  // increase the index counter
	  index = index + 1;
      }
      global_provides_map = lookup(osr_map, "global_provides", $[]);

      // save the global-provides-map to the /tmp-directory
      SCR::Write(.dumpto.tmp.osr_global_provides, global_provides_map);

      return;
  }
  
//  SCR(`Write(.dumpto.tmp.user_settings, user_settings));
  
  if (!demo_mode)
  {
      /*
      if (!OSRAmIRoot())
      {
	  UI(`AnyMessagePopup(_("YaST2 OS Repair: Error"),
			      _("You have to be logged in as root in order to start\nthe rescue system.\n\nYaST2 OS Repair halts now.")
			      ));
      
	  return;
      }
      */
  }

  if (!OSROpenMainWindow())
  {
      return UI::CloseDialog();
  }

  // ask the user for reading an old osr_map from a previos
  // YaST2 OS Repair-session. The map has to be stored in a
  // file "osr_map.ycp" on a floppy-disk.
  old_osr_map = OSRMapReadFloppy();
        
  if (!OSRInit())
  {
      return UI::CloseDialog();
  }

  if (!OSRDetect())
  {
      return UI::CloseDialog();
  }

  // ask the user to store the whole osr_map to floppy-disk for later
  // YaST2 OS Repair-sessions
  OSRMapWriteFloppy();
  
  if (!script_mode)
  {
      // enable the buttons
      UI::ChangeWidget(`id(`next), `Enabled, true);
      UI::ChangeWidget(`id(`abort), `Enabled, true);
      UI::ChangeWidget(`id(`back), `Enabled, true);
      UI::SetFocus(`id(`next));
  
      // wait for user input
      any user_input = nil;

      if (automatic_mode)
      {
	  user_input = `next;
      }
      
      while((user_input != `next) && (user_input != `back) && (user_input != `abort))
      {
	  user_input = UI::UserInput();
      }
      
      if ((user_input == `next) || (user_input == `abort))
      {
	  UI::CloseDialog();
      }
      
      return user_input;
  }
  else
  {
      return `next;
  }

  /*
  // definition of map user_settings  
  map user_settings = $[];
  
  //  set "os_repair_status" `off
  user_settings = add(user_settings, "osr_status", `off);
  
  global define SetContents(string title, term contents, string helptext,
			    boolean has_back, boolean has_skip, boolean has_abort, boolean has_next) ``{
      ChangeWidget(`id(`next),  `Enabled, has_next);
      ChangeWidget(`id(`back),  `Enabled, has_back);
      ChangeWidget(`id(`skip),  `Enabled, has_skip);
      ChangeWidget(`id(`abort), `Enabled, has_abort);
      ChangeWidget(`id(`help),  `Value,   helptext);
      ChangeWidget(`id(`title), `Value,   title);
      ReplaceWidget(`id(`contents), contents);
  };

  user_settings = add( user_settings, "demo_mode", demo_mode );
  user_settings = add( user_settings, "auto_mode", auto_mode );
  */
  
  /*
   * Main dialog cycle
   *
   */

  /*
  integer osr_module_list_index = 0;

  any result = `next;

  while ((osr_module_list_index >= 0) && (osr_module_list_index < size (osr_module_list))) {
    
      result = eval(select(osr_module_list, osr_module_list_index));
    
      if ( result == `cancel )
      {
	  break;
      }
      else if ( result == `skip )
      {
	  osr_module_list_index = osr_module_list_index + 1;
      }
      else if ( result == `next )
      {
	  osr_module_list_index = osr_module_list_index + 1;
      }
      else if ( result == `back )
      {
	  osr_module_list_index = osr_module_list_index - 1;
      }
      else if ( result == `finish )
      {
	  break;
      }
  }
  */
  
  //return UI(`CloseDialog());
}
