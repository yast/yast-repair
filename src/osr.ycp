/**
 *  File:
 *    osr.ycp
 *
 *  Module:
 *    YaST2 OS Repair - automatic error detection & repair tool for Linux.
 *
 *  Summary:
 *    This file provides the framework of the YaST2 OS Repair tool. It contains some
 *    main functions that control the detection and repair process and some additional
 *    functions which form the interface for the detection and repair modules.
 *
 *  Author:
 *    Michael Koehrmann <curry@suse.de>
 *
 * $Id$
 */

/***
 *
 *  YaST2 OS Repair
 *
 */

{
  textdomain "osr";

  include "ui/common_popups.ycp";
  include "ui/wizard_dialog.ycp";
  include "installation_ui.ycp";

  include "osr/osr_system.ycp";
  include "osr/osr_api.ycp";
  include "osr/osr_summary.ycp";
  include "osr/osr_popup.ycp";

  import "osr/OSRModuleProgress";
  import "osr/OSRGlobalProgress";
  import "osr/OSRLogFile";

  import "Installation";
//  import "Arch";

  ////////////////////////////////////////////////////////////////////////////////
  //
  //  GLOBAL VARIABLES
  //
  ////////////////////////////////////////////////////////////////////////////////

  // Path of the global log file.
  string log_file = "" + OSRGetTmpDir() + "/osr_log";

  // Set the global log file, if it not succeeds, exit the rescue system.
  if (!OSRLogFile::SetFile(log_file))
  {
      y2error("Setup of the log file failed. YaST2 OS Repair exits now!");

      return false;
  }

  // This map contains all informations for the whole YaST2 OS Repair-system, except
  // the lists of detection-methods. The .. is that the functions are executed if
  // the osr_map is written to a file.
  map osr_map              = $[];

  // This map contains the old informations from a previous session. The old value has to
  // be saved to a floppy-device and can be loaded at the beginning of each session.
  map old_osr_map          = $[];

  // A map with all lists of detect-methods. The function-names have to be enclosed in
  // double-quoted braces!
  // osr_detect_method_map = $[
  //     "osr_module_init"      : [ ``(OSRInitConvertUserSettings()), ``(OSRInitCheckFstab()) ],
  //     "osr_module_partition" : [ ``(OSRPartitionCheck()), ``(OSRPartitionCheckDisks()) ],
  //     "osr_module_lilo"      : [ ... ] ]
  map osr_detect_method_map = $[];

  // get the execution-mode, description:
  // Installation::initial_mode  == true -> Initial boot per CD-Rom or NFS
  // Installation::continue_mode == true -> Continue installation
  // (Installation::initial_mode == false) && (Installation::continue_mode == false) -> Running Linux-system
  if (!Installation::initial_mode && !Installation::continue_mode)
  {
      y2milestone("Starting the rescue-system from the running Linux-system!");

      OSRLogFile::Add("Starting the rescue-system from the running Linux-system!\n");
  }
  else if (Installation::initial_mode && !Installation::continue_mode)
  {
      y2milestone("Starting the rescue-system directly after boot from cdrom or per nfs");

      OSRLogFile::Add("Starting the rescue-system directly after boot from cdrom or per nfs\n");
  }
  else if (!Installation::initial_mode && Installation::continue_mode)
  {
      y2milestone("NOT starting the rescue-system! Continue installation first!");

      OSRLogFile::Add("NOT starting the rescue-system! Continue installation first!\n");

      ErrorPopup(_("You have to finish installation before
starting the YaST2 OS Repair-system.

YaST2 OS Repair halts now."));
	  
      return false;
  }
  else
  {
      y2warning("Something's wrong: initial_mode == %1 and continue_mode == %2, but cannot both be true!",
	      Installation::initial_mode, Installation::continue_mode);
  }
      
  osr_map = $[
	      "initial_mode"  : Installation::initial_mode,
	      "continue_mode" : Installation::continue_mode
  ];
  
  // get the user_settings from the initial YaST2 installation client module
  // y2m_inst/ycp/general/inst_startup.ycp
  map user_settings = user_settings;

  if ((size(user_settings) == nil) || (size(user_settings) == 0))
  {
      user_settings = $[];
  }
  else
  {
      if (Installation::initial_mode && !Installation::continue_mode)
      {
	  // write the actual user settings for later use
	  SCR::Write(.target.ycp, "/var/lib/YaST2/user_settings", user_settings);
      
	  OSRLogFile::Add(sformat("map user_settings:\n%1\n", user_settings));
      }
  }

  ////////////////////////////////////////////////////////////////////////////////
  //
  //  ARGUMENT HANDLING
  //
  ////////////////////////////////////////////////////////////////////////////////

  integer arg_n = 0;

  boolean normal_mode    = true;       // The normal mode with GUI and user-interaction.
  boolean automatic_mode = false;      // Automatic detection and repair, no user-interaction but GUI.
  boolean demo_mode      = false;      // No real error-detection or repair, only demonstration, GUI.
  boolean detection_mode = false;      // Only detection, no repair, GUI.
  boolean script_mode    = false;      // No GUI, no user-interaction, input-values come from a map.
  boolean provides_mode  = false;      // Prints the values provided by the detection-modules to the
                                       // file /tmp/osr_global_provides.
  boolean test_mode      = false;

  if ( size(Args()) == 0 )
  {
      normal_mode = true;

      OSRLogFile::Add("Running in normal mode.\n");
  }
  else if ( size(Args()) > 1 )
  {
      y2error("ERROR: too many arguments: size(%1) == %2, no more than one allowed. YaST2 OS Repair halts now!",
	      Args(), size(Args()) );

      return `error;
  }
  else
  {
      while ( arg_n < size(Args()) )
      {
	  if ( Args(arg_n) == .automatic )
	  {
	      automatic_mode = true;

	      OSRLogFile::Add("Running in automatic mode.\n");
	  }
	  else if ( Args(arg_n) == .auto )
	  {
	      automatic_mode = true;

	      OSRLogFile::Add("Running in automatic mode.\n");
	  }
	  else if ( Args(arg_n) == .demo )
	  {
	      demo_mode      = true;

	      OSRLogFile::Add("Running in demo mode.\n");
	  }
	  else if ( Args(arg_n) == .detection )
	  {
	      detection_mode = true;

	      OSRLogFile::Add("Running in detection mode.\n");
	  }
	  else if ( Args(arg_n) == .detect )
	  {
	      detection_mode = true;

	      OSRLogFile::Add("Running in detection mode.\n");
	  }
	  else if ( Args(arg_n) == .normal )
	  {
	      normal_mode    = true;

	      OSRLogFile::Add("Running in normal mode.\n");
	  }
	  else if ( Args(arg_n) == .script )
	  {
	      script_mode    = true;

	      OSRLogFile::Add("Running in script mode.\n");
	  }
	  else if ( Args(arg_n) == .provides )
	  {
	      provides_mode  = true;

	      OSRLogFile::Add("Running in provides mode.\n");
	  }
	  else
	  {
	      y2error("ERROR: unknown option %1. YaST2 OS Repair halts now!", Args(arg_n) );

	      return `error;
	  }
	  arg_n = arg_n + 1;
      }
  }

  // a map that contains the boolean values of all execution-modes
  map mode_map = $[
		   "automatic_mode" : automatic_mode,
		   "demo_mode"      : demo_mode,
		   "detection_mode" : detection_mode,
		   "normal_mode"    : normal_mode,
		   "script_mode"    : script_mode,
		   "provides_mode"  : provides_mode
  ];

  // store the map of modes to the global map
  osr_map = add(osr_map, "mode_map", mode_map);

  ////////////////////////////////////////////////////////////////////////////////
  //
  //  METHODS
  //
  ////////////////////////////////////////////////////////////////////////////////

  /**
   *  This method initializes the YaST2 OS Repair system. It is started at first and
   *  builds the main window, initializes the global osr_map and a lot of other data.
   *
   *  For internal use only.
   *
   *  @return boolean True if the initialization progress succeeded.
   */
  define OSRInit() ``{

      string header   = "";
      
      osr_map = $[
		  "module_sequence"              : [],               // sequence of execution of the detection-modules
		  "module_list"                  : [],               // the whole list of detection-modules
		  "has_download_progress_widget" : true,             // boolean, DownloadProgress-widget exists for current UI
		  "read_old_osr_map"             : false,            // boolean, old osr_map is already read from floppy
		  "osr_map_stored"               : false             // boolean, osr_map is already stored to floppy
      ];

      // create the header of the main window
      header = _("YaST2 OS Repair");

      if (demo_mode)
      {
	  header = _("YaST2 OS Repair: demo mode");
      }
      else if (automatic_mode)
      {
	  header = _("YaST2 OS Repair: automatic mode");
      }

      // get the list of modules from the client osr_module_list.ycp,
      // the returned list has to look like this:
      // [`osr_module_init(), `osr_module_partition(), `osr_module_lilo(), `osr_module_finish()]
      list osr_module_list = [];
      osr_module_list      = CallFunction(`osr_module_list());

      if ((osr_module_list == nil) || (size(osr_module_list) == 0))
      {
	  y2error("OSRInit Error: something's wrong with the file \"osr_module_list.ycp\". YaST2 OS Repair halts now!");

	  OSRPopupDisplayQuick(_("Error during initialization.

YaST2 OS Repair halts now."), 2000);
	  
	  return false;
      }
      OSRLogFile::Add(sformat("List of modules:\n%1\n", osr_module_list));
      
      // add .init to the symbols, e.g.: `osr_module_init() -> `osr_module_init(.init)
      list temp_list = [];
      foreach(`n, osr_module_list, ``{temp_list = add(temp_list, add(n, .init));});
      osr_module_list = temp_list;

      integer index = 0;

      // execute the init-functions of all modules in the module-list
      while((index >= 0) && (index < size(osr_module_list)))
      {
	  map    result_map            = $[];
	  map    provides_map          = $[];
	  string module_name           = "";
	  list   module_detect_methods = [];

	  // the result of this evaluation is the module_map of the specific module
	  result_map = CallFunction(select(osr_module_list, index));

	  if ((result_map == nil) || (result_map == $[]))
	  {
	      OSRPopupDisplayQuick(sformat(_("An error occurred during execution
of the init-functions of module: %1

YaST2 OS Repair halts now."), select(osr_module_list, index)), 2000);
	      
	      y2error("An error occurred during execution of the init-functions of module: %1. YaST2 OS Repair halts now!",
		      select(osr_module_list, index));
	      
	      return false;
	  }
	  
	  // the map that contains all information about which module provides which value
	  provides_map = lookup(result_map, "provides", $[]);

	  // the name of the current module
	  module_name = lookup(result_map, "name", "");

	  // the list of detect-methods of the current module
	  module_detect_methods = lookup(result_map, "detect_methods", $[]);

	  // delete the detect_methods from the result_map (it should not appear in the osr_map)
	  result_map = filter(`k, `v, result_map, ``(k != "detect_methods"));

	  // add the detect-methods of the current module to the global detect-methods-map
	  osr_detect_method_map = add(osr_detect_method_map, module_name, module_detect_methods);
	  
	  // add the module_map to the global osr_map
	  osr_map = add(osr_map, module_name, result_map);
	  
	  // add the provides map to the global osr_map
	  osr_map = add(osr_map, "global_provides" ,provides_map);

	  // a list that contains the names of all modules: ["osr_module_init", "osr_module_lilo", ...]
	  list module_list = lookup(osr_map, "module_list", []);

	  // get the current module-name, put it to the module-list and store it in the global map
	  module_list = add(module_list, lookup(result_map, "name", ""));
	  osr_map     = add(osr_map, "module_list", module_list);
	  
	  // increase the index counter
	  index = index + 1;
      }

      // Create the sequence-list of the detection-modules.
      // This is the provides- and requirement-resolver.
      if (OSRComputeModuleSequence())
      {
	  y2debug("OSRInit: all dependencies between the modules successfully solved.");
      }
      else
      {
	  y2error("ERROR OSRInit: not all dependencies between the modules successfully solved. YaST2 OS Repair halts now!");

	  OSRLogFile::Add("Not all dependencies between the modules successfully solved.");

	  if (!automatic_mode)
	  {
	      // show error message and close the main window
	      UI::ErrorPopup(_("Not all dependencies between the modules
were successfully solved.

YaST2 OS Repair halts now."));
	  }
	  return false;
      }
      
      if (!script_mode)
      {
	  UI::ChangeWidget(`id(`next), `Label, _("&Next"));

	  //UI::ChangeWidget(`id(`back), `Enabled, false);
	  //UI::ChangeWidget(`id(`abort), `Enabled, false);
	  //UI::ChangeWidget(`id(`next), `Enabled, false);

	  UI::ChangeWidget(`id(`title), `Value, header + _("\nInitialization succeeded"));

	  // display the main window
	  OSRSetMainWindowContents();
	  
	  // set the increment value for the global progress bar
	  OSRGlobalProgress::ComputeIncrement(lookup(osr_map, "module_sequence", []), osr_detect_method_map);
      }
      return true;
  };

  /**
   *  This is the main detection method. It looks for the module_sequence and
   *  executes all detection methods from the forthcoming modules.
   *
   *  For internal use only.
   *
   *  @return boolean True if the detection progress succeeded.
   */
  define OSRDetect() ``{

      integer index_modules = 0;
      
      // this list contains the sequence of detection-modules
      list module_sequence = lookup(osr_map, "module_sequence", []);
      
      if ( size(module_sequence) <= 0 )
      {
	  y2error("OSRDetect ERROR: list module_sequence is empty: %1. YaST2 OS Repair halts now!", module_sequence);

	  OSRLogFile::Add("No sequence of modules.");
	  
	  return false;
      }

      OSRLogFile::Add(sformat("Sequence of detection modules:\n%1\n", module_sequence));

      OSRLogFile::Add("Starting detection.\n");

      while (index_modules < size(module_sequence))
      {
	  string module_name    = select(module_sequence, index_modules, "");
          map    module_map     = lookup(osr_map, module_name, $[]);
	  list   detect_methods = lookup(osr_detect_method_map, module_name, []);
	  
	  // reset some values to empty before re-entry into the loop!
	  integer index_detect  = 0;
	  map     result_map    = $[];
	  string  status        = "";
	  string  severity      = "";

	  // execute all detect-functions of the specified module
	  while((index_detect >= 0) && (index_detect < size(detect_methods)))
	  {
	      // evaluate the functions and get the result_map
	      result_map      = eval(select(detect_methods, index_detect));

	      // get some information from the result_map
	      status          = lookup(result_map, "status", "");
	      severity        = lookup(result_map, "severity", "");
	      
	      if (status == "detect_ok")
	      {
		  // if no error detected go to the next detection-method
		  OSRGlobalProgress::Increase();
		  index_detect = index_detect + 1;
	      }
	      else if ((status == "detect_error") && (severity == "blocking"))
	      {
		  // if a blocking error was detected but no repair method started
		  // halt the rescue system

		  OSRGlobalProgress::Fill();
		  return false;
	      }
	      else if ((status == "detect_error") && (severity == "module_blocking"))
	      {
		  // if a module-blocking error was detected but no repair method started
		  // execute no further detection methods from the current module and jump
		  // to the next detection module

		  // adjust the value of the global progress bar
		  while (index_detect < size(detect_methods))
		  {
		      OSRGlobalProgress::Increase();
		      index_detect = index_detect + 1;
		  }
	      }
	      else if (status == "detect_error")
	      {
		  // if a "normal" error was detected but no repair method started
		  // restart the current detection method
	      }
	      else if (status == "detect_problem")
	      {
		  // if a potential problem was detected and no repair method started
		  // go to the next detection method
		  OSRGlobalProgress::Increase();
		  index_detect = index_detect + 1;
	      }
	      else if (status == "repair_ok")
	      {
		  // if all detected errors were repaired restart the current
		  // detection method
	      }
	      else if ((status == "repair_error") && (severity == "blocking"))
	      {
		  // if a blocking error was detected but the repair method failed
		  // halt the rescue system

		  OSRGlobalProgress::Fill();
		  return false;
	      }
	      else if ((status == "repair_error") && (severity == "module_blocking"))
	      {
		  // if a module-blocking error was detected but the repair method failed
		  // execute no further detection methods from the current module and jump
		  // to the next detection module

		  // adjust the value of the global progress bar
		  while (index_detect < size(detect_methods))
		  {
		      OSRGlobalProgress::Increase();
		      index_detect = index_detect + 1;
		  }
	      }
	      else if (status == "repair_error")
	      {
		  // if the repair-method was not successfull restart the current
		  // detection method
	      }
	      else if ((status == "repair_omit") && (severity == "blocking"))
	      {
		  // if a blocking error was detected but the user omitted repairing
		  // halt the rescue system

		  OSRGlobalProgress::Fill();
		  return false;
	      }
	      else if ((status == "repair_omit") && (severity == "module_blocking"))
	      {
		  // if the user omitted repairing a module-blocking error
		  // go to the next module

		  // adjust the value of the global progress bar
		  while (index_detect < size(detect_methods))
		  {
		      OSRGlobalProgress::Increase();
		      index_detect = index_detect + 1;
		  }
	      }
	      else if (status == "repair_omit")
	      {
		  // if the user omitted repairing a "normal" error go to
		  // the next detection method
		  
		  OSRGlobalProgress::Increase();
		  index_detect = index_detect + 1;
	      }
	      else if (status == "exit")
	      {
		  // if a blocking error was detected exit the rescue system, e.g. if no harddisks were detected
		  y2milestone("A blocking error was detected. YaST2 OS Repair halts now!");

		  OSRGlobalProgress::Fill();
		  return false;
	      }
	      else
	      {
		  y2error("not a valid status: %1", status);
	      }
	  }
	  // fill the module-progress-bar to 100%, if not already done
	  OSRModuleProgress::Fill();
	  
	  // go to the next module
	  index_modules = index_modules + 1;
      }

      // fill up the global-progress-bar to 100%, this can be necessary because of
      // arithmetic rounding problems
      OSRGlobalProgress::Fill();

      // enable the pushbuttons from the main window
      UI::ChangeWidget(`id(`next), `Enabled, true);
      UI::ChangeWidget(`id(`abort), `Enabled, true);
      UI::ChangeWidget(`id(`back), `Enabled, true);
      UI::SetFocus(`id(`next));
      
      return true;
  };

  ////////////////////////////////////////////////////////////////////////////////
  //
  //  provides_mode
  //
  ////////////////////////////////////////////////////////////////////////////////

  // TODO: adjust the provides-mode
  if (provides_mode)
  {
      integer index                = 0;
      map     global_provides_map  = $[];
      list    osr_module_list      = [];

      osr_module_list = SCR::Read (.target.ycp, "/usr/lib/YaST2/osr_module_list.ycp");

      // add .init to the symbols
      list temp_list = [];
      foreach(`n, osr_module_list, ``{temp_list = add(temp_list, add(n, .init));});
      osr_module_list = temp_list;

      // execute the init-functions of all modules in the module-list
      while((index >= 0) && (index < size(osr_module_list)))
      {
	  map    result_map   = $[];
	  map    provides_map = $[];
	  string module_name  = "";

          // the result of evaluation is the module_map
	  result_map     = CallFunction(select(osr_module_list, index));
	  provides_map   = lookup(result_map, "provides", $[]);

	  // add the module_map to the global osr_map
	  module_name    = lookup(result_map, "name", "");
	  osr_map        = add(osr_map, module_name, result_map);

	  // add the provides map to the global osr_map
          global_provides_map = lookup(osr_map, "global_provides", $[]);
	  global_provides_map = add(global_provides_map, module_name, provides_map);
	  osr_map             = add(osr_map, "global_provides", global_provides_map);

	  // increase the index counter
	  index = index + 1;
      }
      global_provides_map = lookup(osr_map, "global_provides", $[]);

      // save the global-provides-map to the /tmp-directory
      SCR::Write(.dumpto.tmp.osr_global_provides, global_provides_map);

      // exit the rescue system
      return;
      
  }  // end: provides_mode

  ////////////////////////////////////////////////////////////////////////////////
  //
  //  MAIN
  //
  ////////////////////////////////////////////////////////////////////////////////

  // Check the user-name, only root has access to the rescue-system.
  // If the rescue-system was started via cdrom or nfs this test is not necessary.
  if ((!demo_mode) && (!Installation::initial_mode) && (!Installation::continue_mode))
  {
      if (!OSRAmIRoot())
      {
	  UI::AnyMessagePopup(_("YaST2 OS Repair: Error"),
			      _("You have to be logged in as root in order
to start the rescue system.

YaST2 OS Repair halts now."));
	  
	  return;
      }
  }

  // open the main-window
  if (!OSROpenMainWindow())
  {
      return UI::CloseDialog();
  }

  // Start the client "inst_startup.ycp" if the rescue-system is launched from
  // a running Linux-system, else the module inst_startup.ycp was already launched.
  if (!Installation::initial_mode && !Installation::continue_mode)
  {
      OSRLogFile::Add("Calling client module inst_startup.\n");
      
      CallFunction(`inst_startup());

      // write the actual user settings for later use (e.g. CallFunction(`osr_module_lilo()) needs it)
      SCR::Write(.target.ycp, "/var/lib/YaST2/user_settings", user_settings);

      UI::ChangeWidget(`id(`next), `Enabled, true);
      UI::ChangeWidget(`id(`abort), `Enabled, true);
      UI::ChangeWidget(`id(`back), `Enabled, true);
      UI::SetFocus(`id(`next));
  }

  any user_input = nil;

  //OSRSetMainWindowContents();
  
  // the main-loop
  repeat
      {
	  UI::ChangeWidget(`id(`next), `Label, _("&Start"));

	  // Ask the user for reading an old osr_map from a previos YaST2 OS Repair-session.
	  // The map is stored in a file "osr_map.ycp" on a floppy-disk.
	  any returned_user_input = OSRReadFloppy();

	  if (returned_user_input == `back)
	  {
	      return UI::CloseDialog();
	  }
	  else if (returned_user_input == `abort)
	  {
	      return UI::CloseDialog();
	  }
	  
	  // start the init-function OSRInit() and all initial module-functions
	  if (!OSRInit())
	  {
	      return UI::CloseDialog();
	  }

	  /*
	  UI::ChangeWidget(`id(`next), `Enabled, true);
	  UI::ChangeWidget(`id(`abort), `Enabled, true);
	  UI::ChangeWidget(`id(`back), `Enabled, true);
	  UI::SetFocus(`id(`next));
	  */
	  
	  // start the detection-methods from the modules
	  if (!OSRDetect())
	  {
	      return UI::CloseDialog();
	  }
	  user_input = UI::UserInput();
      }
  until (user_input != `back);

  UI::ChangeWidget(`id(`next), `Label, _("&Finish"));
  
  // Ask the user to store the whole osr_map and the partition-tables of all detected harddisks
  // to floppy-disk for later YaST2 OS Repair-sessions.
  OSRWriteFloppy();

  //SCR::Write(.dumpto.tmp.user_settings, user_settings);
  
  if (!script_mode)
  {
      // enable the buttons
      UI::ChangeWidget(`id(`next), `Enabled, true);
      UI::ChangeWidget(`id(`abort), `Enabled, true);
      UI::ChangeWidget(`id(`back), `Enabled, true);
      UI::SetFocus(`id(`next));
  
      // wait for user input
      //any user_input = nil;

      if (automatic_mode)
      {
	  user_input = `next;
      }
      
      while((user_input != `next) && (user_input != `back) && (user_input != `abort))
      {
	  user_input = UI::UserInput();
      }

      // show the contents of the log file
      //ShowFilePopup(_("YaST2 OS Repair - Log file"), OSRLogFile::GetFile());
      
      if ((user_input == `next) || (user_input == `abort))
      {
	  UI::CloseDialog();
      }
      
      return user_input;
  }
  else
  {
      return `next;
  }
}
