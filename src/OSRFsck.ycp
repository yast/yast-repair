/**
 *  File:
 *    OSRFsck.ycp
 *
 *  Module:
 *    YaST OS Repair. Automatic error detection & repair tool for Linux.
 *
 *  Summary:
 *    YaST OS Repair. Automatic error detection & repair tool for Linux.
 *
 *  Author:
 *    Johannes Buchhold <jbuch@suse.de>
 *
 * $Id$
 */
{
  module "OSRFsck";

  import "FileSystems";
  import "Storage";
  import "Partitions";
  import "Mode";
  
  import "OSRExecute";
  import "OSRLogFile";
  import "OSRModuleLoading";
  import "OSRPopup";


  import "Popup";

  textdomain "repair";
  
  /**
   * The last return value from a check_... call
   */ 
  integer last_check_return = 0;

  /**
   * Options for a repair call. Not Supported at the moment.
   */
  string  fsck_options      = "";

  /**
   * The not loaded filesystem an lvm/raid modules.
   */
  global list(string) not_installed_modules = [];

  /**
   * The loaded modules.
   */
  global list(string) fs_kernel_modules     = [];

  /**
   * A list of all possible filesystem id's for fsck... 
   */
  global list(integer) fsck_fsid 	    = [];

  /**
   * A list of all possible types for a fsck ...	
   */
  global list(symbol) fsck_type		    = [ `sw_raid, `lvm, `logical, `primary ];
  
  /**
   * The partition name witch is currently in work ( checked - repaired)
   */
  string check_partition = "";

  /**
   * The find/check/repair define for all supported filesystems.
   */
  map fsck_map = $[
		   `ext2 :	$[
                   "find"	: ``(is_ext2fs()),
				   "repair"	: ``(repair_ext2fs()),
				   "check"	: ``(check_ext2fs()) ],
		   `ext3 :  $[
                   "find"	: ``(is_ext2fs()),
				   "repair"	: ``(repair_ext2fs()),
				   "check"	: ``(check_ext2fs()) ],
		   `reiser: $[
				   "find"	: ``(is_reiserfs()),
				   "repair"	: ``(repair_reiserfs()),
				   "check"	: ``(check_reiserfs()) ],
		   `xfs	:	$[
				  "find"	: ``(is_xfs()	),
				  "repair"	: ``(repair_xfs()),
				  "check"	: ``(check_xfs()) ],
		   `jfs :	$[
				  "find"	: ``(is_jfs()),
				  "repair"	: ``(repair_jfs()),
				  "check"	: ``(check_jfs())],
		    // "Do not touch non-linux partitions" (#25002)
		    // -> no check/repair functions for other filesystems
		   `fat16 :	$[
				  "find"	: ``(is_fat()) ],
		   `fat32 :	$[
				  "find"	: ``(is_fat()) ],
		    `ntfs :	$[
				    "find"	: ``(is_ntfs()) ]
  ];


  string file_name = "";

  global define void Reset()``{ 
      file_name 		= "";
      last_check_return 	= 0;
      fsck_options      	= "";
      not_installed_modules 	= [];
      fs_kernel_modules     	= [];
      check_partition 		= "";
 
  }
  
  /**
   * Fill the list fsck_fsid with the date from module Partition.
   */
  global define OSRFsck()``{

      fsck_fsid = union( Partitions::fsid_wintypes, Partitions::fsid_dostypes );
      fsck_fsid = union( fsck_fsid, Partitions::fsid_ntfstypes );
      fsck_fsid = union( fsck_fsid, [Partitions::fsid_native ]);
  }


  /**
   * Load all needed fileystem and lvm/raid modules.
   */
  global define boolean LoadAllFsModules()``{

      if( Mode::test )  return true;
      
      not_installed_modules = [];
      fs_kernel_modules     = [];
      
      list(symbol) all_supportet_fs    	= maplist(symbol fs, map details, FileSystems::GetAllFileSystems(false, false ), ``(fs) );
      
      foreach(symbol fs, all_supportet_fs , ``{
	  fs_kernel_modules = union(fs_kernel_modules, FileSystems::GetNeededModules(fs ));
      });
      
      fs_kernel_modules = union(fs_kernel_modules , [ "xor", "raid0", "raid1", "raid5", "lvm-mod"]);

      
      // iterate all listed kernel modules
      foreach(string fs_module, fs_kernel_modules, ``{
	  if (! OSRModuleLoading::Load( fs_module, "","","",false, true))
	      not_installed_modules = add( not_installed_modules, fs_module );
      });

      return size( not_installed_modules ) == 0;
  }




  /**
   * Return a list witch contains all partitions names that can be
   * used for a fsck.
   */
  global define list(map) PossiblePartitions()``{
      if ( Mode::test ) return ["/dev/hda1", "/dev/hda2"];

      list(map) partitions =	[];

      foreach(string dev, map target, Storage::GetTargetMap(), ``{

	  foreach(map p, target["partitions"]:[],``{

	      if( p["delete"]:false == false &&
		  ( contains ( fsck_fsid, p["fsid"]:0 ) &&
 		    contains ( fsck_type, p["type"]:`unknown ) ) )
	      {
		  p["maindev"] = dev;
		  partitions = add(partitions, p );
	      }
	  });
      });

      y2milestone("all partitions %1", partitions);
     
      return partitions;
  }


/**
  * Test the filesystem of one partition.
  * @param the partition map
  *
  */
global define boolean Check(map part ) ``{
    if(Mode::test ) return true;

    symbol used_fs = part["detected_fs"]:`unknown;
    check_partition = Storage::GetDeviceName(part["maindev"]:"", part["nr"]:0);

    y2milestone("Check the file system of the partition %1", check_partition );
    // find fs
    if ( ! eval( lookup( fsck_map[used_fs]:$[], "find", ``(is_unknown()) )) )
    {
	y2error("used_fs is not ok. Searching for new filesystem");

	used_fs            = `unknown;
	symbol new_used_fs = `unknown;

	foreach(symbol fs, map fs_map, fsck_map, ``{
	    if ( fs != used_fs ) {
		if( eval( fs_map["find"]:``{ return false; }))
		{
		    new_used_fs = fs;
		}
	    }
	});
	if ( new_used_fs != `unknown )
	    used_fs = new_used_fs;
	else
	{
	    y2error(" no file systen found for %1", check_partition );
	}
    }
    else
    {
	y2milestone("used_fs is ok. Executing file system check !!");
    }
    Storage::SetSubDevParam (
	Storage::GetSubDevKey (part["maindev"]:"", part["nr"]:0 ),
	"detected_fs", used_fs );

    if ( used_fs != `unknown && used_fs != nil )
    {
	// ----------- start check now
//	if (!haskey (fsck_map[used_fs]:$[], "check"))
	if (IsNonLinuxFileSystem (used_fs))
	{
	    y2milestone("non-linux filesystem: no checks");
	    return true;
	}
	if( eval (fsck_map[used_fs, "check"]:``{ return false;}))
	{
	    y2milestone("file system check successful executed");
	    return true;
	}
    }
    else
    {
	y2milestone("no file system found");
	return nil;
    }
    y2error("file system check was not successful");
    return false;
  }


  define boolean is_unknown()``{
      y2error("unkonwn file system");
      return false;
  }

  /**
   *  Checks if the specified check_partition is of filesystem-type ext2fs.
   *  @return boolean True if the check_partition is ext2fs.
   */
  define boolean is_ext2fs() ``{

      boolean is_ext2fs =  OSRExecute::Command(.local.bash, "/sbin/dumpe2fs -h " + check_partition );
      
      if (is_ext2fs )
      {
	  y2milestone("partition %1 is ext2fs", check_partition);
      }
      else 
      {
	  y2milestone("partition %1 is NOT ext2fs", check_partition);
      }

      return is_ext2fs;
  };

  
  /**
   *  Checks if the specified partition is of filesystem-type reiserfs.
   *  @return boolean True if the partition is reiserfs.
   */
  define boolean is_reiserfs() ``{

      boolean is_reiserfs = OSRExecute::Command(.local.bash, "/sbin/debugreiserfs " + check_partition);
      
      if ( is_reiserfs )
      {
	  y2milestone("partition %1 is reiserfs", check_partition);
      }
      else
      {
	  y2milestone("partition %1 is NOT reiserfs", check_partition);
      }
      
      return is_reiserfs;
  };


  /**
   *  Checks if the specified partition is of filesystem-type xfs.
   *  @return boolean True if the partition is xfs.
   */
  define boolean is_xfs()``{

      boolean is_xfs = OSRExecute::CommandOutput(.local.bash, "/usr/sbin/xfs_admin -l -u " + check_partition);
      // failed
      //xfs_admin: unexpected XFS SB magic number 0xdd0a05a6
      //bad sb magic # 0xdd0a05a6 in AG 0
      //failed to read label in AG 0
      //bad sb magic # 0xdd0a05a6 in AG 0
      //failed to read UUID from AG 0

      // success
      //label = ""
      //uuid = ad743076-12b8-452b-86c0-2e62918479ae  
      if ( issubstring(OSRExecute::stdout, "label") &&
	   issubstring(OSRExecute::stdout, "uuid" ) )
      {
	  y2milestone("partition %1 is xfs", check_partition);
	  is_xfs = true;
      }
      else
      {
	  y2milestone("partition %1 is NOT xfs", check_partition);
	  is_xfs = false;
      }

      return is_xfs;
      
  };



  /**
   *  Checks if the specified partition is of filesystem-type jfs.
   *  @return boolean True if the partition is jfs.
   */
  define boolean is_jfs()``{

      string command  =  sformat("if /usr/bin/test -f %1; then /bin/rm %1; fi", OSRLogFile::GetTmpDir() +"/jfslog.dmp" );

      // delete the old progress_file, if it exists
      if (  WFM::Execute(.local.bash, command) != 0 )
	  y2error("The file %1 could not be deleted.", OSRLogFile::GetTmpDir() +"/jfslog.dmp" );

      
      string  command        	= sformat("cd %1; /sbin/jfs_logdump %2", OSRLogFile::GetTmpDir(), check_partition );
      boolean is_jfs 		= OSRExecute::CommandOutput(.local.bash, command );

      // check_jfs is 0 !! -> read jfslog.dmp
      string jfslog 		= WFM::Read(.local.string, OSRLogFile::GetTmpDir()+"/jfslog.dmp" );

      y2milestone("jfslog.dmp %1", jfslog);
      
      if ( issubstring( jfslog, "?????????????????" ))
      {
	  is_jfs = false;
      }

      return is_jfs;
  };


  
  /**
   *  Checks if the specified partition is of filesystem-type fat/vfat.
   *  @return boolean True if the partition is fat/vfat.
   */
  define boolean is_fat()``{
      string  command   = sformat("/bin/guessfstype %1", check_partition );
      boolean is_fat	= OSRExecute::CommandOutput(.local.bash, command );

      if ( issubstring( OSRExecute::stdout, "fat" ))
      {
	  is_fat = true;
      }
      else {
	  is_fat = false;
      }

      return is_fat;
  };

  /**
   *  Checks if the specified partition is of filesystem-type ntfs
   *  @return boolean True if the partition is ntfs
   */
  define boolean is_ntfs()  ``{
      string  command   = sformat("/bin/guessfstype %1", check_partition );
      boolean is_ntfs	= false;
      OSRExecute::CommandOutput(.local.bash, command );

      if ( issubstring( OSRExecute::stdout, "ntfs" ))
	    is_ntfs = true;

      return is_ntfs;
  };
  

  
  /**
   *  Checks the specified partition for consistency with "/sbin/e2fsck".
   *  @return boolean 
   *      The exit code returned by e2fsck is the sum of the following conditions:
   *      0 - No errors,
   *      1 - File system errors corrected,
   *      2 - File system errors corrected, system should be rebooted if file system was mounted,
   *      4 - File system errors left uncorrected,
   *      8 - Operational error,
   *      16 - Usage or syntax error,
   *      128 - Shared library error.
   */
  define boolean check_ext2fs() ``{

      string command	   = sformat("/sbin/fsck.ext2 -n -f %1", check_partition );
      boolean check_ext2fs = OSRExecute::Command(.local.bash,command);
      last_check_return    = OSRExecute::result;

      if (check_ext2fs  )
      {
	  y2milestone("partition %1 is o.k., /sbin/e2fsck reports no errors", check_partition);
      }
      else
      {
	  y2error("/sbin/e2fsck reports an error: %1, command line: %2", check_ext2fs, command);
      }

      return check_ext2fs;
  };

  /**
   *  Checks the specified partition for consistency with "/sbin/reiserfsck".
   */
  define boolean check_reiserfs() ``{

    string command = sformat("/bin/echo Yes | /sbin/reiserfsck --check %1",
	check_partition);

    // don't use OSRExecute .. because OSRExecute use .target.bash_output and
    // this break the whole Yast2 -> output is to much !! e.g. 14 MB
    last_check_return      = WFM::Execute(.local.bash, command );
    boolean check_reiserfs = last_check_return == 0 ;

    if (check_reiserfs )
    {
	y2milestone("partition %1 is o.k., /sbin/reiserfsck reports no errors",
	    check_partition);
    }
    else
    {
	y2error("/sbin/reiserfsck reports an error: %1, command line: %2",
	    check_reiserfs, command);
    }
    return check_reiserfs;
  };

    
  /**
   * Checks the specified partition for consistency with "/sbin/xfs_db -c check".
   */
  define boolean check_xfs()``{
      string  command        	= sformat("/usr/sbin/xfs_db -c check %1", check_partition );
      boolean check_xfs 	= OSRExecute::Command(.local.bash, command);
      last_check_return         = OSRExecute::result;
      
      if (check_xfs )
      {
	  y2milestone("partition %1 is o.k., xfs_check reports no errors", check_partition);
      }
      else 
      {
	  y2milestone("xfs_check reports an error for partition %1", check_partition );
      }

      return check_xfs;
  };

  
  /**
   * Checks the specified partition for consistency with "/sbin/fsck.jfs -n ".
   */
  define boolean check_jfs()``{
      string  command        	= sformat("/sbin/fsck.jfs -n %1", check_partition );
      boolean check_jfs 	= OSRExecute::Command(.local.bash, command);
      last_check_return         = OSRExecute::result;
            
      if (check_jfs )
      {
	  y2milestone("partition %1 is o.k., jfs_check reports no errors", check_partition);
      }
      else 
      {
	  y2milestone("jfs_check reports an error for partition %1", check_partition );
      }

      return check_jfs;
  };

  /**
   * The main repair dialog.
   * @param t_check_partition the partition e.g.: /dev/hda1
   * @param used_fs the filesystem symbol
   * @return `ok,`error,`cancel
   */
  global define symbol Repair(string t_check_partition, symbol used_fs ) ``{

      // not used at the moment.
      fsck_options   = "";

      file_name      = OSRLogFile::GetTmpDir()+ "/" + "fsck_repair";

      // makes global use possible ( from another define as Check);
      check_partition = t_check_partition;

      // error message, %1 is filesystem type, %2 partition
      string error_message = sformat(_("
The %1 file system of the partition %2 is corrupted.
To repair the file system, press \"Repair\".

Press \"Skip\" to avoid repairing.
"), FileSystems::GetName( used_fs, "unkonwn"), check_partition );

      // error message
      string help_text         = _("
<p>An inconsistent file system occurs when
a partition is not correctly unmounted.
This could happen during the system crash.</p>
") +

      // error message
_("<p>There is a repair method for each file
system. For example, if the file system
of the damaged partition is ext2 or
ext3, use fsck.ext2 (e2fsck) with the
corresponding options to repair the
file system. The following lines list
the repair tools of the different Linux
file systems.</p>
") +

_("<p><pre>
ext2 and ext2: fsck.ext2 or e2fsck
reiserfs:      reiserfsck
jfs:           fsck.jfs
xfs:           xfs_repair
msdos (fat):   fsck.msdos</pre></p>") +

_("<p>If you know what kind of file system
you have and how to use the corresponding
tool, close YaST and repair the
damaged file system on your own. Otherwise,
close this help dialog and press the
\"Repair\" button for automatic repair.</p>
");

      while( true )
      {
	  if (! OSRPopup::Repair(_("Error detected."), error_message, help_text) ) return `cancel;

	  UI::OpenDialog(`VBox(`VSpacing(1),
			       `Label(_("Repairing file system. Please wait...")),
			       `VSpacing(1)));

	  // if file exist
	  if( WFM::Execute(.local.bash, "/usr/bin/test -f " + file_name ) == 0 )
	  {
	      WFM::Execute(.local.bash, "/bin/rm %1", file_name );
	  }
	  
	  boolean ret = true;
	  if( ! Mode::test )
	  {
	      ret = eval( fsck_map[used_fs, "repair"]:``{ return false;});
	  }
	  
	  UI::CloseDialog();
	
	  string headline = "";
	  
	  if ( ret ) {
	      headline = sformat(_("
Repairing %1 file system of
partition %2 was successful."),
				 FileSystems::GetName(used_fs, "unkonwn"),
				 check_partition );
	  }
	  else {
	      headline = sformat(_("
Repairing %1 file system of partition
%2 was not successful."),
				 FileSystems::GetName(used_fs, "unkonwn"),
				 check_partition );
	  }

	  // if file exist
	  if( WFM::Execute(.local.bash, "/usr/bin/test -f " + file_name ) == 0 )
	  {
	      Popup::ShowFile( headline, file_name);
	  }

	  if ( ret ) return `ok;
	  
      }
  }

  /**
   * Repair ext2/ext3 filesystem.
   * The exit code returned by e2fsck is the sum of the following conditions:
   *      0 - No errors,
   *      1 - File system errors corrected,
   *      2 - File system errors corrected, system should be rebooted if file system was mounted,
   *      4 - File system errors left uncorrected,
   *      8 - Operational error,
   *      16 - Usage or syntax error,
   *      128 - Shared library error.
   */
  define boolean repair_ext2fs()``{

      if(  last_check_return == 4 ) {

	  y2milestone("repair ext2/ext3 filesystem on partition %1", check_partition);

	  string command = sformat("/sbin/fsck.ext2 -p -f %1 %2", fsck_options, check_partition );
	  boolean repair_ext2fs = OSRExecute::CommandProgress(.local.bash,command ,file_name);

	  // TODO what is if fsck.ext2 requires y y y y for del indo XX ...
	  
	  if ( OSRExecute::result == 0 ||
	       OSRExecute::result == 1 ||
	       OSRExecute::result == 2 ) {
	      return true;
	  }
	  
      }
   
      y2milestone("ext2 filesystem not successful repaired.");
      return false;
  }
		   

  /**
   * Repair reiserfs filesystem.
   */
  define boolean repair_reiserfs()``{
      
      string command 		= "";
      integer repair_reiserfs   = 0;
      
      if ( last_check_return == 1 ) {
	  command 	    = sformat("/bin/echo Yes | /sbin/reiserfsck --fix-fixable %1", check_partition);
	  repair_reiserfs   = WFM::Execute(.local.bash,command, file_name );
      }
      else if ( last_check_return == 2 ) {
	  
	  if ( Popup::YesNoHeadline(_("Reiserfs Fatal Corruptions"), _("
Checking the file system (reiserfs) reports
fatal corruptions. Only a rebuild of the reiserfs
file system tree (reiserfsck --rebuild-tree)
could solve the problem.

To rebuild your reiserfs tree,
press \"Yes\". Otherwise press
\"No\" and repair the file system manually.
")))
	  {
	      command 	        = sformat("/bin/echo Yes | /sbin/reiserfsck --rebuild-tree %1", check_partition);
	      repair_reiserfs   = WFM::Execute(.local.bash,command , file_name);
	  }
	  else {
	      return false;
	  }
      }
      
      if ( repair_reiserfs == 0 || 
	   repair_reiserfs == 1 ||
	   repair_reiserfs == 2   ) {
	  return true;
      }
      
      return false;
  }

  /**
   * Repair xfs filesystem.
   */
  define boolean repair_xfs()``{
      string command 		= sformat("/sbin/xfs_repair %1", check_partition);
      return  OSRExecute::CommandProgress(.local.bash,command , file_name);
  }

  /**
   * Repair jfs filesystem.
   */
  define boolean repair_jfs()``{
      string command 		= sformat("/sbin/fsck.jfs -p %1", check_partition);
      boolean repair_jfs 	= OSRExecute::CommandProgress(.local.bash,command , file_name);

      if ( OSRExecute::result == 0 ||
	   OSRExecute::result == 1 ||
	   OSRExecute::result == 2 ) {
	  return true;
      }
      y2milestone("not ext2 filesystem repaired successful.");
      return false;

  }

/**
 * checks for filesystem type
 * (Repair module should not touch non-linux partitions - bug #25002)
 */
global define boolean IsNonLinuxFileSystem (symbol fs) ``{

    return contains ([`ntfs, `fat16, `fat32], fs);

}


}
