/**
 * File:	OSRPkg.ycp
 * Module:	repair
 * Summary:	Packages check
 * Authors:	Johannes Buchhold <jbuch@suse.de>
 *
 * $Id$
 *
 * Provide osr mode information.
 */

{
  
    module "OSRPkg";

    
    include "ui/common_popups.ycp";
    
    textdomain "repair";

    import "Kernel";
    import "PackageCallbacks";

    import "OSRSystem";
    import "OSRExecute";
    import "OSRLogFile";
    import "OSRPkgUI";
    import "OSRPopup";
    import "OSRPkgVerify";

    
    /**
     * Package database files
     */
    list(string) rpm_db_files = [	 
				 "/var/lib/rpm/conflictsindex.rpm",
				 "/var/lib/rpm/fileindex.rpm",
				 "/var/lib/rpm/groupindex.rpm",
				 "/var/lib/rpm/nameindex.rpm",
				 "/var/lib/rpm/packages.rpm",
				 "/var/lib/rpm/providesindex.rpm",
				 "/var/lib/rpm/requiredby.rpm",
				 "/var/lib/rpm/triggerindex.rpm"
    ];
    
    /**
     * if a backup (YaST) of the package  database was
     * created.
     * Save rpm_db_files[X] -> rpm_db_files[X].old
     */
    boolean backup_created = false;
    
    /**
     * Mount point where the target system is mounted.
     */
    global string root_mountpoint = "";

    /**
     * Help text to show errors.
     */
    global string help_text	   = "";

    /**
     * Error text. 
     */
    global string error_text	   = "";

    /**
     * Dialog description for the install missing or damaged packages.
     */
    global list install_missing_dialog_data = [];
 
    /**
     * Missing packages database files.
     */
    global list (string) not_found_files  = [];

    /**
     * Not installed base packages or damaged packages.
     */
    global list (string) missing_packages = [];

    /**
     * All new installed packages.
     */
    list (string) reinstalled_packages    = [];
    
    /**
     * This will be local when converted to a Module::
     * Has Pkg::TargetInit run?
     */
    boolean target_initialized = false;

    /**
     * This will be local when converted to a Module::
     * Has Pkg::SourceStartCache run?
     */
    boolean source_initialized = false;

    boolean package_db_repaired = false;


    list(string) architecture_packages = [];
    
    string default_package_help  = _("
<p>The package database administrate all
information of the installed software packages.
The most common way to add a new program or library
to a linux system is to install a new package.
In doing so the install routine copy all files of the
package to the target and register the package in
the package database.</P>");

    string damaged_package_help = _("
<P>If the package database is damaged installing
and reovering packages ore updating the system
is not possible.</P>");


    /**
     * Reset the module settings.
     */
    global define void Reset()``{

	not_found_files  	= [];
	error_text		= "";
	help_text		= "";
	root_mountpoint		= "";
	missing_packages 	= [];

	architecture_packages = [];
	package_db_repaired = false;
	reinstalled_packages    = [];
	install_missing_dialog_data = [];

	
	if( target_initialized )
	{
	    target_initialized = ! Pkg::TargetFinish ();
	}
	// don't reset source_initialized
	// don't reset reinstalled_packages
	OSRPkgUI::Reset();
	OSRPkgVerify::Reset();
    }
    
    /**
     * Constructor.
     */
    global define OSRPkg()``{
	Reset();
    }
        
    /**
     * Open the package database.
     */
    global define boolean OpenPkg( string root )``{

	y2milestone("Open pkg database with target system  -%1-", root );
	if( root != "" && root != nil ) root_mountpoint = root;

	// open the package source 
	if( ! Mode::initial )
	{
	    source_initialized = source_initialized || Pkg::SourceStartCache (true) != [];
	}
	else 
	{
	    if ( ! source_initialized  )
	    {
		y2milestone("Calling package module");

		//change root for the Package module call
		OSRSystem::SetOrgRoot();

		import "Packages";
		Packages::Init( true );

		architecture_packages = Packages::ComputeSystemPackageList();
		y2milestone("Add architecture packages %1", architecture_packages );
	
			
		//reset root environment
		OSRSystem::ChangeRoot(root);

		source_initialized = true;
	    }
	}

	// open target system for Pkg access
	target_initialized = target_initialized || Pkg::TargetInit ( root, false);

	// something failed
	if( ! target_initialized || ! source_initialized )
	{
	    y2error("Opening the package database failed. ");
	    y2error("Target is initialised: %1", target_initialized);
	    y2error("Source is initialised: %1", source_initialized);

	    // build help and error text for following repair dialog
	    help_text  = default_package_help + damaged_package_help;
	    error_text = _("
YaST can not open the package database.
Please try to rebuild the package
database or revert a backup.
");
	}
	return target_initialized && source_initialized;
    }
    
    
    /**
     * Return false if db files are missing.
     * Save missing files in the list not_found_files.
     */
    global define boolean CheckDB(string root )``{
	if( root != "" && root != nil ) root_mountpoint = root;
	
	not_found_files = [];

	// check all database files
	foreach(string file, rpm_db_files, ``{
	    if ( ! OSRExecute::Command(.local.bash, sformat("/usr/bin/test -f %1", root_mountpoint + file)))
	    {
		not_found_files = add(not_found_files, file);
	    }
	});

	// if files are missing
	if( size( not_found_files ) > 0 )
	{
	    help_text  = default_package_help + damaged_package_help;
	    
	    error_text = sformat(_("
YaST checked the package database and
did not find the following files
which belongs to the package database.

%1"),mergestring(not_found_files,"\n"));

	}
	else
	{ 
	    // try to open the database.
	    // if open fails OpenPkg set help and error text
	    return OpenPkg( root_mountpoint );
	}
	
	return size( not_found_files ) == 0;
    }

    
    /**
     * Make a backup of the package database
     * files.
     */
    define boolean backup_package_db()``{

	// only create one package at the
	// first call of backup_package_db
	if( backup_created ) return true;

	list(boolean) ret = [];
	
	foreach(string file, rpm_db_files, ``{
	    string f = root_mountpoint  + file;
	    if( ! contains( not_found_files , file))
	    {
		ret = add( ret , OSRExecute::Command(.local.bash, sformat("/bin/cp %1 %1.old",f)));
	    }
	});

	// if not error was found
	if( size(filter(boolean r, ret, ``( r != true ))) == 0 )
	{
	    backup_created = true;
	}
	return backup_created;
    }

    /**
     * Revert the YaST backup of the package database.
     */
    define boolean revert_packages_backup()``{
	if ( ! backup_created ) return false;
	
	list(boolean) ret = [];
	foreach(string file, rpm_db_files, ``{
	    string f = root_mountpoint  + file;

	    //if orginal file exists
	    if( ! contains( not_found_files , file))
	    {
		ret = add( ret , OSRExecute::Command(.local.bash, sformat("/bin/cp %1.old %1",f)));
	    }
	});

	// if not error was occurred
	if( size(filter(boolean r, ret, ``( r != true ))) == 0 )
	{
	    Report::Message(_("
Reverting the backup was successful.
"));
	    return true;
	}
	else
	{
	    Report::Error(_("
Reverting the backup was not
successful. Please select a
another backup or try to
rebuild the package database.
")); 
	    return false;
	}
    };



    /**
     * Rebuild the package database.
     */
    define boolean rebuild_package_db( boolean show_message )``{
	boolean ret = true;


	UI::OpenDialog(`VBox(`VSpacing(1),
			   `Label(_("Rebuilding the package database. Please wait ...")),
			   `VSpacing(1)));
	
	if( backup_created || size(not_found_files ) > 0 )
	{
	    // some package database files are missing
	    if( (! Mode::test)  && size( not_found_files ) > 0 )
	    {
		ret = WFM::Execute(.local.bash, sformat("/bin/rpm --root %1 --initdb",root_mountpoint)) == 0;
	    }

	    // rebuild package database
	    ret = ret &&  WFM::Execute(.local.bash, sformat("/bin/rpm --root %1 --rebuilddb" ,root_mountpoint)) == 0;

	    package_db_repaired = true;

	    UI::CloseDialog();
	    if( show_message )
	    {
		if( ret )
		{
		    Report::Message(_("
YaST rebuild the package database
successful.
"));
		}
		else
		{
		    Report::Error(_("
YaST could not rebuild the package
database. Please revert a backup of
the packagedatabase.
"));
		}
	    }
	}
	else {
	    UI::CloseDialog();
	    ret = false;
	}
	
	return ret;
    }


    /**
     * Revert a backup of the package database
     * from /var/adm/backup/rpmdb.
     */
    define boolean revert_daily_backup()``{

	boolean ret = false;
	if( ! backup_created && size(not_found_files) == 0 ) return false;
	
	string backup_path = SCR::Read(.sysconfig.backup.RPMDB_BACKUP_DIR );
	string file_path   = "packages.rpm";
	if ( backup_path == "" || backup_path == nil )
	{
	    y2error("No sysconfig backup path found. Use default /var/adm/backup/rpmdb");
	    backup_path = "/var/adm/backup/rpmdb";
	}

	list(string) files = SCR::Read(.target.dir, backup_path );
	files = filter(string f, files, ``(substring(f, 0, size(file_path)) == file_path ));
	y2milestone("Found files for backup: %1", files );

	//packages.rpm-20021105.gz
	list(string) dates = maplist(string f, files, ``(substring(f, size(file_path)+1 , 8)));
	dates 	   = sort(string f, string ff, dates, ``( f >= ff ));
	dates      = maplist(string f, dates, ``(sformat("%1.%2.%3", substring( f,0,4),
							 substring(f,4,2),
							 substring(f,6,2))));
	list(list) items = maplist(string f, dates, ``([f,""]));

	// no backup was found
	if( size(items ) == 0 )
	{
	    Report::Error(sformat(_("
YaST could not find any package database
backup files. Normally a cron job creates
daily backups of the package database and
store the backups in the directory
%1. But YaST found not
backup files in this directory. Please
try a other repair method."),backup_path));
	    return false;
	}
	
	
	string selected  = OSRPopup::RadioButtonGroupText(_("Please select one backup time:"),
						   _("
YaST has found several backups
of the package database at the
system. 
Please select the date (YYYY/MM/DD)
of the backup which should reverted.
"), items, dates[0]:"", "", false);

	y2milestone("The selected item %1", selected);

	if(selected != "" )
	{
	    selected = find(string f, files, ``(issubstring(f, mergestring(splitstring(selected, "."),"") )));
	    selected = backup_path + "/"+selected;
	    if( OSRExecute::Command(.local.bash, sformat("/usr/bin/test -f %2/%1", selected, root_mountpoint )))
	    {
		if( ! Mode::test && WFM::Execute(.local.bash, sformat("/bin/gunzip < %2/%1  \
> %2/var/lib/rpm/packages.rpm", selected ,root_mountpoint )) == 0   )
		{
		    if ( rebuild_package_db(false) ) 
		    {
			Report::Message(_("
Reverting the backup of the package
database was successful.
"));
			ret = true;
		    }
		}
		else
		{
		    Report::Error(_("
Reverting the backup of the package
database was not successful.
"));
		}
		package_db_repaired = true;
	    }
	    else
	    {
		//should never happpen
		y2error("Selected package update file not found");
	    }
	}
	return ret;
    }

    
    /**
     * Repair or initialise a damaged package
     * damaged. Call CheckDB before.
     */
    global define symbol RepairDB()``{

	string repair_header = _("Repair package database");
	
	if ( ! backup_package_db())
	{
	    y2error("Creating backup of package db was not successful");
	    if ( size(not_found_files ) == 0 ) return `error;
	    
	}

	term r_options = `VBox(`Left(`Label(_("Please select one repair method or skip repairing?"))),
			       `VSpacing(0.5),
			       `Left(`RadioButton(`id(`rebuild ),  _("Rebuild package database") ,true )),
			       `Left(`RadioButton(`id(`daily    ), _("Revert daily backup"), false))
			       );
	
	term last_entry = `RadioButton(`id(`revert ));

	if ( ! package_db_repaired )
	    last_entry = add( last_entry , `opt(`disabled ));
	
	last_entry = add( last_entry,  _("Revert orginal package database (saved by YaST)"));
	last_entry = add( last_entry, false);
	r_options  = add( r_options, last_entry);

	
	if ( ! OSRPopup::OpenMainRepairDialog( repair_header , error_text, r_options ))
	{
	    y2error("Could not open main dialog for repairing package database.");
	    return `error;
	}   

	symbol ret     = `ok;
	repeat {
	    ret             = UI::UserInput();
	    symbol selected = UI::QueryWidget(`id(`rb), `CurrentButton);
	
	    if( ret == `help )
	    {
		UI::LongTextPopup( OSRPopup::help_headline , `RichText( help_text ), 50, 20);
	    }
	    else if ( ret == `ok )
	    {
		UI::CloseDialog();

		boolean rret = false;
		//execute selected repair mehtod 	
		if(       selected == `rebuild ) rret = rebuild_package_db(true);
		else if ( selected == `daily   ) rret = revert_daily_backup();
		else if ( selected == `revert  ) rret = revert_packages_backup();
	      
		if ( ! rret  )
		{
		    if ( ! OSRPopup::OpenMainRepairDialog(repair_header , error_text, r_options ))
		    {
			y2error("Could not open main dialog");
			return `error;
		    }
		    ret = `again;
		}
	    }
	} until( ret == `cancel || ret == `abort || ret == `ok );	      
    
	if( ret != `ok )  UI::CloseDialog();

	return ret;
    }


    /**
     * Check if all minimal required packages are installed.
     */
    global define boolean CheckMinimum(string root )``{

	// reset missing package
	missing_packages = [];

	if( root != "" && root != nil ) root_mountpoint = root;

	if (! OpenPkg( root_mountpoint ))
	{
	    y2error("Opening the package database failed. Checking minimal package selection is not possible.");
	    y2error("Please call CheckDB before calling CheckMinimum");
	    return false;
	}

	
	list(string) installed_packages = Pkg::GetPackages(`installed, true);
	list(string) minimal_packages   = get_verify_packages( "base" );

	missing_packages = filter(string pkg_name, minimal_packages, ``( ! contains(installed_packages, pkg_name )));

	// fix Pkg bug. GetPackages get not the reinstalled_packages!!
	missing_packages = filter(string pkg_name, missing_packages, ``( ! contains( reinstalled_packages, pkg_name)));
	
	boolean ret      = size(missing_packages) == 0;

	if (! ret )
	{
	    y2error("Not found packages that belong to the minimal selection: %1" ,missing_packages );
	    // set information for repair dialog
	    install_missing_dialog_data = [
					   _("Missing packages"),
					   _("
YaST checked the package selection of
the system. The following packages are
not installed."),

					   _("
The listed packages belong to the minimal
package selection. YaST propose to
install these packages. Please press
\"Repair \" to install all selected 
packages in the list.
"),
					     _("
<P>SuSE linux needs at least some packages for
the basic system functionality. Without these
packages the system is not executable.</P>") +

_("<P>YaST checks if all for a minimal installation
required software packages are installed. If
some packages are missing YaST propose to
install the missing packages.</P>
"),
					   _("Missing packages to install:"),
					   []
	    ];
	}
	return ret;

    };

    
    /**
     * Return all packages which should be verified 
     */
    define list(string) get_verify_packages(string what ) ``{

	list(string)  ret = [];
	
	// return all packages
	if(what == "all" )
	{
	    ret = Pkg::GetPackages(`installed, true);
	}
	// return base packages only
	else if ( what == "base")
	{
	    // check how to get base packages
	    // TODO replace osr_minimal.ycp with a method which get the minimal selection
	    // from the Pkg interface.  
	   
	    list(string) minimal = CallFunction(`osr_minimal());  
	    list(string) special = [];
	    
            //Packages::ComputeSystemPackageList();
	  
	    ret = union( minimal, special) ;
	    
	}
	else {
	    y2error("Parameter what not valid. Only all or base are allowed.");
	    ret =  nil;
	}

	
	if (ret != nil )
	{
	    ret = union( ret , architecture_packages );
	}
	
	return ret;
    }
    
    /**
     * Verify all specified packages.
     * @param root The mount point where the target system is mounted.
     * @param what "all" or "base" packages
     * @param expert_mode Show the verify protocol too
     * @param reset Clear missing_packages before start verifying.
     */
    global define symbol VerifyPackages(string root, string what , boolean expert_mode, boolean reset )``{
	
	if( root != "" && root != nil )
	{
	    root_mountpoint = root;
	}

	if( reset )
	{
	    missing_packages = [];
	}

	// open package database
	if( ! OpenPkg(root_mountpoint) )
	{
	    y2error("Opening the package database failed. Verify package not possible");
	    return `error;
	}

	list(string) check_packages = toset(get_verify_packages(what));

	
	if( check_packages == nil ||  size(check_packages) == 0 )
	{
	    y2error("No packages to verify found. Stop verify and return error.");
	    return `error;
	}

	string headline = ( what != "all" ) ? _("Verifying base packages") : _("Verifying all installed packages");
	
	// open dialog
	if ( ! OSRPkgUI::OpenVerifyDialog( size(check_packages), headline , expert_mode) )
	{
	    y2error("Verify Dialog can not be opened");
	    return `error;
	}

	symbol ret  = `again;
	string rret = "";
	repeat {
	    // verify all selected packages
	    foreach(string p, check_packages, ``{

		if( ret != `abort ) {
		    rret = UI::PollInput();

		    if( ! (rret == "" || rret == nil ))
		    {
			ret = OSRPkgUI::EvalUserInput(rret );
			if ( ret == `abort ) return `abort;
			if ( ret == `pause )
			{
			    repeat {
				y2milestone("Starting pause loop");
				rret = UI::UserInput();
				ret  = OSRPkgUI::EvalUserInput( rret );
				if ( ret == `abort ) return `abort;
			    } until( ret == `continue || ret == `abort || ret == `cancel );
			} 
		    }

		    if (! haskey(OSRPkgVerify::verified_packages, p ) && ret != `abort && ret != `cancel)
		    {
			if ( ! OSRPkgVerify::Verify( p ) )
			{
			    missing_packages = add(missing_packages, p );
			}
		    }
		
		}
	    });
	    OSRPkgUI::Finish();

	    // finish verified wait for user input in expert mode.
	    if ( ret != `abort && OSRPkgUI::expert_mode )
	    {
		check_packages = [];
		rret = UI::UserInput();
		y2milestone(" user input get signal %1", rret);
		if( ret != nil  )  // e.g.: get a `cancel or `abort
		{
		    ret = OSRPkgUI::EvalUserInput( rret );
		}
		else {
		    ret = `next;
		}

		// all packages verified.
		if( ret == `abort || ret == `cancel ) ret = `next;
	    }
	    // close dialog in normal mode
	    else {
		ret = `next;
	    }
	    
	} until ( ret == `next || ret == `abort || ret == `cancel );
	
	UI::CloseDialog();

	
	missing_packages = OSRPkgVerify::not_successful_verified;
	
	OSRPkgVerify::WriteVerifiedPackages( check_packages, false);
	
	if( size( missing_packages ) > 0 )
	{
	    string protocol_label = _("Show protocol");
	    OSRPkgUI::expert_mode = true;
	    install_missing_dialog_data = [
					   _("Not verified packages"),
					   _("
YaST verified the installed software
and found problems by the following
packages."),

					   _("
YaST propose to install these packages
new. Please press \"Repair \" to install
all selected packages in the list.
"),
					   sformat(_("
<P>YaST have verified all install packages. Some
of these packages contains error. For details
see the protocol of the verify process.
To open the protocol press the button %1.</P>

<p>There you can see if files of the package are
missing or the data of the package in the package
database diff with the installed files of the
package.</P>
"), protocol_label),
					   _("Packages with problems:"),
					   [ [`Right(`PushButton( `id(`protocol), protocol_label )), `protocol, ``(OSRPkgUI::ProtocolDialog())]]
	     ];
	}
	return ret;
    }

    
    /**
     * Install selected Packages. The packages are damaged or not install.
     * Call CheckMinimum or VerifyPackages before.
     */
    global define symbol InstallMissing(boolean use_dialog )``{

	symbol ret = `ok;
	
	if( size(missing_packages) > 0 )
	{
	    list(list) item_list = [];
	    foreach(string item, missing_packages, ``{
		item_list = add( item_list, [item, true]);
	    });


	    if (use_dialog )
	    {
		missing_packages = OSRPopup::MultiSelectionBox(
						       install_missing_dialog_data[0]:"",
						       install_missing_dialog_data[1]:"",
						       install_missing_dialog_data[2]:"",
						       install_missing_dialog_data[3]:"",
						       install_missing_dialog_data[4]:"",
						       item_list,
						       install_missing_dialog_data[5]:[]);
	    }

	   if( missing_packages == [] )
	   {
	       y2milestone("No packages to install. User skiped reinstall.");
	       ret = `cancel;
	   }
	   else
	   {
	       y2milestone("Install missing or damaged packages %1", missing_packages );
	       
		if ( OpenPkg(root_mountpoint ))
		{
		    boolean ok = true;

		    foreach (string p, missing_packages , ``{
			ok = ok && Pkg::PkgInstall (p);
			if( ! ok )
			{
			    y2error("Change the state to install for  package %1 failed", p );
			}
		    });

		    ok = ok && Pkg::PkgSolve ();
		    y2milestone("Solving dependencies returned %1", ok );
		    
		    list result = Pkg::PkgCommit (0);
		    y2milestone ("PkgCommit: %1", result );

		    ok = ok && result[1]:nil == [] && result[2]:nil == [];
		    Wizard::CreateDialog ();
		    WFM::CallModule ("inst_suseconfig", [false, false]);

		    Wizard::CloseDialog ();

		    if ( ok )
		    {
			reinstalled_packages = missing_packages;
			y2milestone("All reinstalled_packages: %1", reinstalled_packages );
			ret = `ok;
		    }
		    else ret = `error;
		}
		else {
		    y2error("Opening the ppackage database failed");
		    ret = `error;
		}
	    }
	}
	else {
	    y2error("No missing packages. Set missing_packages before.");
	    ret = `cancel;
	}	
	return ret;
    }

}


