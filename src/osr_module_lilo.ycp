/**
 * File:
 *   osr_module_lilo.ycp
 *
 * Module:
 *   LILO checking module.
 *
 * Summary:
 *   YaST2 OS Repair. Automatic error detection & repair tool for Linux.
 *
 * Author:
 *   Michael Koehrmann <curry@suse.de>
 *
 * $Id$
 */

{
  textdomain "osr";

  // begin argument handling: in the initial phase the framework calls each module
  // with the argument ".init", don't delete!
  integer arg_c = size(Args());
  integer arg_n = 0;

  boolean init_mode = false;
  
  while ( arg_n < arg_c )
  {
      if ( Args(arg_n) == .init ) init_mode = true;
      else
      {
	  y2error("ERROR: unknown option %1", Args(arg_n) );
	  return `error;
      }
      arg_n = arg_n + 1;
  }
  // end argument handling

  //////////////////////////////////////////////////////////////////////
  //
  //  METHODS
  //
  //////////////////////////////////////////////////////////////////////
  
  /**
   *  Initialization of the module map that contains all important information
   *  for this module.
   *
   *  @return map The map that contains all information about the module osr_module_lilo.
   */
  define OSRLiloInit() ``{
      
      map osr_module_lilo = $[];

      osr_module_lilo = $[
			  // has to be the name of the file
			  "name"              :  "osr_module_lilo",
			  "headline"          :  _("LILO"),
			  "summary"           :  [],
			  "test_mode_summary" :  [
						  $["header" : "LILO package", "description" : "Package is installed", "error" : false],
						  $["header" : "LILO package", "description" : "Package is verified", "error" : false]
			  ],

			  // the sequence of the detection methods of this module
			  "detect_methods"    :  [
						  ``(OSRLiloCheckPackage()),
						  ``(OSRLiloConfTest())
			  ],

			  // the values this module requires from other modules of the rescue system
			  // use "yast2 osr .provides" to create the file "/tmp/osr_global_provides" to
			  // show which values are already provided
			  "requires"          :  [
						  "disk_device_list",
						  "root_partition",
						  "root_mountpoint",
						  "kernel_path_list",
						  "initrd_path_list",
						  "repair_target"
			  ],

			  // the values this module will provide
			  "provides"          : $[
						  "lilo_package_is_installed" : $[ "type" : "boolean", "value" : false, "status" : "unknown" ],
						  "lilo_package_is_verified"  : $[ "type" : "boolean", "value" : false, "status" : "unknown" ],
						  "lilo_conf_path"            : $[ "type" : "string", "value" : "/etc/lilo.conf", "status" : "unknown" ]
			  ],

			  // informations for the module progress bar
			  "progress_file"     : OSRGetTmpDir() + "/osr_module_lilo_progress",
			  "progress_expect"   : 1000
      ];
      return osr_module_lilo;
  }

  //////////////////////////////////////////////////////////////////////
  //
  //  DETECTION METHODS
  //
  //////////////////////////////////////////////////////////////////////
  
  /**
   *  This detection method checks the lilo RPM-package. It looks if the
   *  package is installed, is verified and some other things.
   *
   *  Requires: string repair_target
   *
   *  @return map The result_map.
   */
  global define OSRLiloCheckPackage() ``{

      boolean repair_question  = false;
      boolean error_detected   = false;
      integer progress_expect  = 40;
      string  minimum_version  = "21.6";
      string  module_name      = "osr_module_lilo";
      string  command          = "";
      string  help_text        = "";
      string  error_message    = "";
      string  progress_file    = "";
      string  progress_label   = _("Checking LILO package");
      string  lilo_version     = "";
      string  lilo_conf_path   = "/etc/lilo.conf";
      string  stdout_string    = "";
      string  status           = "";
      list    error_keys       = [];
      map     module_map       = $[];
      map     result_map       = $[];
      map     return_map       = $[];

      string  repair_target    = "";

      module_map      = OSRGetModuleMap(module_name);

      progress_file   = lookup(module_map, "progress_file", "");

      repair_target = OSRRequireString("repair_target");

      // set the parameters for the module progress bar
      OSRModuleProgress::SetParams(progress_label, progress_file, progress_expect);

      if (demo_mode)
      {
          // set demo values
	  return_map = $["exit" : 0, "stdout" : "lilo-21.6-56", "stderr" : ""];
      }
      else
      {	  
	  // set the command line and execute, only in non-demo mode, the return map would look like this:
	  // $["exit" : 0, "stdout" : "lilo-21.6-56", "stderr" : ""]
	  if (repair_target != "")
	  {
	      // if the rescue system is executed from CD-Rom or NFS, the root directory has to
	      // be specified, see man 8 lilo for details
	      command = sformat("/bin/rpm -q -r %1 lilo", repair_target);
	      return_map = OSRExecuteCommandOutput(command, .local);
	  }
	  else
	  {
	      // if the rescue system is executed from the ruinning Linux system
	      command = "/bin/rpm -q lilo";
	      return_map = OSRExecuteCommandOutput(command, .target);
	  }
      }

      // increase the value of the module-progress-bar
      OSRModuleProgress::Add(10);

      if (lookup(return_map, "exit", 1) != 0)
      {
	  // rpm -q lilo reported an error -> lilo.rpm is not installed
	  status = OSRStatusDetectError();

	  // text for the error window
	  error_detected = true;
 	  error_message  = _("The LILO package is not installed on your system.

Repair will install this package.");

	  // text for the help window
	  help_text      = sformat(
				   _("<p>The command %1 reported the following error: %2</p>
<p>It seems that the LILO package is not installed
on your system. This package is one of the basic
packages for your system. Alternatively you can use
another bootloader than LILO.</p>
<p>Press <b>Repair</b> to install this package.</p>"), command, lookup(return_map, "stderr", ""));

	  // display the result in the RichText widget
	  OSRSummaryDetectError(
				module_name,
				_("Checking LILO package"),
				_("/bin/rpm -q lilo reports an error<br>
Package is not installed")
				);
      }
      else
      {
	  status = OSRStatusDetectOK();

	  // display the result in the RichText widget
	  OSRSummaryDetectOK(
			     module_name,
			     _("Checking LILO package"),
			     _("/bin/rpm -q lilo reports no errors<br>
Package is installed")
			     );
	  
	  stdout_string = lookup(return_map, "stdout", "");

	  // cut the substring "lilo-" off the output string
	  lilo_version = substring(stdout_string, size("lilo-"), (size(stdout_string)-1));
	  
	  // increase the value of the module progress bar
          OSRModuleProgress::Add(10);
	  
          // check if the current version of lilo is higher than a specific minimum version number
	  if (!OSRVersionIsHigherOrEqual(lilo_version, minimum_version))
	  {
	      status = OSRStatusDetectError();

	      // the current lilo version is older than the minimum_version
	      error_detected = true;
	      
              // error text for the error window
	      error_message = _("
The version of the LILO package installed on your
system is obsolete.

Repair will install a later version of this package.");

	      // help text for the help window
	      help_text = sformat(_("<p>The command %1 reported an error: %2</p>
<p>The version of the LILO package installed
on your system is obsolete.</p>
<p>This package is one of the basic packages
for your system.</p>
<p>Press <b>Repair</b> to install a later version
of this package.</p>"), command, lookup(return_map, "stderr", ""));
	      
	      // display the result in the RichText widget
	      OSRSummaryDetectError(
				    module_name,
				    _("Checking LILO version"),
				    sformat(
					    _("Current version is obsolete: %1<br>
Should be version number %2 or later"),
					    stdout_string,
					    minimum_version
					    )
				    );
	  }
	  else
	  {
	      status = OSRStatusDetectOK();

	      error_detected = false;

	      // display the result in the RichText widget
	      OSRSummaryDetectOK(
				 module_name,
				 _("Checking LILO version"),
				 sformat(_("Version number is up to date: %1"), stdout_string)
				 );
	      
	      if (demo_mode)
	      {
		  // demo value
		  return_map = $["exit" : 0, "stdout" : "", "stderr" : ""];
	      }
	      else
	      {
		  // result is the exit code of the bash command, only in non demo mode
		  // should look like: $["exit" : 0, "stdout" : "", "stderr" : ""] or something like
		  // $["exit" : 1, "stdout" : ".......T   /sbin/lilo", "stderr" : ""]
		  // if any file of the lilo package differs to the original
		  if (repair_target != "")
		  {
		      // if the rescue system is executed from CD-Rom or NFS, the root directory has to
		      // be specified, see man 8 lilo for details
		      command = sformat("/bin/rpm -V -r %1 lilo", repair_target);
		      return_map = OSRExecuteCommandOutput(command, .local);
		  }
		  else
		  {
		      // if the rescue system is executed from the running Linux system
		      command = "/bin/rpm -V lilo";
		      return_map = OSRExecuteCommandOutput(command, .target);
		  }
	      }

	      // increase the value of the module progress bar
	      OSRModuleProgress::Add(10);

	      if (lookup(return_map, "exit", 1) != 0)
	      {
		  status = OSRStatusDetectError();

		  // rpm -V lilo reported an error -> some of the package files differ to the original ones
		  error_detected = true;

		  string stdout  = lookup(return_map, "stdout", "");

		  error_message  = _("
Some files of the LILO package differ to the original
package files.

Repair will reinstall a new version of this package.");

		  // help text for the help window
		  help_text = sformat(_("<p>The command %1 reported the following error: %2</p>
<p>Some files of the LILO package differ to the original
package files.</p>
<p>This package is one of the basic packages for your
system. If you use another bootloader than LILO skip the
following repair step.</p>
<p>Press <b>Repair</b> to install this package on your
system.</p>"), command, stdout);

		  // display the result in the RichText widget
		  OSRSummaryDetectError(
					module_name,
					_("Verifying the LILO package"),
					sformat(_("rpm -V lilo reports an error:<br>
%1<br>Some files differ to the original"), stdout)
					);
	      }
	      else
	      {
		  status = OSRStatusDetectOK();

		  // everything is o.k.
		  error_detected = false;
		  
		  // display the result in the RichText widget
		  OSRSummaryDetectOK(
				     module_name,
				     _("Verifying the LILO package"),
				     _("rpm -V lilo reports no errors<br>Package is o.k.")
				     );
	      }
	  }
      }

      if ((error_detected) || (status == OSRStatusDetectError()))
      {
	  // set the value of the module progress bar to 100%
	  OSRModuleProgress::Fill();

	  // launch the repair popup, in automatic mode no popup is displayed and "true" is returned
	  repair_question = OSRPopupRepair(_("Error detected"), error_message, help_text);

	  // REPAIR
	  if (repair_question)
	  {
	      // install the LILO package
	      if (OSRLiloPackageInstall())
	      {
		  status = OSRStatusRepairOK();

		  boolean lilo_conf_exists = OSRLiloConfExists();
		  boolean backup_created   = false;

		  // if an old lilo.conf exists create a backup
		  if (lilo_conf_exists)
		  {
		      backup_created = OSRLiloConfCreateBackup();
		  }


		  /*
		  UI::OpenDialog(`opt(`decorated));
		  
		  CallFunction(`lilo());

		  UI::CloseDialog();

		  status = OSRStatusRepairOK();

		  OSRSummaryRepairOK(
			     module_name,
			     _("Creating new LILO configuration file"),
			     _("Creation succeeded")
			     );
		  */
		  
		  // create a new LILO configuration file
		  if (!OSRLiloConfCreate())
		  {
                      // TODO: launch the lilo configuration module!
		      //CallFunction(`lilo());
		      
		      status = OSRStatusRepairError();

		      y2error("Creation of new lilo.conf failed.");

		      // revert the old lilo configuration file if a backup was made
		      if (backup_created)
		      {
			  OSRLiloConfRevertBackup();
		      }
		  }
		  else
		  {
		      status = OSRStatusRepairOK();
		  }

		  // /sbin/lilo has to be executed after a new installation of lilo.rpm,
		  // no matter if /etc/lilo.conf changed or not!
		  if (!OSRLiloExecuteLilo())
		  {
		      status = OSRStatusRepairError();

		      y2debug("Execution of /sbin/lilo failed.");
		  }
		  else
		  {
		      status = OSRStatusRepairOK();
		  }
		  
	      }
	      else
	      {
		  status = OSRStatusRepairError();

		  y2debug("Installing of lilo.rpm failed");
	      }
	  }
	  else
	  {
	      // !repair_question
	      status = OSRStatusRepairOmit();

	      // display the result in the RichText widget
	      OSRSummaryRepairOmit(
				   module_name,
				   _("Installing the LILO package"),
				   _("Package not installed")
				   );
	  }
      }
      result_map = $[
		     "status"         : status,
		     "error_detected" : error_detected,
		     "error_repair"   : repair_question,
		     "error_keys"     : error_keys
      ];

      // set the value of the module progress bar to 100%
      OSRModuleProgress::Fill();
      
      return result_map;
  }

  /**
   *  Checks the configuration file lilo.conf for consistency.
   *
   *  Requires: string repair_target,
   *            //list disk_device_list,
   *            string root_partition
   *
   *  @return map The result_map of this detection method.
   */
  global define OSRLiloConfTest() ``{

      boolean error_detected        = false;
      boolean repair_question       = false;
      boolean lilo_conf_exists      = false;
      integer result                = 1;
      integer progress_expect       = 600;
      string  module_name           = "osr_module_lilo";
      string  command               = "";
      string  help_text             = "";
      string  error_message         = "";
      string  progress_file         = "";
      string  progress_label        = "Checking LILO configuration file";
      list    error_keys            = [];
      map     result_map            = $[];
      list    lilo_conf_list        = [];
      string  root_partition        = "";
      string  root_device           = "";
      string  boot_device           = "";
      string  lilo_conf_path        = "/etc/lilo.conf";
      string  status                = "";

      progress_file   = lookup(module_map, "progress_file", "");
      
      OSRModuleProgress::SetParams(progress_label, progress_file, progress_expect);

      if (demo_mode)
      {
	  // set demo value
	  lilo_conf_exists = true;
      }
      else
      {
	  lilo_conf_exists = OSRLiloConfExists();
      }

      // increase the value of the module progress bar
      OSRModuleProgress::Add(10);
      
      if (!lilo_conf_exists)
      {
	  status = OSRStatusDetectError();

	  // error: the file /etc/lilo.conf doesn't exist
	  error_detected = true;

	  /*
	  // display the results to the RichText widget
	  OSRSummaryDetectError(
				module_name,
				_("Checking LILO configuration file"),
				_("File does not exist at /etc/lilo.conf")
				);
	  */
				
	  // set the value of the module progress bar to 100%
	  OSRModuleProgress::Fill();
	  
	  help_text = sformat(_("<p>The LILO configuration file does not exist at %1.</p>

<p>It is highly recommended to place the LILO configuration
file at its standard location /etc/lilo.conf.</p>

<p>If you use another file instead copy this to
the standard location /etc/lilo.conf and skip the
following repair step. Don't forget to run /sbin/lilo!</p>

<p>Press <b>Repair</b> to create a new configuration
file.</p>"), lilo_conf_path);

	  error_message = sformat(_("The LILO configuration file does not exist at %1.

Press Repair to create a new configuration file."), lilo_conf_path);

	  // launch the repair popup, in automatic mode no popup is launched and "true" is returned
          repair_question = OSRPopupRepair(_("Error detected"), error_message, help_text);

          // REPAIR
	  if (repair_question)
	  {
//	      boolean lilo_conf_exists = OSRLiloConfExists();
	      boolean backup_created = false;

	      // if an old lilo.conf exists create a backup
	      if (lilo_conf_exists)
	      {
		  backup_created = OSRLiloConfCreateBackup();
	      }

              /*
	      UI::OpenDialog(`opt(`decorated));
	      CallFunction(`lilo());
	      UI::CloseDialog();

	      status = OSRStatusRepairOK();

	      OSRSummaryRepairOK(
				 module_name,
				 _("Creating new LILO configuration file"),
				 _("Creation succeeded")
				 );
	      */
	      
	      // create a new LILO configuration file
	      if (!OSRLiloConfCreate())
	      {
		  // TODO: launch the lilo configuration module!
		  //CallFunction(`lilo());
		      
		  status = OSRStatusRepairError();

		  y2error("Creation of new lilo.conf failed.");

		  // revert the old lilo configuration file if a backup was made
		  if (backup_created)
		  {
		      OSRLiloConfRevertBackup();
		  }
	      }
	      else
	      {
		  status = OSRStatusRepairOK();
	      }

	      if (!OSRLiloExecuteLilo())
	      {
		  status = OSRStatusRepairError();

		  y2debug("Execution of /sbin/lilo failed.");
	      }
	      else
	      {
		  status = OSRStatusRepairOK();
	      }
	  }
	  else
	  {
	      // !repair_question
	      status = OSRStatusRepairOmit();
	      
	      // display the result in the RichText widget
	      OSRSummaryRepairOmit(
				   module_name,
				   _("Creating LILO configuration file"),
				   _("Configuration file not repaired")
				   );
	  }
      }
      else
      {
	  status = OSRStatusDetectOK();

	  // the file /etc/lilo.conf exists
	  error_detected = false;

	  /*
	  // display the results to the RichText widget
	  OSRSummaryDetectOK(
			     module_name,
			     _("Checking LILO configuration file"),
			     sformat(
				     _("File exists at %1"),
				     lilo_conf_path
				     )
			     );
	  */
	  
	  // increase the value of the module progress bar
	  OSRModuleProgress::Add(10);

	  if (demo_mode)
	  {
	      // demo value
	      result = 0;
	  }
	  else
	  {
	      // execute a test run of /sbin/lilo, if it succeeds, most parts of the config file will be o.k.
	      command = "lilo -t -v";
	      result = OSRExecuteCommandProgress(command, .target, progress_file);
	  }

	  // increase the value of the module progress bar
	  OSRModuleProgress::Add(10);

	  if (result != 0)
	  {
	      status = OSRStatusDetectError();

	      error_detected = true;

	      // display the results in the RichText widget
	      OSRSummaryDetectError(
				    module_name,
				    _("Checking LILO configuration file"),
				    _("/sbin/lilo -t reports an error")
				    );

	      // set the value of the module progress bar to 100%
	      OSRModuleProgress::Fill();
	  
	      help_text = _("
<p>The command /sbin/lilo -t reported an error.</p>
<p>Press <b>Repair</b> to create a new LILO configuration
file.</p>");
	      
	      error_message = _("The command /sbin/lilo -t reported an error.

Press Repair to create a new LILO configuration
file.");

	      // launch the repair popup
	      repair_question = OSRPopupRepair(_("Error detected"), error_message, help_text);

              // REPAIR
	      if (repair_question)
	      {
//		  boolean lilo_conf_exists = OSRLiloConfExists();
		  boolean backup_created = false;

		  // if an old lilo.conf exists create a backup
		  if (lilo_conf_exists)
		  {
		      backup_created = OSRLiloConfCreateBackup();
		  }

		  /*
		  UI::OpenDialog(`opt(`decorated));
		  CallFunction(`lilo());
		  UI::CloseDialog();

		  status = OSRStatusRepairOK();

		  OSRSummaryRepairOK(
				     module_name,
				     _("Creating new LILO configuration file"),
				     _("Creation succeeded")
				     );
		  */

		  // create a new LILO configuration file
		  if (!OSRLiloConfCreate())
		  {
		      // TODO: launch the lilo configuration module!
		      //CallFunction(`lilo());
		      
		      status = OSRStatusRepairError();

		      y2error("Creation of new lilo.conf failed.");

		      // revert the old lilo configuration file if a backup was made
		      if (backup_created)
		      {
			  OSRLiloConfRevertBackup();
		      }
		  }
		  else
		  {
		      status = OSRStatusRepairOK();
		  }

		  if (!OSRLiloExecuteLilo())
		  {
		      status = OSRStatusRepairError();

		      y2debug("Execution of /sbin/lilo failed.");
		  }
		  else
		  {
		      status = OSRStatusRepairOK();
		  }
	      }
	      else
	      {
		  // !repair_question
		  status = OSRStatusRepairOmit();
		  
		  // display the result in the RichText widget
		  OSRSummaryRepairOmit(
				       module_name,
				       _("Creating LILO configuration file"),
				       _("Configuration file not repaired")
				       );
	      }
	  }
	  // TODO
	  //else if (result == 127)
	  //{
	  // command not found: /sbin/lilo, maybe package not installed

	  //}
	  else
	  {
	      status = OSRStatusDetectOK();

	      error_detected = false;

	      // display the results in the RichText widget
	      OSRSummaryDetectOK(
				 module_name,
				 _("Checking LILO configuration file"),
				 _("/sbin/lilo -t reports no errors")
				 );

	      if (demo_mode)
	      {
		  // demo value
		  boot_device = "/dev/hda";
	      }
	      else
	      {
		  // TODO: use a better agent for parsing the lilo configuration file
		  lilo_conf_list = SCR::Read(.etc.liloconf1, ["/mnt" + lilo_conf_path]);
		  boot_device    = lookup(find(`n, lilo_conf_list, ``(lookup(n, "key", "") == "boot")), "value", "");
	      }
	      
	      OSRModuleProgress::Add(10);
	      
	      if (boot_device == "" || boot_device == nil)
	      {
		  status = OSRStatusDetectError();

		  // from man 5 lilo.conf:
		  // boot=<boot-device>
		  //    Sets the name of the device (e.g. a hard disk partition) that contains the
		  //    boot sector. If this keyword is omitted, the boot sector is read from (and
		  //    possibly written to) the device that is currently mounted as root.
		  error_detected = true;

		  // display the results in the RichText widget
		  OSRSummaryDetectError(
					module_name,
					_("Checking LILO configuration file"),
					_("No boot device specified")
					);

		  // increase the value of the module progress bar
		  OSRModuleProgress::Add(10);

		  help_text = _("<p>In the LILO configuration file no boot device is
specified.</p>
<p>Press <b>Repair</b> to create a new LILO configuration
file.</p>
");
		  help_text = help_text + _("");


		  error_message = _("In the LILO configuration file no boot device is
specified. For some system configurations this
may cause several errors.

Press Repair to create a new LILO configuration
file.");

		  // launch the repair popup
		  repair_question = OSRPopupRepair(_("Error detected"), error_message, help_text);

		  // REPAIR
		  if (repair_question)
		  {
		      // increase the value of the module progress bar
		      OSRModuleProgress::Add(10);

		      // get the device of the root partition and cut the partition number
		      root_partition = OSRRequireString("root_partition");
 		      root_device    = select(splitstring(root_partition, "1234567890"), 0);

		      // set the value of the module progress bar to 100%
		      OSRModuleProgress::Fill();

//		      boolean lilo_conf_exists = OSRLiloConfExists();
		      boolean backup_created   = false;

		      // if an old lilo.conf exists create a backup
		      if (lilo_conf_exists)
		      {
			  backup_created = OSRLiloConfCreateBackup();
		      }


		      /*
		      UI::OpenDialog(`opt(`decorated));
		      CallFunction(`lilo());
		      UI::CloseDialog();

		      status = OSRStatusRepairOK();

		      OSRSummaryRepairOK(
					 module_name,
					 _("Creating new LILO configuration file"),
					 _("Creation succeeded")
					 );
		      */

		      // create a new LILO configuration file
		      //if (!OSRLiloConfCreateBootDevice(root_device))

		      if (!OSRLiloConfCreate())
		      {
			  // TODO: launch the lilo configuration module!
			  //CallFunction(`lilo());
		      
			  status = OSRStatusRepairError();

			  y2error("Creation of new lilo.conf failed.");

			  // revert the old lilo configuration file if a backup was made
			  if (backup_created)
			  {
			      OSRLiloConfRevertBackup();
			  }
		      }
		      else
		      {
			  status = OSRStatusRepairOK();
		      }
		      
     		      if (!OSRLiloExecuteLilo())
		      {
			  status = OSRStatusRepairError();
		      }
		      else
		      {
			  status = OSRStatusRepairOK();

		      }
		  }
		  else
		  {
		      // !repair_question
		      status = OSRStatusRepairOmit();

		      // display the result in the RichText widget
		      OSRSummaryRepairOmit(
					   module_name,
					   _("Creating LILO configuration file"),
					   _("Configuration file not repaired")
					   );		      
		  }
	      }
	      else
	      {
		  status = OSRStatusDetectOK();

		  error_detected = false;

		  // display the results in the RichText widget
		  OSRSummaryDetectOK(
				     module_name,
				     _("Checking LILO configuration file"),
				     sformat(
					     _("Boot device: %1"),
					     boot_device
					     )
				     );

		  // increase the value of the module progress bar
		  OSRModuleProgress::Add(10);
	      }
	  }
      }

      // set the value of the module progress bar to 100%
      OSRModuleProgress::Fill();
      
      result_map = $[
		     "status"         : status,
		     "error_detected" : error_detected,
		     "error_repair"   : repair_question,
		     "error_keys"     : error_keys
      ];
      return result_map;
  };

  /**
   *  Checks if the lilo configuration file exists at the standard location
   *  /etc/lilo.conf.
   *
   *  Requires: string root_mountpoint
   * 
   *  @return boolean True if the file /etc/lilo.conf exists.
   */
  global define OSRLiloConfExists() ``{

      string  lilo_conf_path  = "/etc/lilo.conf";
      string  root_mountpoint = "";
      integer lilo_conf_size  = 0;
      string  module_name     = "osr_module_lilo";

      root_mountpoint = OSRRequireString("root_mountpoint");

      // look if the file lilo.conf exists an has a positive size
      lilo_conf_size  = SCR::Read(.target.size, "" + root_mountpoint + lilo_conf_path);

      if (lilo_conf_size > 0)
      {
	  y2milestone("LILO configuration file exists at %1", root_mountpoint + lilo_conf_path);

	  OSRSummaryDetectOK(
			     module_name,
			     _("Checking LILO configuration file"),
			     sformat(_("File exists at %1"), root_mountpoint + lilo_conf_path)
			     );
	  
      }
      else if (lilo_conf_size == 0)
      {
	  y2error("LILO configuration file exists at %1 but is empty", root_mountpoint + lilo_conf_path);

	  OSRSummaryDetectError(
				module_name,
				_("Checking LILO configuration file"),
				sformat(_("File %1 is empty"), root_mountpoint + lilo_conf_path)
				);

      }
      else
      {
	  y2error("LILO configuration file does not exist at %1", root_mountpoint + lilo_conf_path);

	  OSRSummaryDetectError(
				module_name,
				_("Checking LILO configuration file"),
				sformat(_("File does not exist at %1"), root_mountpoint + lilo_conf_path)
				);
      }
      
      return (lilo_conf_size > 0);
  };

  //////////////////////////////////////////////////////////////////////
  //
  //  REPAIR METHODS
  //
  //////////////////////////////////////////////////////////////////////

  /**
   *  Creates a backup of the current LILO configuration file, if it exists.
   *  The location of the backup file is OSRGetTmpDir() + "/lilo.conf".
   * 
   *  @return boolean True if the backup succeeded.
   */
  global define OSRLiloConfCreateBackup() ``{

      string command         = "";
      string lilo_conf_path  = "/etc/lilo.conf";
      string root_mountpoint = "";

      root_mountpoint = OSRRequireString("root_mountpoint");
      
      command = sformat("cp %1 %2", root_mountpoint + lilo_conf_path, OSRGetTmpDir() + "/lilo.conf");
      integer copy_result = OSRExecuteCommand(command, .target);

      if (copy_result == 0)
      {
	  OSRSummaryDetectOK(
			     module_name,
			     _("Creating backup of lilo configuration file"),
			     _("Backup succeeded")
			     );
      }
      else
      {
	  OSRSummaryDetectError(
				module_name,
				_("Creating backup of lilo configuration file"),
				_("Backup failed")
				);
      }
      return (copy_result == 0);
  };

  /**
   *  Reverts the backup of the LILO configuration file, if a backup was made.
   * 
   *  @return boolean True if reverting succeeded.
   */
  global define OSRLiloConfRevertBackup() ``{

      string command        = "";
      string lilo_conf_path = "/etc/lilo.conf";

      command = sformat("cp %1 %2", OSRGetTmpDir() + "/lilo.conf", lilo_conf_path);
      integer copy_result = OSRExecuteCommand(command, .target);

      if (copy_result == 0)
      {
	  OSRSummaryDetectOK(
			     module_name,
			     _("Reverting backup of lilo configuration file"),
			     _("Copy succeeded")
			     );
      }
      else
      {
	  OSRSummaryDetectError(
				module_name,
				_("Reverting backup of lilo configuration file"),
				_("Copy failed")
				);
      }
      return (copy_result == 0);
  };
  
  /**
   *  Installs the lilo package lilo.rpm.
   * 
   *  @return boolean True if the repair process was successful.
   */
  global define OSRLiloPackageInstall() ``{

      integer result          = 1;
      integer progress_expect = 50;
      string  command         = "";
      string  progress_label  = "Installing LILO package";
      string  progress_file   = "";
      string  module_name     = "osr_module_lilo";
      boolean mount_ok        = false;
      boolean error_detected  = false;
      
      progress_file   = lookup(module_map, "progress_file", "");

      // TODO: check for old installation source media: cdrom, ftp, www, /work4, ...
      //       check mount, check for installation dir, ...
      //mount_ok = ChangeCD( 1, true );

      // setting up the progress bar
      OSRModuleProgress::SetParams(progress_label, progress_file, progress_expect);

      // install the lilo package
      //command = "/bin/rpm -hU --force /tmp/lilo.rpm";
      //result  = OSRExecuteCommandProgress(command, progress_file);

      string tmpdir   = SCR::Read(.target.tmpdir);
      string filename = tmpdir + "/sw_single_input";
      SCR::Write(.target.ycp, filename, $["install":["lilo"], "userInput" : false ]);
      symbol res_symbol = CallFunction (`inst_sw_single(`single, `not_only_checked));

      y2error("result: %1", res_symbol);

      // TODO: get the result from sw_single
      result = 0;
      
      if (result == 0)
      {
	  error_detected = false;
	  
	  OSRSummaryRepairOK(
			     module_name,
			     _("Installing the LILO package"),
			     _("Installation succeeded")
			     );
      }
      else
      {
	  error_detected = true;

	  OSRSummaryRepairError(
				module_name,
				_("Installing the LILO package"),
				_("Installation was not successfull")
				);
      }

      return (result == 0);
  }

  /**
   *  Creates a new lilo configuration file at /etc/lilo.conf.
   *
   *  Requires: list disk_device_list,
   *            string root_partition
   *
   *  @return boolean True if the repair process was successful.
   */
  global define OSRLiloConfCreate() ``{

      integer result           = 1;
      integer progress_expect  = 1200;
      string  command          = "";
      string  progress_label   = "Creating LILO configuration file";
      string  progress_file    = OSRGetTmpDir() + "/dolilo.log";
      string  boot_device      = "";
      string  root_partition   = "";
      string  root_device      = "";
      string  module_name      = "osr_module_lilo";
      list    disk_device_list = [];
      boolean error_detected   = false;

      /*
      command = "rm -f /tmp/dolilo.log";
      OSRExecuteCommand(command, .target);
      */
      
      // setting up the progress bar
      OSRModuleProgress::SetParams(progress_label, progress_file, progress_expect);

      // TODO: get the boot device, eventually from user
      disk_device_list = OSRRequireList("disk_device_list");
      root_partition   = OSRRequireString("root_partition");

      // cut the partition number off the root partition
      root_device = select(splitstring(root_partition, "1234567890"), 0);

      // figure out the boot device name where lilo should be installed,
      // as default the boot device is the one with the root partition inside,
      // TODO: user selection of the boot device
      //       - the entry in the old lilo.conf
      //       - user selection
      //       - the device with the root partition into it
      //       - floppy??
      if (size(disk_device_list) == 1)
      {
	  boot_device = select(disk_device_list, 0, "");
	  if (boot_device != root_device)
	  {
	      y2error("OSRLiloConfCreate ERROR: boot_device != root_device ??: %1 %2", boot_device, root_device);
	  }
      }
      else
      {
	  integer i          = 0;
	  boolean is_element = false;
	  while (i >= 0 && i < size(disk_device_list))
	  {
	      if (root_device == select(disk_device_list, i, ""))
	      {
		  is_element = true;
		  break;
	      }
	      i = i + 1;
	  }
	  if (!is_element)
	  {
	      if (!automatic_mode)
	      {
		  boot_device = OSRPopupSelectItem(
						   _("LILO boot device"),
						   _("You have to select one of the devices"),
						   disk_device_list,
						   "",
						   true
						   );
	      }
	      else
	      {
		  // TODO: is this true??
		  boot_device = root_device;
	      }
	  }
	  else
	  {
	      boot_device = root_device;

	      // TODO: ask the user??
	      /*
		boot_device = OSRPopupSelectItem(
		UI(_("LILO boot device")),
		UI(_("You have to select one of the devices")),
		disk_device_list,
		root_device
		);
	      */
	  }
      }
      // execute the command
      command  = sformat("/usr/lib/YaST2/bin/dolilo / -m %1 -v", boot_device);
      result   = OSRExecuteCommand(command, .target);

      /*
      command  = "cat /tmp/dolilo.log";
      OSRExecuteCommand(command, .target);
      */
      
      if (result == 0)
      {
	  error_detected = false;
	  
	  OSRSummaryRepairOK(
			     module_name,
			     _("Creating new LILO configuration file"),
			     _("Creation succeeded")
			     );
      }
      else
      {
	  error_detected = true;

	  OSRSummaryRepairError(
				module_name,
				_("Creating new LILO configuration file"),
				_("Creation was not successfull")
				);
      }
      
      return (result == 0);
  }

  /**
   *  Creates a new lilo configuration file at /etc/lilo.conf with the specified
   *  boot device.
   *
   *  @param string The new boot device.
   *  @return boolean True if the repair process was successful.
   */
  global define OSRLiloConfCreateBootDevice(string boot_device) ``{

      integer result           = 1;
      integer progress_expect  = 1200;
      string  command          = "";
      string  progress_label   = "Creating LILO configuration file";
      string  progress_file    = OSRGetTmpDir() + "/dolilo.log";
      string  root_partition   = "";
      string  module_name      = "osr_module_lilo";

      OSRExecuteCommand(command, .target);

      // setting up the progress bar
      OSRModuleProgress::SetParams(progress_label, progress_file, progress_expect);
      
      // execute the command and get the exit code
      command  = sformat("/usr/lib/YaST2/bin/dolilo / -m %1 -v", boot_device);
      result   = OSRExecuteCommand(command, .target);

      command  = "cat /tmp/dolilo.log";
      OSRExecuteCommand(command, .target);

      if (result == 0)
      {
	  error_detected = false;
	  
	  OSRSummaryDetectOK(
			     module_name,
			     _("Creating new LILO configuration file"),
			     _("Creation succeeded<br>
New configuration file is /etc/lilo.conf")
			     );
      }
      else
      {
	  error_detected = true;

	  OSRSummaryDetectError(
				module_name,
				_("Creating new LILO configuration file"),
				_("Creation was not successfull<br>
Resetting old configuration")
				);
      }

      return (result == 0);
  }
  
  /**
   *  Installs the bootloader. The command /sbin/lilo reads the configuration file
   *  at /etc/lilo.conf.
   *
   *  @return boolean True if the repair process was successful.
   */
  global define OSRLiloExecuteLilo() ``{

      integer result          = 1;
      integer progress_expect = 600;
      string  command         = "";
      string  progress_label  = _("Installing LILO bootloader");
      string  progress_file   = "";
      string  module_name     = "osr_module_lilo";

      progress_file   = lookup(module_map, "progress_file", "");
      
      // setting up the progress bar
      OSRModuleProgress::SetParams(progress_label, progress_file, progress_expect);

      // execute the lilo command and display the progress
      command = "/sbin/lilo -v";
      result  = OSRExecuteCommandProgress(command, .target, progress_file);
      
      if (result == 0)
      {
	  error_detected = false;
	  
	  OSRSummaryRepairOK(
			     module_name,
			     _("Executing LILO"),
			     _("Execution of LILO succeeded<br>
New bootloader installed")
			     );
      }
      else
      {
	  error_detected = true;

	  OSRSummaryRepairError(
				module_name,
				_("Executing LILO"),
				_("Execution of LILO was not successfull<br>
You have to run /sbin/lilo manually")
				);
      }

      
      // set the value of the module progress bar to 100%
      OSRModuleProgress::Fill();
      
      return (result == 0);
  }

  //////////////////////////////////////////////////////////////////////
  //
  //  MAIN
  //
  //////////////////////////////////////////////////////////////////////

  // in init mode only execute the init function and return the module map
  // to the framework, don't delete
  if (init_mode)
  {
      map module_map = OSRLiloInit();

      return module_map; 
  }
  // end MAIN
}
