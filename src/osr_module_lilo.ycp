/**
 * File:
 *   osr_module_lilo.ycp
 *
 * Module:
 *   LILO checking module.
 *
 * Summary:
 *   YaST2 OS Repair. Automatic error detection & repair tool for Linux.
 *
 * Author:
 *   Michael Koehrmann <curry@suse.de>
 *
 * $Id$
 */

{
  textdomain "osr";

  // begin argument handling: in the initial phase the framework calls each module
  // with the argument ".init", don't delete!
  integer arg_c = size(Args());
  integer arg_n = 0;

  boolean init_mode = false;
  
  while ( arg_n < arg_c )
  {
      if ( Args(arg_n) == .init ) init_mode = true;
      else
      {
	  y2error("ERROR: unknown option %1", Args(arg_n) );
	  return `error;
      }
      arg_n = arg_n + 1;
  }
  // end argument handling

  //map     mode_map  = lookup(osr_map, "mode_map", $[]);
  //boolean demo_mode = lookup(mode_map, "demo_mode", false);

  //y2error("DEMO: %1 %2", demo_mode, mode_map);
  
  //////////////////////////////////////////////////////////////////////
  //
  //  METHODS
  //
  //////////////////////////////////////////////////////////////////////
  
  /**
   *  Initialization of the module map that contains all important information
   *  for this module.
   *
   *  @return map The map that contains all information about the module osr_module_lilo.
   */
  define OSRLiloInit() ``{
      
      map osr_module_lilo = $[];

      osr_module_lilo = $[
		   // has to be the name of the file
		   "name"              :  "osr_module_lilo",
		   "headline"          :  _("LILO"),
		   "summary"           :  [],
		   "test_mode_summary" :  [
					   $["header" : "LILO package", "description" : "Package is installed", "error" : false],
					   $["header" : "LILO package", "description" : "Package is verified", "error" : false]
		   ],

		   // the sequence of the detection methods of this module
		   "detect_methods"    :  [
				    	   ``(OSRLiloCheckPackage()),
					   ``(OSRLiloConfTest())
		   ],

		   // the values this module requires from other modules of the rescue system
		   // use "yast2 osr .provides" to create the file "/tmp/osr_global_provides" to
		   // show which values are already provided
		   "requires"          :  [
					   "disk_device_list",
					   "root_partition",
					   "kernel_path_list",
					   "initrd_path_list",
					   "repair_target"
		   ],

		   // the values this module will provide
		   "provides"          : $[
					   "lilo_package_is_installed" : $[ "type" : "boolean", "value" : false, "status" : "unknown" ],
					   "lilo_package_is_verified"  : $[ "type" : "boolean", "value" : false, "status" : "unknown" ],
					   "lilo_conf_path"            : $[ "type" : "string", "value" : "/etc/lilo.conf", "status" : "unknown" ]
		   ],

		   // informations for the module progress bar
		   "progress_file"     : "/tmp/osr_module_lilo_progress",
		   "progress_expect"   : 1000
      ];
      return osr_module_lilo;
  }

  //////////////////////////////////////////////////////////////////////
  //
  //  DETECTION METHODS
  //
  //////////////////////////////////////////////////////////////////////
  
  /**
   *  This detection method checks the lilo RPM-package. It looks if the
   *  package is installed, is verified and some other things.
   *
   *  @return map The result_map.
   */
  global define OSRLiloCheckPackage() ``{

      boolean repair_question  = false;
      boolean error_detected   = false;
      integer progress_expect  = 40;
      string  minimum_version  = "21.6";
      string  module_name      = "osr_module_lilo";
      string  command          = "";
      string  help_text        = "";
      string  error_message    = "";
      string  progress_file    = "";
      string  progress_label   = _("Checking LILO package");
      string  log_file         = "";
      string  lilo_version     = "";
      string  lilo_conf_path   = "/etc/lilo.conf";
      string  stdout_string    = "";

      //TODO: update the documentation
      string  status           = ""; // "detect_ok", "detect_error", "repair_ok", "repair_error", "repair_omit"
      list    error_keys       = [];
      map     module_map       = $[];
      map     result_map       = $[];
      map     return_map       = $[];

      string  repair_target    = "";

      module_map      = OSRGetModuleMap(module_name);
      log_file        = OSRLogFile::GetFile();
      
      progress_file   = lookup(module_map, "progress_file", "");

      repair_target = OSRRequireString("repair_target");

      // set the parameters for the module-progress-bar
      OSRModuleProgress::SetParams(progress_label, progress_file, progress_expect);

      if (demo_mode)
      {
          // set demo values
	  return_map = $["exit" : 0, "stdout" : "lilo-21.6-56", "stderr" : ""];
      }
      else
      {	  
	  // set the command line and execute, only in non-demo-mode, the return-map would look like this:
	  // $["exit" : 0, "stdout" : "lilo-21.6-56", "stderr" : ""]
	  if (repair_target != "")
	  {
	      command = sformat("/bin/rpm -q -r %1 lilo", repair_target);
	      return_map = OSRExecuteCommandOutput(command, log_file, .local);
	  }
	  else
	  {
	      command = "/bin/rpm -q lilo";
	      return_map = OSRExecuteCommandOutput(command, log_file, .target);
	  }
      }

      // increase the value of the module-progress-bar
      OSRModuleProgress::Add(10);

      if (lookup(return_map, "exit", 1) != 0)
      {
	  // rpm -q lilo reported an error -> lilo.rpm is not installed
	  status = OSRStatusDetectError();

	  // error-text for the error-window
	  error_detected = true;
 	  error_message  = _("The LILO package is not installed on your system.\nRepair will install this package.");

	  // help-text for the help-window
	  help_text      = sformat(
				   _("<p>The command <code>%1</code> reported the following error: <code>%2</code></p>"),
				   command,
				   lookup(return_map, "stderr", ""));
	  help_text      = help_text + _("<p>It seems that the LILO package is not installed on your system. ");
	  help_text      = help_text + _("This package is one of the basic packages for your system. ");
	  help_text      = help_text + _("Alternatively you can use another bootloader than LILO.</p>");
	  help_text      = help_text + _("<p>Press <b>Repair</b> to install this package.</p>");

	  // display the result in the RichText-widget
	  OSRSummaryDetectError(
			  module_name,
			  _("Checking LILO package"),
			  _("<code>/bin/rpm -q lilo</code> reports an error<br>
Package is not installed")
			  );
      }
      else
      {
	  status = OSRStatusDetectOK();

	  // display the result in the RichText-widget
	  OSRSummaryDetectOK(
		       module_name,
		       _("Checking LILO package"),
		       _("<code>/bin/rpm -q lilo</code> reports no errors<br>
Package is installed")
		       );
	  
	  stdout_string = lookup(return_map, "stdout", "");

	  // cut "lilo-" off the string
	  //lilo_version = select(splitstring(stdout_string, "-"), 1, "");
	  lilo_version = substring(stdout_string, size("lilo-"), (size(stdout_string)-1));
	  
	  // increase the value of the module-progress-bar
          OSRModuleProgress::Add(10);

	  if (!OSRVersionIsHigherOrEqual(lilo_version, minimum_version))
	  {
	      status = OSRStatusDetectError();

	      // the current lilo-version is older than the minimum_version
	      error_detected = true;
	      
              // error-text for the error-window
	      error_message = _("The version of the LILO package installed on your system is obsolete.\n");
	      error_message = error_message + _("Repair will install a newer version of this package.");

	      // help-text for the help-window
	      help_text = sformat(
				   _("<p>The command <code>%1</code> reported an error: <code>%2</code></p>"),
				   command,
				   lookup(return_map, "stderr", ""));
	      help_text = help_text + _("<p>The version of the LILO package installed on your system is obsolete.</p>");
	      help_text = help_text + _("<p>This package is one of the basic packages for your system.</p>");
   	      help_text = help_text + _("<p>Press <b>Repair</b> to install a later version of this package.</p>");

	      // display the result in the RichText-widget
	      OSRSummaryDetectError(
			      module_name,
			      _("Checking LILO version"),
			      sformat(
				      _("Current version is obsolete: <code>%1</code><br>
Should be version number <code>%2</code> or later"),
				      stdout_string,
				      minimum_version
				      )
			      );
	  }
	  else
	  {
	      status = OSRStatusDetectOK();

	      error_detected = false;

	      // display the result in the RichText-widget
	      OSRSummaryDetectOK(
			   module_name,
			   _("Checking LILO version"),
			   sformat(
				   _("Version number is up to date: <code>%1</code>"),
				   stdout_string
				   )
			   );
	      
	      if (demo_mode)
	      {
		  // demo-value
		  return_map = $["exit" : 0, "stdout" : "", "stderr" : ""];
	      }
	      else
	      {
		  // result is the exit-code of the bash-command, only in non-demo-mode
		  // should look like: $["exit" : 0, "stdout" : "", "stderr" : ""] or 
		  // $["exit" : 1, "stdout" : ".......T   /sbin/lilo", "stderr" : ""] if /sbin/lilo was touched
		  if (repair_target != "")
		  {
		      command = sformat("/bin/rpm -V -r %1 lilo", repair_target);
		      return_map = OSRExecuteCommandOutput(command, log_file, .local);
		  }
		  else
		  {
		      command = "/bin/rpm -V lilo";
		      return_map = OSRExecuteCommandOutput(command, log_file, .target);
		  }
	      }

	      // increase the value of the module-progress-bar
	      OSRModuleProgress::Add(10);

	      if (lookup(return_map, "exit", 1) != 0)
	      {
		  status = OSRStatusDetectError();

		  // rpm -V lilo reported an error -> some of the package files differ to the original ones
		  error_detected = true;

		  string stdout  = lookup(return_map, "stdout", "");

		  error_message  = _("Some files of the LILO package differ to the original package files.\n");
		  error_message  = error_message + _("Repair will reinstall a new version of this package.");

		  // help-text for the help-window
		  help_text = sformat(
					   _("<p>The command <code>%1</code> reported the following error: <code>%2</code></p>"),
					   command,
					   stdout
					   );
		  help_text = help_text +  _("<p>Some files of the LILO package differ to the original package files.</p>");
		  help_text = help_text +  _("<p>This package is one of the basic packages for your system.</p>");
     	          help_text = help_text +  _("<p>Press <b>Repair</b> to reinstall this package.</p>");

		  // display the result in the RichText-widget
		  OSRSummaryDetectError(
				  module_name,
				  _("Verifying the LILO package"),
				  sformat(_("<code>rpm -V lilo</code> reports an error:<br>
<code>%1</code><br>
Some files differ to the original"), stdout)
				  );
	      }
	      else
	      {
		  status = OSRStatusDetectOK();

		  // everything is o.k.
		  error_detected = false;
		  
		  // display the result in the RichText-widget
		  OSRSummaryDetectOK(
			       module_name,
			       _("Verifying the LILO package"),
			       _("<code>rpm -V lilo</code> reports no errors<br>
Package is o.k.")
			       );
	      }
	  }
      }

      if ((error_detected) || (status == OSRStatusDetectError()))
      {
	  // set the value of the module-progress-bar to 100%
	  OSRModuleProgress::Fill();

	  // launch the repair-popup, in automatic-mode no popup is displayed and "true" is returned
	  repair_question = OSRPopupRepair(_("Error detected"), error_message, help_text);

	  // REPAIR
	  if (repair_question)
	  {
	      // install the LILO package
	      if (OSRLiloPackageInstall())
	      {
		  status = OSRStatusRepairOK();

		  // check if the file /etc/lilo.conf exists, if not create a new one
		  if (repair_target != "")
		  {
		      command    = sformat("test -f %1%2", repair_target, lilo_conf_path);
		      return_map = OSRExecuteCommandOutput(command, log_file, .local);
		  }
		  else
		  {
		      command    = sformat("test -f %1", lilo_conf_path);
		      return_map = OSRExecuteCommandOutput(command, log_file, .target);
		  }

		  if (lookup(return_map, "exit", 1) != 0)
		  {
		      // TODO: make a copy of /etc/lilo.conf
		      //command = sformat("cp %1 /tmp/lilo.conf.orig", lilo_conf_path);
		      //OSRExecuteCommand(command, log_file);
		      //SCR(`Execute(.target.bash, command));			 
		      
		      // create a new LILO-configuration-file
		      if (!OSRLiloConfCreate())
		      {
			  status = OSRStatusRepairError();

			  y2debug("Creation of new lilo.conf failed.");

			  // TODO: copy the original lilo.conf to /etc/lilo.conf
			  //command = sformat("cp /tmp/lilo.conf.orig %1", lilo_conf_path);
			  //OSRExecuteCommand(command, log_file);
			  //SCR(`Execute(.target.bash, command));
		      }
		      else
		      {
			  status = OSRStatusRepairOK();
		      }
		  }

		  // /sbin/lilo has to be executed after a new installation of lilo.rpm,
		  // no matter if /etc/lilo.conf changed or not!
		  if (!OSRLiloExecuteLilo())
		  {
		      status = OSRStatusRepairError();

		      y2debug("Execution of /sbin/lilo failed.");
		  }
		  else
		  {
		      status = OSRStatusRepairOK();
		  }
	      }
	      else
	      {
		  status = OSRStatusRepairError();

		  y2debug("Installing of lilo.rpm failed");
	      }
	  }
	  else
	  {
	      // !repair_question
	      status = OSRStatusRepairOmit();

	      // display the result in the RichText-widget
	      OSRSummaryRepairOmit(
			   module_name,
			   _("Installing the LILO package"),
			   _("Package not installed")
			   );
	  }
      }
      result_map = $[
		     "status"         : status,
		     "error_detected" : error_detected,
		     "error_repair"   : repair_question,
		     "error_keys"     : error_keys
      ];

      // set the value of the module-progress-bar to 100%
      OSRModuleProgress::Fill();
      
      return result_map;
  }

  /**
   *  Checks the configuration file lilo.conf for consistency.
   *
   *  @return map The result_map of this detection method.
   */
  global define OSRLiloConfTest() ``{

      boolean error_detected        = false;
      boolean repair_question       = false;
      integer result                = 1;
      integer progress_expect       = 600;
      string  module_name           = "osr_module_lilo";
      string  command               = "";
      string  help_text             = "";
      string  error_message         = "";
      string  progress_file         = "/tmp/osr_module_lilo_progress";
      string  progress_label        = "Checking LILO configuration file";
      string  log_file              = "";
      list    error_keys            = [];
      map     result_map            = $[];
      list    lilo_conf_list        = [];
      list    disk_device_list      = [];
      string  root_partition        = "";
      string  root_device           = "";
      string  boot_device           = "";
      string  lilo_conf_path        = "/etc/lilo.conf";
      string  status                = "";
      string  repair_target         = "";

      log_file = OSRLogFile::GetFile();

      OSRModuleProgress::SetParams(progress_label, progress_file, progress_expect);

      repair_target = OSRRequireString("repair_target");

      if (demo_mode)
      {
	  // set demo-value
	  result = 0;
      }
      else
      {
	  // check if the file /etc/lilo.conf exists
	  if (repair_target != "")
	  {
	      command = sformat("test -f %1%2", repair_target, lilo_conf_path);
	      result  = OSRExecuteCommand(command, log_file, .local);
	  }
	  else
	  {
	      command = sformat("test -f %1", lilo_conf_path);
	      result  = OSRExecuteCommand(command, log_file, .target);
	  }
      }

      // increase the value of the module-progress-bar
      OSRModuleProgress::Add(10);


      // TODO: launch the lilo-module if the user wants to create a new config-file!!!!

      
      if ( result != 0 )
      {
	  status = OSRStatusDetectError();

	  // error: the file /etc/lilo.conf doesn't exist
	  error_detected = true;

	  // display the results to the RichText-widget
	  OSRSummaryDetectError(
			  module_name,
			  _("Checking LILO configuration file"),
			  _("File does not exist at <code>/etc/lilo.conf</code>")
			  );

	  // set the value of the module-progress-bar to 100%
	  OSRModuleProgress::Fill();
	  
	  help_text = sformat(
				  _("The LILO configuration file does not exist at <code>%1</code>"),
				  lilo_conf_path
				  );
	  help_text = help_text + _("<p>If you use another file instead copy this to the standard location ");
	  help_text = help_text + _("and skip the following repair step. ");
	  help_text = help_text + _("Don't forget to run <code>/sbin/lilo</code>!</p>");
          help_text = help_text + _("<p>Press <b>Repair</b> to create a new configuration file.</p>");

	  error_message = sformat(
				  _("The LILO configuration file does not exist at %1.\n"),
				  lilo_conf_path
				  );
	  error_message = error_message + _("Repair creates a new configuration file.");

	  // launch the repair-popup, in automatic-mode no popup is launched and "true" is returned
          repair_question = OSRPopupRepair(_("Error detected"), error_message, help_text);

          // REPAIR
	  if (repair_question)
	  {
	      // TODO: make a copy of /etc/lilo.conf
	      //command = sformat("cp %1 /tmp/lilo.conf.orig", lilo_conf_path);
	      //OSRExecuteCommand(command, log_file);
	      // SCR(`Execute(.target.bash, command));
		   
	      // create a new LILO-configuration-file
	      if (!OSRLiloConfCreate())
	      {
		  status = OSRStatusRepairError();

		  y2debug("Creation of new lilo.conf failed.");

		  // copy the original lilo.conf to /etc/lilo.conf
		  //command = sformat("cp /tmp/lilo.conf.orig %1", lilo_conf_path);
		  //OSRExecuteCommand(command, log_file);
		  //SCR(`Execute(.target.bash, command));
	      }
	      else
	      {
		  status = OSRStatusRepairOK();
	      }

	      if (!OSRLiloExecuteLilo())
	      {
		  status = OSRStatusRepairError();

		  y2debug("Execution of /sbin/lilo failed.");
	      }
	      else
	      {
		  status = OSRStatusRepairOK();
	      }
	  }
	  else
	  {
	      // !repair_question
	      status = OSRStatusRepairOmit();
	      
	      // display the result in the RichText-widget
	      OSRSummaryRepairOmit(
			   module_name,
			   _("Creating LILO configuration file"),
			   _("Configuration file not repaired")
			   );

	  }
      }
      else
      {
	  status = OSRStatusDetectOK();

	  // the file /etc/lilo.conf exists
	  error_detected = false;

	  // display the results to the RichText-widget
	  OSRSummaryDetectOK(
		       module_name,
		       _("Checking LILO configuration file"),
		       sformat(
			       _("File exists at <code>%1</code>"),
			       lilo_conf_path
			       )
		       );

	  // increase the value of the module-progress-bar
	  OSRModuleProgress::Add(10);

	  if (demo_mode)
	  {
	      // demo-value
	      result = 0;
	  }
	  else
	  {
	      // execute a test-run of /sbin/lilo, if it succeeds, most of the config-file would be o.k.
	      command = "lilo -t -v";
	      result = OSRExecuteCommandProgress(command, log_file, .target, progress_file);
	  }

	  // increase the value of the module-progress-bar
	  OSRModuleProgress::Add(10);

	  if (result != 0)
	  {
	      status = OSRStatusDetectError();

	      error_detected = true;

	      // display the results in the RichText-widget
	      OSRSummaryDetectError(
			      module_name,
			      _("Checking LILO configuration file"),
			      _("<code>/sbin/lilo -t</code> reports an error")
			      );

	      // set the value of the module-progress-bar to 100%
	      OSRModuleProgress::Fill();
	  
	      help_text = _("<p>The command <code>/sbin/lilo -t</code> reported an error.</p>");
	      help_text = help_text + _("<p>Press <b>Repair</b> to create a new LILO configuration file.</p>");
	      
	      error_message = _("The command /sbin/lilo -t reported an error.\nRepair creates a new LILO configuration file.");

	      // launch the repair-popup
	      repair_question = OSRPopupRepair(_("Error detected"), error_message, help_text);

              // REPAIR
	      if (repair_question)
	      {
		  // TODO: make a copy of /etc/lilo.conf
		  //command = sformat("cp %1 /tmp/lilo.conf.orig", lilo_conf_path);
		  //OSRExecuteCommand(command, log_file);
		  // SCR(`Execute(.target.bash, command));
		      
		  // create a new LILO-configuration-file
		  if (!OSRLiloConfCreate())
		  {
		      status = OSRStatusRepairError();

		      y2debug("Creation of new lilo.conf failed.");

		      // TODO: copy the original lilo.conf to /etc/lilo.conf
		      //command = sformat("cp /tmp/lilo.conf.orig %1", lilo_conf_path);
		      //OSRExecuteCommand(command, log_file);
		      //SCR(`Execute(.target.bash, command));
		  }
		  else
		  {
		      status = OSRStatusRepairOK();
		  }

		  if (!OSRLiloExecuteLilo())
		  {
		      status = OSRStatusRepairError();

		      y2debug("Execution of /sbin/lilo failed.");
		  }
		  else
		  {
		      status = OSRStatusRepairOK();
		  }

	      }
	      else
	      {
		  // !repair_question
		  status = OSRStatusRepairOmit();
		  
		  // display the result in the RichText-widget
		  OSRSummaryRepairOmit(
				       module_name,
				       _("Creating LILO configuration file"),
				       _("Configuration file not repaired")
				       );
	      }
	  }
	  // TODO
	  //else if (result == 127)
	  //{
	      // command not found: /sbin/lilo, maybe package not installed

	  //}
	  else
	  {
	      status = OSRStatusDetectOK();

	      error_detected = false;

	      // display the results in the RichText-widget
	      OSRSummaryDetectOK(
			   module_name,
			   _("Checking LILO configuration file"),
			   _("<code>/sbin/lilo -t</code> reports no errors")
			   );

	      if (demo_mode)
	      {
		  // demo-value
		  boot_device = "/dev/hda";
	      }
	      else
	      {
		  // TODO: use a better agent
		  lilo_conf_list = SCR::Read(.etc.liloconf1, ["/mnt" + lilo_conf_path]);
		  boot_device    = lookup(find(`n, lilo_conf_list, ``(lookup(n, "key", "") == "boot")), "value", "");
	      }
	      
	      OSRModuleProgress::Add(10);
	      
	      if (boot_device == "" || boot_device == nil)
	      {
		  status = OSRStatusDetectError();

		  // from man 5 lilo.conf:
		  // boot=<boot-device>
		  //    Sets the name of the device (e.g. a hard disk partition) that contains the
		  //    boot sector. If this keyword is omitted, the boot sector is read from (and
		  //    possibly written to) the device that is currently mounted as root.
		  error_detected = true;

		  // display the results in the RichText-widget
		  OSRSummaryDetectError(
				  module_name,
				  _("Checking LILO configuration file"),
				  _("No boot-device specified")
				  );

		  // increase the value of the module-progress-bar
		  OSRModuleProgress::Add(10);

		  help_text = _("<p>In the LILO configuration file no boot device is specified.</p>");
		  help_text = help_text + _("<p>Press <b>Repair</b> to create a new LILO configuration file.</p>");

		  error_message = _("In the LILO configuration file no boot device is specified.\n");
		  error_message = _("This may not be an error.\n");
		  error_message = error_message + _("Press Repair to create a new LILO configuration file.");

		  // launch the repair-popup
		  repair_question = OSRPopupRepair(_("Error detected"), error_message, help_text);

		  // REPAIR
		  if (repair_question)
		  {
		      // get the list of disk-devices
		      disk_device_list = OSRRequireList("disk_device_list");

		      // increase the value of the module-progress-bar
		      OSRModuleProgress::Add(10);

		      // get the device of the root-partition and cut the partition number
		      root_partition = OSRRequireString("root_partition");
		      root_device    = select(splitstring(root_partition, "1234567890"), 0);

		      // set the value of the module-progress-bar to 100%
		      OSRModuleProgress::Fill();

		      // TODO: make a copy of /etc/lilo.conf
		      //command = sformat("cp %1 /tmp/lilo.conf.orig", lilo_conf_path);
		      //OSRExecuteCommand(command, log_file);
		      //SCR(`Execute(.target.bash, command));
		      // create a new LILO-configuration-file with the current root-device as value for
		      // the boot-device
		      if (!OSRLiloConfCreateBootDevice(root_device))
		      {
			  status = OSRStatusRepairError();

			  y2debug("Creation of new lilo.conf failed.");

			  // TODO: copy the original lilo.conf to /etc/lilo.conf
			  //command = sformat("cp /tmp/lilo.conf.orig %1", lilo_conf_path);
			  //OSRExecuteCommand(command, log_file);
			  //SCR(`Execute(.target.bash, command));
		      }
		      else
		      {
			  status = OSRStatusRepairOK();
		      }
		      
		      if (!OSRLiloExecuteLilo())
		      {
			  status = OSRStatusRepairError();
		      }
		      else
		      {
			  status = OSRStatusRepairOK();
		      }
		  }
		  else
		  {
		      // !repair_question
		      status = OSRStatusRepairOmit();

		      // display the result in the RichText-widget
		      OSRSummaryRepairOmit(
					   module_name,
					   _("Creating LILO configuration file"),
					   _("Configuration file not repaired")
					   );
		      
		  }
	      }
	      else
	      {
		  status = OSRStatusDetectOK();

		  error_detected = false;

		  // display the results in the RichText-widget
		  OSRSummaryDetectOK(
			       module_name,
			       _("Checking LILO configuration file"),
			       sformat(
				       _("Boot-device: <code>%1</code>"),
				       boot_device
				       )
			       );

		  // increase the value of the module-progress-bar
		  OSRModuleProgress::Add(10);
	      }
	  }
      }

      // set the value of the module-progress-bar to 100%
      OSRModuleProgress::Fill();
      
      result_map = $[
		     "status"         : status,
		     "error_detected" : error_detected,
		     "error_repair"   : repair_question,
		     "error_keys"     : error_keys
      ];
      return result_map;
  }

  //////////////////////////////////////////////////////////////////////
  //
  //  REPAIR METHODS
  //
  //////////////////////////////////////////////////////////////////////

  /**
   *  Installs the lilo package lilo.rpm.
   * 
   *  @return boolean True if the repair process was successful.
   */
  global define OSRLiloPackageInstall() ``{

      integer result          = 1;
      integer progress_expect = 50;
      string  log_file        = "";
      string  command         = "";
      string  progress_label  = "Installing LILO package";
      string  progress_file   = "/tmp/osr_module_lilo_install.log";
      string  module_name      = "osr_module_lilo";
      boolean mount_ok        = false;
      boolean error_detected  = false;

      // TODO: check for old installation source media: cdrom, ftp, www, /work4, ...
      //       check mount, check for installation dir, ...
      //mount_ok = ChangeCD( 1, true );
      log_file = OSRLogFile::GetFile();

      // setting up the progress bar
      OSRModuleProgress::SetParams(progress_label, progress_file, progress_expect);

      // install the lilo package
      //command = "/bin/rpm -hU --force /tmp/lilo.rpm";
      //result  = OSRExecuteCommandProgress(command, log_file, progress_file);

      string tmpdir   = SCR::Read(.target.tmpdir);
      string filename = tmpdir + "/sw_single_input";
      SCR::Write(.target.ycp, filename, $["install":["lilo"], "userInput" : false ]);
      symbol res_symbol = CallFunction (`inst_sw_single(`single, `not_only_checked));

      y2error("result: %1", res_symbol);

      // TODO: get the result from sw_single
      result = 0;
      
      if (result == 0)
      {
	  error_detected = false;
	  
	  OSRSummaryRepairOK(
			   module_name,
			   _("Installing the LILO package"),
			   _("Installation succeeded")
			   );
      }
      else
      {
	  error_detected = true;

	  OSRSummaryRepairError(
			  module_name,
			  _("Installing the LILO package"),
			  _("Installation was not successfull")
			  );
      }

      return (result == 0);
  }

  /**
   *  Creates a new lilo configuration file at /etc/lilo.conf.
   *
   *  @return boolean True if the repair process was successful.
   */
  global define OSRLiloConfCreate() ``{

      integer result           = 1;
      integer progress_expect  = 1200;
      string  log_file         = "";
      string  command          = "";
      string  progress_label   = "Creating LILO configuration file";
      string  progress_file    = "/tmp/dolilo.log";
      string  boot_device      = "";
      string  root_partition   = "";
      string  root_device      = "";
      string  module_name      = "osr_module_lilo";
      list    disk_device_list = [];
      boolean error_detected   = false;

      log_file = OSRLogFile::GetFile();
      
      command = "rm -f /tmp/dolilo.log";
      OSRExecuteCommand(command, log_file, .target);

      // setting up the progress bar
      OSRModuleProgress::SetParams(progress_label, progress_file, progress_expect);

      // TODO: get the boot-device, eventually from user
      disk_device_list = OSRRequireList("disk_device_list");
      root_partition   = OSRRequireString("root_partition");

      // cut the partition number off the root partition
      root_device = select(splitstring(root_partition, "1234567890"), 0);

      // figure out the boot device name where lilo should be installed,
      // as default the boot device is the one with the root partition inside,
      // TODO: user selection of the boot device
      //       - the entry in the old lilo.conf
      //       - user selection
      //       - the device with the root partition into it
      //       - floppy??
      if (size(disk_device_list) == 1)
      {
	  boot_device = select(disk_device_list, 0, "");
	  if (boot_device != root_device)
	  {
	      y2error("OSRLiloConfCreate ERROR: boot_device != root_device ??: %1 %2", boot_device, root_device);
	  }
      }
      else
      {
	  integer i          = 0;
	  boolean is_element = false;
	  while (i >= 0 && i < size(disk_device_list))
	  {
	      if (root_device == select(disk_device_list, i, ""))
	      {
		  is_element = true;
		  break;
	      }
	      i = i + 1;
	  }
	  if (!is_element)
	  {
	      if (automatic_mode)
	      {
		  boot_device = OSRPopupSelectItem(
						   _("LILO boot device"),
						   _("You have to select one of the devices"),
						   disk_device_list,
						   "",
						   true
						   );
	      }
	      else
	      {
		  // TODO: is this true??
		  boot_device = root_device;
	      }
	  }
	  else
	  {
	      boot_device = root_device;

	      // TODO: ask the user??
	      /*
		boot_device = OSRPopupSelectItem(
		UI(_("LILO boot device")),
		UI(_("You have to select one of the devices")),
		disk_device_list,
		root_device
		);
	      */
	  }
      }
      // execute the command and get the exit code
      command  = sformat("/usr/lib/YaST2/bin/dolilo / -m %1 -v", boot_device);
      result   = OSRExecuteCommand(command, progress_file, .target);
      
      command  = "cat /tmp/dolilo.log";
      OSRExecuteCommand(command, log_file, .target);

      if (result == 0)
      {
	  error_detected = false;
	  
	  OSRSummaryRepairOK(
			   module_name,
			   _("Creating new LILO configuration file"),
			   _("Creation succeeded")
			   );
      }
      else
      {
	  error_detected = true;

	  OSRSummaryRepairError(
			  module_name,
			  _("Creating new LILO configuration file"),
			  _("Creation was not successfull")
			  );
      }
      
      return (result == 0);
  }

  /**
   *  Creates a new lilo configuration file at /etc/lilo.conf with the specified
   *  boot-device.
   *
   *  @param string The new boot-device.
   *  @return boolean True if the repair process was successful.
   */
  global define OSRLiloConfCreateBootDevice(string boot_device) ``{

      integer result           = 1;
      integer progress_expect  = 1200;
      string  log_file         = "";
      string  command          = "";
      string  progress_label   = "Creating LILO configuration file";
      string  progress_file    = "/tmp/dolilo.log";
      string  root_partition   = "";
      string  module_name      = "osr_module_lilo";
      list    disk_device_list = [];

      log_file = OSRLogFile::GetFile();
      
      command = "rm -f /tmp/dolilo.log";
      OSRExecuteCommand(command, log_file, .target);

      // setting up the progress bar
      OSRModuleProgress::SetParams(progress_label, progress_file, progress_expect);
      
      // execute the command and get the exit code
      command  = sformat("/usr/lib/YaST2/bin/dolilo / -m %1 -v", boot_device);
      result   = OSRExecuteCommand(command, progress_file, .target);

      command  = "cat /tmp/dolilo.log";
      OSRExecuteCommand(command, log_file, .target);

      if (result == 0)
      {
	  error_detected = false;
	  
	  OSRSummaryDetectOK(
		       module_name,
		       _("Creating new LILO configuration file"),
		       _("Creation succeeded<br>
New configuration file is <code>/etc/lilo.conf</code>")
		       );
      }
      else
      {
	  error_detected = true;

	  OSRSummaryDetectError(
			  module_name,
			  _("Creating new LILO configuration file"),
			  _("Creation was not successfull<br>
Resetting old configuration")
			  );
      }

      return (result == 0);
  }
  
  /**
   *  Installs the bootloader. The command /sbin/lilo reads the configuration file
   *  at /etc/lilo.conf.
   *
   *  @return boolean True if the repair process was successful.
   */
  global define OSRLiloExecuteLilo() ``{

      integer result          = 1;
      integer progress_expect = 600;
      string  command         = "";
      string  log_file        = "";
      string  progress_label  = _("Installing LILO bootloader");
      string  progress_file   = "/tmp/osr_module_lilo_progress";
      string  module_name      = "osr_module_lilo";

      log_file = OSRLogFile::GetFile();

      // setting up the progress bar
      OSRModuleProgress::SetParams(progress_label, progress_file, progress_expect);

      // execute the lilo-command and display the progress
      command = "/sbin/lilo -v";
      result  = OSRExecuteCommandProgress(command, log_file, .target, progress_file);
      
      if (result == 0)
      {
	  error_detected = false;
	  
	  OSRSummaryRepairOK(
			   module_name,
			   _("Executing LILO"),
			   _("Execution of LILO succeeded<br>
New bootloader installed")
			   );
      }
      else
      {
	  error_detected = true;

	  OSRSummaryRepairError(
			  module_name,
			  _("Executing LILO"),
			  _("Execution of LILO was not successfull<br>
You have to run <code>/sbin/lilo</code> manually")
			  );
      }

      
      // set the value of the module-progress-bar to 100%
      OSRModuleProgress::Fill();
      
      return (result == 0);
  }

  //////////////////////////////////////////////////////////////////////
  //
  //  MAIN
  //
  //////////////////////////////////////////////////////////////////////

  // in init-mode only execute the init-function and return the module-map
  // to the framework, don't delete
  if (init_mode)
  {
      map module_map = OSRLiloInit();

      return module_map; 
  }
  // end MAIN
}
