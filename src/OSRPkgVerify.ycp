/**
 * File:	OSRPkgVerify.ycp
 * Module:	repair
 * Summary:	Packages check
 * Authors:	Johannes Buchhold <jbuch@suse.de>
 *
 * $Id$
 *
 * Provide osr mode information.
 */

{
    module "OSRPkgVerify";

    textdomain "repair";

    import "OSRPkgUI";
    import "OSRPkg";
    import "OSRExecute";
    import "OSRLogFile";
    import "OSRMode";


    /**
     * Missing key. For parsing rpm output.
     */
    global string missing    		 = "missing";

    /**
     * Unsatisfied key. For parsing rpm output.
     */
    global string unsatisfied 		 = "Unsatisfied dependencies for";

    /**
     * Rpm symbol for all tests.
     */ 
    string all_tests 		= "SM5DLUGT";

    /**
     * All allowed rpm test options.
     */
    string possible    		 = "5SLTDUGM?.";

    /**
     * Key seperate packagename with not valid file count.
     */
    global string separator             = "____KEY____";

    
    
    //  
    map unimportant_file_problems = $[
				      "file_type" : $[ ".log" 		: [ all_tests          ],
						       ".html"		: [ all_tests, missing ],
						       ".png"   	: [ all_tests 	       ],
						       ".protocol" 	: [ all_tests	       ]
				      ],
				      "directory" : $[ "/usr/share/doc" : [ all_tests, missing ],
						       "/var/log"	: [ all_tests	       ],
						       "/var/cache"	: [ all_tests	       ],
						       "/usr/share/man" : [ all_tests, missing ],
						       "/usr/X11R6/man" : [ all_tests, missing ],
						       "/usr/share/man" : [ all_tests, missing ],
						       "/usr/share/info": [ all_tests, missing ],
						       "/var/spool"	: [ all_tests	       ],
						       "/dev"		: [ "MUG..."           ]
						       //"etc"		: [ "..." ]
				      ],
				      "config_file" : $[ "all"		: [ "SM5....T" 	       ]
				      ],
				      "you-installed" : $[ "/var/lib/YaST2/you/installed" : [ all_tests ]
				      ],
				      "build_problems" : $[ "all"	: []]
    ];

    global map unimportant2help = $[
				    "file_type" 	: _("The file is a noncritical type."),
				    "directory"		: _("The file is located in a noncritical directory."),
				    "config_file"	: _("The file is a configuration file."),
				    "you_installed"	: _("The package has been updated with the online update."),
				    "build_problems"    : _("The test failure seems to be caused by an incorrectly built package.")
    ];
    
    
    /**
     * Data of all verified packages.
     */
    global map  verified_packages	 = $[];

    global list(string) not_successful_verified  = []; 
    /**
     * Verified packages after a new installation.
     */
    global map initial_verified_packages = $[];

    
    global map update_problems_map	 = $[];
 

    /**
     *
     */
    global define void Reset()``{
	verified_packages 	= $[];
	not_successful_verified = [];
    }
    
    
    global define void OSRPkgVerify()``{
	initial_verified_packages = CallFunction(`osr_verified_packages());
	Reset();
    }


    
    define void	build_update_problems_map()``{

	if( update_problems_map == $[] || update_problems_map == nil )
	{
	    foreach(string dir, list(string) allowed_erros, unimportant_file_problems["you-installed" ]:$[], ``{
		list(string) you_installed_pkgs =  SCR::Read(.target.dir, dir );

		if( you_installed_pkgs == nil || you_installed_pkgs == [] )
		{
		    return;
		}
		
		foreach(string patch_file, you_installed_pkgs, ``{
		    string file  = SCR::Read(.target.string , dir + "/" + patch_file);
		    list(string) lines   = filter(string line,  splitstring( file, "\n"),
					      ``( substring( line , 0, size("Filename:")) == "Filename:" ));

		    foreach(string line, lines, ``{
			line = substring( line, size("Filename:"));
			line = mergestring( splitstring( line, " "), "");
			if( issubstring( line, ".rpm") || issubstring( line, ".RPM" ))
			    line = substring( line, 0,size(line) - size(".rpm"));
		    //y2milestone(" line : %1" , line );
			if( line != nil && line != "" )
			{
			    update_problems_map[ line ] = allowed_erros;
			}
		    });
		});
	    });
	}
	y2milestone(" update_problems packages %1", update_problems_map );
    }
    
   

    
    define boolean check_allowed( list(string) allowed_erros, string status )``{
	y2milestone("check allowed: all allowed: %1 current status %2", allowed_erros, status);
	boolean found = false;
	foreach(string allowed, allowed_erros, ``{

	    if( allowed == missing && status == missing ||
		allowed != missing && size ( deletechars(  status, allowed + "." )) == 0   )
	    {
		found = true;
		return;
	    }
	});
	y2milestone("allowd : %1", found);
	return found;
    }

    /**
     *
     */
    define string unimportant_file_type( string file, string status )``{
	boolean found = false;
	foreach( string type, list(string) allowed_erros , unimportant_file_problems["file_type"]:$[], ``{
	    if( size(file) > size(type) && substring( file, size(file) - size(type)) == type )
	    {
		if ( check_allowed( allowed_erros, status )) 
		{
		    found = true;
		    return;
		}
	    }
	});
	return ( found ) ? "file_type" : "";
    }

    /**
     *
     */
    define string unimportant_directory( string file, string status )``{
	boolean found = false;
	foreach( string dir, list(string) allowed_erros,  unimportant_file_problems["directory"]:$[] , ``{
	    if( substring( file, 0, size(dir)) == dir )
	    {
		if ( check_allowed( allowed_erros, status )) 
		{
		    found = true;
		    return;
		}	
	    }
	});
	return ( found ) ? "directory" : "";
    }


    /**
     *
     */
    define string config_file_allowed( map pkg_data ) ``{
	if ( ! pkg_data["config_file"]:false ) return "";
	return (( check_allowed( unimportant_file_problems["config_file","all"]:[], pkg_data["status"]:"" ) ) ? "config_file" : "");
    }
    
    /**
     *
     */
    define string update_problems( string pkg_name , string file, string status  )``{
	boolean found = false;

	map you_installed =  filter( string you_installed_pkg, list(string) allowed_erros, update_problems_map, 
				      ``( substring(you_installed_pkg,0, size( pkg_name)) == pkg_name ));

	foreach( string you_installed_pkg, list(string) allowed_erros, you_installed, ``{
	
	    if( check_allowed( allowed_erros, status ))
	    {
		found = true;
		return;
	    }
	});
	    
	return ( found ) ? "you-installed" : "";
    }

    
    /**
     *
     */
    define string build_problems( string pkg_name, map pkg_data )``{
	
	map org_data =  initial_verified_packages[pkg_name]:$[];
	if ( size( filter(string key, map d, org_data, ``( d == pkg_data ))) > 0 )
	{
	    return "build_problems";
	}
	return "";
    }


    /**
     * Return if a package was not build correctly.
     */
    global define string GreenPackageProblems(string pkg_name, map pkg_data )``{

	if( haskey( pkg_data , "green_status" )) return pkg_data["green_status"]:"";

	string green_status =  ""; 

	// set config files to green status
	if ( green_status == "" )
	    green_status = config_file_allowed( pkg_data  );

	if ( green_status == "" )
	    green_status = update_problems( pkg_name, pkg_data["file"]:"", pkg_data["status"]:"" );

	if ( green_status == "" )
	    green_status = unimportant_file_type( pkg_data["file"]:"" , pkg_data["status"]:"" );

	if ( green_status == "" )
	    green_status = unimportant_directory( pkg_data["file"]:"" , pkg_data["status"]:"" );

	if ( green_status == "" )
	    green_status = build_problems( pkg_name,  pkg_data );

	if ( green_status != "" )
	{
	    y2milestone("Found green package problems. Name of package: %1 Type: %2 File: %3 ",
			pkg_name, green_status , pkg_data["file"]:"");
	}

	return green_status;
    }

    /**
     * Convert rpm output to a map.
     * @param pkg_name The package name e.g.: filesystem
     * @param verify_output_string The rpm output: .....UG.   /etc/cups
     *                                             .M......   /proc
     *					   
     * @return  e.g.: $["filesystem____KEY____1":
     *                                      $["config_file":false,
     *					      "file":"/etc/cups",
     *					      "status":".....UG."
     *					      ],
     *                  "filesystem____KEY____2"   :$["config_file":false, "
     *		                               file":"/proc",
     *					       "status":".M......"]]	
     *
     *					   
     */
    define boolean convert_verify_outpunt(string pkg_name, string verify_output_string )``{
	
	integer	 key                    = 0;
	map verify_data           	= $[];
	list(string) verify_output_list = splitstring(verify_output_string , "\n");
	integer build_problem_counter   = 0;
	integer verify_output_counter   = 0;
	
	foreach(string verify_output, verify_output_list, ``{
	    
	    if( size( verify_output ) > 1 ) 
	    {
		verify_output_counter = verify_output_counter  +1 ;
		key = key +1 ;
		string pkg_key =  sformat("%1%2%3", pkg_name,separator, key );
		if( substring (verify_output, 0, size(missing) )  == missing )
		{
		    verify_data[ pkg_key ]  = $[
			"config_file"  : issubstring (
			    substring(verify_output,size(missing), findfirstof(verify_output, "/") - size(missing)),
			    "c" ),
			"file"	: substring(
			    verify_output, findfirstof(verify_output, "/")),
		      "status"	: missing
		    ];
		}
		else if( substring(verify_output, 0, size(unsatisfied )) == unsatisfied )
		{
		    verify_data[ pkg_key ] =
		    $[ "config_file" : false,
		       "file"	: substring(verify_output, size(unsatisfied)),
		       "status"	: unsatisfied
		    ];
		}
		else if( findfirstnotof(substring(verify_output,0,8), possible ) == nil )
		{
		    verify_data[ pkg_key ] =
		    $[ "config_file": issubstring(substring(verify_output, 8, findfirstof(verify_output, "/") - 8 ), "c" ),
		       "file"	: substring(verify_output, findfirstof(verify_output, "/")),
		       "status"	: substring(verify_output, 0,8)
		    ];
		}
		else
		{
		    y2error(" not known output");
		    verify_data[pkg_key] =  $[ "status" : "unknown" ];
		}
		verify_data[pkg_key, "green_status"] = GreenPackageProblems( pkg_name, verify_data[pkg_key]:$[]);

		if( verify_data[pkg_key, "green_status"]:"" != "" )
		{
		    build_problem_counter = build_problem_counter +1;
		}
	    }
	});

	verified_packages[ pkg_name ] = verify_data;

	// return false if the package was not verified successfully.
	return ( build_problem_counter == verify_output_counter ||
		 ( build_problem_counter == 0 && size( verify_output_string ) <= 1 ));
    }
    
    
    /**
     * A a new package summary to the dialog
     * and repaint the text.
     */
    define boolean add_package_summary(string pkg_name , string verify_output )``{

	boolean package_ok = convert_verify_outpunt( pkg_name, verify_output );
	if( ! package_ok ) not_successful_verified = add( not_successful_verified, pkg_name );
	
	OSRPkgUI::AddPackageSummary( pkg_name, verified_packages[ pkg_name]:$[] );
	
	
	return package_ok;
    }


    
    /**
     *
     */
    global define boolean Verify( string p ) ``{

	build_update_problems_map();

	y2milestone("-----------verifying package %1", p );

	OSRExecute::CommandOutput(.local.bash,  sformat("LANG=ENG /bin/rpm --root %2 -V %1", p, OSRPkg::root_mountpoint ));

	y2milestone("-----------package %1 verified", p);

	return add_package_summary( p, OSRExecute::stdout );
    }



    /**
     * Debug the verified packages informations.
     */
    global define boolean WriteVerifiedPackages( list installed, boolean debug )``{
	string ypath  = OSRLogFile::GetTmpDir()+ "/initial_verified_packages";
	string spath  = OSRLogFile::GetTmpDir()+ "/initial_verified_packages_text";

	if ( OSRMode::save )
	{
	    y2milestone("Try to save data of all verified packages");
	    //if( size(installed) == size(verified_packages))
	    //{
		y2milestone("All packages were verified. Saveing data ..");
		// not ok packages
		map t_verified_packages = filter(string pkg_name, map data, verified_packages, ``( data != $[] ));

		// write as text file!!
		foreach( string pkg_name, map pkg_data, t_verified_packages, ``{

		    WFM::Execute(.local.bash, sformat("/bin/echo %1 >> %2", pkg_name, spath));
		    foreach( string key, map file_data, pkg_data, ``{
			
			WFM::Execute(.local.bash, sformat("/bin/echo \"  %1  %2  %3\" >> %4", file_data["status"]:"",
							  ( file_data["config_file"]:false) ? "c" : " ",
							  file_data["file"]:"" , spath ));
		    });
		});

		// write as ycp-file
		return WFM::Write(.local.ycp , ypath , t_verified_packages) == 0;
		
	}
	
	if( debug )  return WFM::Write(.local.ycp , ypath , verified_packages) == 0;
	return true;
    }
}
