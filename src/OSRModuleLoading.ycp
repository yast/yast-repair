/**
 *  File:
 *    OSRModuleLoading.ycp
 *
 *  Module:
 *    OSRModuleLoading
 *
 *  Summary:
 *    Load and unload kernel modules
 *	
 *  Author:
 *    Johannes Buchhold <jbuch@suse.de>
 *
 * $Id$
 */
{
  module "OSRModuleLoading";
 
  import "ModuleLoading";
  
  textdomain "repair";

  /**
   * Contains a list with the name of all kernel modules loaded at the first import
   * of the OSRModuleLoading module.
   */
  list(string) startup_loaded_modules 	= [];

  /**
   * Contains a list with the name of all kernel modules loaded with
   * the Load define (OSRModuleLoading::Load(..); .
   */
  list(string) loaded_modules 		= [];

  /**
   * The constructor init the startup_loaded_modules list.
   */
  global define OSRModuleLoading()``{
      startup_loaded_modules = maplist(`key,`map, SCR::Read(.proc.modules), ``(key));
  }
  
  /**
   * @param	string modulename
   * @param	string moduleargs
   * @param	string vendorname
   * @param	string devicename
   * @param	boolean ask_before_loading
   * @param	boolean with_modprobe
   *
   * @returns symbol:	`dont	user choose *not* to load module
   *			`ok	module loaded ok
   *			`fail	module loading failed
   *
   * Load a module if not already loaded by linuxrc and
   * saves the name of the loaded modules in the list
   * loaded_modules.
   */
  global define boolean Load( string modulename, string moduleargs,
			      string vendorname, string devicename,
			      boolean ask_before_loading, boolean with_modprobe ) ``{

      // always look whether the module is already loaded
y2warning ("modules: %1", SCR::Read(.proc.modules));
      map current_modules = SCR::Read(.proc.modules);
      if (size (current_modules[modulename]:$[]) > 0)
      {
	  // already loaded
	  return true;
      }
      else {

	  if( ModuleLoading::Load( modulename, moduleargs, vendorname, devicename, ask_before_loading, with_modprobe ) == `ok )
	  {
	      loaded_modules = add( loaded_modules, modulename );
	      return true;
	  }
	  else return false;
      }
  }

  
  /**
   * Unload one kernel module.
   * @param modulename name of the kernel module that should be unloaded
   */
  global define boolean Unload(string modulename ) ``{
if (modulename == "") return true;
      if ( WFM::Execute(.local.bash, sformat("/sbin/rmmod %1",modulename) ) != 0 ) {
	  y2error("Can't remove module %1", modulename );
	  return false;
      }
      return true;
  }


  /**
   * Unload all loaded kernel modules.
   */
  global define boolean UnloadAll()``{
      integer index = size(loaded_modules );
      boolean error = false;

      // unload all with OSR code loaded modules
      while ( index != 0 && ! error  ) {
	  if( ! Unload( loaded_modules[index - 1]:"" )) error = true;
	  else {
	      index = index - 1;
	  }
      }

      // unload all with other code loaded modules
      list(string) end_loaded_modules = maplist(`key,`map, SCR::Read(.proc.modules), ``(key));
      list(string) unload_modules     = filter(`key, end_loaded_modules, ``( ! contains( startup_loaded_modules, key )));
      integer unload_count    = size( unload_modules );
      index = 0;

      // JOETODO fix unload_count 
      while ( index < unload_count ) {
	  if ( Unload( unload_modules[index]:"" ))
	  {
	      unload_modules = remove( unload_modules, index);
	  }
	  index = index + 1;
      }

      if ( ! error ) error = ( size( unload_modules) != 0 );

      return ! error;
  }

  
}
