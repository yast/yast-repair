/**
 * File:
 *   osr_module_finish.ycp
 *
 * Module:
 *   YaST2 OS Repair finish module.
 *
 * Summary:
 *   This module contains methods that have to be executed after the detection
 *   and repair modules were running. The execution of this module is for exiting
 *   the rescue system with a cleaned-up Linux system.
 *
 * Author:
 *   Michael Koehrmann <curry@suse.de>
 *
 * $Id$
 */

{
  textdomain "repair";

  integer arg_c = size(Args());
  integer arg_n = 0;

  boolean init_mode = false;

  while ( arg_n < arg_c )
  {
      if ( Args(arg_n) == .init )
      {
	  init_mode = true;

	  y2milestone("Argument: %1", Args(arg_n));
      }
      else
      {
	  y2error("ERROR: unknown option %1", Args(arg_n) );

	  return $[];
      }
      arg_n = arg_n + 1;
  }

  //////////////////////////////////////////////////////////////////////
  //
  //  METHODS
  //
  //////////////////////////////////////////////////////////////////////

  /**
   *  Initialization of the module map that contains all important information
   *  for this module.
   *
   *  @return map The map that contains all information about the module osr_module_finish.
   */
  define OSRFinishInit() ``{

      y2debug("OSRFinishInit");

      map  osr_module_finish = $[];

      osr_module_finish = $[
		   "name"           :  "osr_module_finish",
		   "headline"       :  _("Finishing"),
		   "summary"        :  [],
		   "test_mode_summary" : [
					  $["header" : "Finish", "description" : "o.k.", "error" : false],
		   ],
		   "detect_methods" :  [
					``(OSRFinishUmount())
		   ],
		   "provides"       : $[],
		   "requires"       :  [ "just_mounted" ],
		   "progress_file"  : "/tmp/osr_module_finish_progress",
		   "progress_expect" : 1000
      ];
      
      return osr_module_finish;
  };

  //////////////////////////////////////////////////////////////////////
  //
  //  DETECTION METHODS
  //
  //////////////////////////////////////////////////////////////////////

  /**
   *  Umount all partitions that were mounted by the rescue system in earlier stages.
   *
   *  Requires: list just_mounted
   *
   *  @return map The result map.
   */
  global define OSRFinishUmount() ``{

      string  status                  = "";
      list    just_mounted = [];

      // list of partition/mounpoint pairs of the partitions that were mounted by the rescue system
      just_mounted = OSRRequireList("just_mounted");

      // umount the just mounted partitions in the reversed order of mounting them, umount always the
      // last element in the list and delete it from the list.
      while (size(just_mounted) > 0)
      {
	  map    last_element = select(just_mounted, (size(just_mounted) -1), "");
	  string partition    = lookup(last_element, "partition", "");
	  string mountpoint   = lookup(last_element, "mountpoint", "");

	  if (last_element != "")
	  {
	      // umount the selected partition from the system
	      boolean umount = SCR::Execute(.target.umount, mountpoint);

	      if (umount)
	      {
		  status = OSRStatusDetectOK();

		  OSRSummaryDetectOK(
				     module_name,
				     sformat(_("Umounting partition %1 from %2"), partition, mountpoint),
				     _("Umount succeeded")
				     );
	      }
	      else
	      {
		  status = OSRStatusDetectProblem();

		  OSRSummaryDetectProblem(
					module_name,
					sformat(_("Umounting partition %1 from %2"), partition, mountpoint),
					_("Umount failed")
					);
	      }
	      // remove the last element from the list
	      just_mounted = remove(just_mounted, (size(just_mounted) -1));
	  }
      }
      status = OSRStatusDetectOK();
      
      return $[ "status" : status ];
  }

  //////////////////////////////////////////////////////////////////////
  //
  //  MAIN
  //
  //////////////////////////////////////////////////////////////////////
  
  if (init_mode)
  {
      map test_map = OSRFinishInit();
      //SCR::Write(.dumpto.tmp.osr_module_finish, test_map);

      return test_map; 
  }
}
