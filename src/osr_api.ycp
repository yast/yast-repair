 /**
 *  File:
 *    osr_api.ycp
 *
 *  Module:
 *    YaST2 OS Repair - automatic error detection & repair tool for Linux.
 *
 *  Summary:
 *    This file provides the api functions of the YaST2 OS Repair tool that can be used
 *    by the error detection and repair modules.
 *
 *  Author:
 *    Michael Koehrmann <curry@suse.de>
 *
 * $Id$
 */
{
  textdomain "osr";
  import "Storage";
  
  /**
   *  Executes the given commandline in a bash and writes all execution-information
   *  to the standard log file. This function returns all output from the commandline
   *  in a result map. Use these functions instead of directly calling the SCR or WFM
   *  agents (e.g. SCR::Execute(.target.bash_output, "rpm -q lilo") resp.
   *  WFM::(.local.bash_output, "rpm -q -r /mnt lilo")) to be sure to support logging
   *  correctly.
   *
   *  API function.
   *
   *  @param path environment The environment-path, has to be .local.bash_output or
   *         .target.bash_output (or .local.bash resp. .target.bash)
   *  @param string commandline The commandline.
   *  @return map The result map with all output from the command.
   *  @example map result_map = OSRExecuteCommandOutput(.local.bash_output, "rpm -qi -r /mnt/ lilo");
   */
  global define OSRExecuteCommandOutput(path environment, string commandline) ``{

      map     result_map  = $[];
      integer result      = 0;
      string  command     = "";
      string  demo_string = "";
      string  stdout      = "";
      string  stderr      = "";

      // TODO: in demo-mode set "echo" in front of every commandline
      if (demo_mode) demo_string = "echo";

      // write the commandline to the log file and execute the command
      command     = commandline;

      // accept also .local.bash and .target.bash as parameter
      if (environment == .local.bash)
      {
	  environment = .local.bash_output;
      }
      else if (environment == .target.bash)
      {
	  environment = .target.bash_output;
      }
      
      if (environment == .local.bash_output)
      {
	  result_map = WFM::Execute(.local.bash_output, commandline);
      }
      else if (environment == .target.bash_output)
      {
	  result_map = SCR::Execute(.target.bash_output, commandline);
      }
      else
      {
	  y2error(sformat("OSRExecuteCommandOutput ERROR: wrong environment \"%1\", has to be .local.bash_output or .target.bash_output",
			  environment));
	  return $[];
      }
      
      //result_map  = SCR::Execute(.target.bash_output, commandline);
      result      = lookup(result_map, "exit", 0);
      stdout      = lookup(result_map, "stdout", "");
      stderr      = lookup(result_map, "stderr", "");

      OSRLogFile::Add(sformat("Command: %1\nstdout: %2stderr: %3exit: %4\n", command, stdout, stderr, result));
	
      if ( result == 0 )
      {
	  y2debug("OSRExecuteCommandOutput: command succeeded: %1", result);
      }
      else if ( result == 126 )
      {
	  y2debug("OSRExecuteCommandOutput: command found but not executable: %1", result);
      }
      else if ( result == 127 )
      {
	  y2debug("OSRExecuteCommandOutput: command not found: %1", result);
      }
      else if ( result >= 128 )
      {
	  y2debug("OSRExecuteCommandOutput: command terminates with fatal sign N (N=%1-128): %1", result);
      }
      else
      {
	  y2debug("OSRExecuteCommandOutput: command terminates with error code %1", result);
      }
      return result_map;
  };

  /**
   *  Executes the given commandline in a bash and writes all execution-information
   *  to the specified logfile. Use these functions instead of directly calling the
   *  SCR or WFM agents (e.g. SCR::Execute(.target.bash, "rpm -q lilo") resp.
   *  WFM::(.local.bash, "rpm -q -r /mnt lilo")) to be sure to support logging correctly.
   *
   *  API function.
   *
   *  @param path environment The environment-path, has to be .local.bash or .target.bash
   *  @param string commandline The commandline.
   *  @return integer The exit code of the execution.
   *  @example OSRExecuteCommand(.local.bash, "rpm -qi -r /mnt/ lilo");
   *
   *   $ cat /tmp/osr.log
   *   *** /bin/rpm -qi lilo ***
   *   Name      : lilo         Relocations: (not relocateable)
   *   Version   : 21.6              Vendor: SuSE GmbH, Nuernberg, Germany
   *   [...]
   *   SuSE series: a
   *   *** exit code: 0 ***
   */
  global define OSRExecuteCommand(path environment, string commandline) ``{

      return OSRExecuteCommandProgress(environment, commandline, "");
  };
  
  /**
   *  Executes the given commandline in a bash and writes all execution-information
   *  to the specified logfile. Use these functions instead of directly calling the
   *  SCR or WFM agents (e.g. SCR::Execute(.target.bash, "rpm -q lilo") resp.
   *  WFM::(.local.bash, "rpm -q -r /mnt lilo")) to be sure to support logging correctly.
   *
   *  API function.
   *
   *  @param path environment The environment-path, has to be .local.bash or .target.bash
   *  @param string commandline The commandline.
   *  @param string progress_file The path of the progress file.
   *  @return integer The exit code of the execution.
   *  @example OSRExecuteCommandProgress(.local.bash, "rpm -qi -r /mnt/ lilo", "/tmp/progress_file");
   *
   *   $ cat /tmp/osr.log
   *   *** /bin/rpm -qi lilo ***
   *   Name      : lilo         Relocations: (not relocateable)
   *   Version   : 21.6              Vendor: SuSE GmbH, Nuernberg, Germany
   *   [...]
   *   SuSE series: a
   *   *** exit code: 0 ***
   */
  global define OSRExecuteCommandProgress(path environment, string commandline, string progress_file) ``{

      integer result        = 0;
      string  command       = "";
      string  demo_string   = "";
      list    string_list   = [];
      string  output_string = "";
      
      // in demo-mode set "echo" in front of every commandline and delete all ";" from
      // the commandline
      if (demo_mode)
      {
	  commandline = sformat("%1", "echo ", mergestring(splitstring(commandline, ";"), " "));
      }

      // only use the module progress bar if a filename was specified and the
      // UI interpreter supports the DownloadProgressWidget
      if ((progress_file != "") && (OSRModuleProgress::HasDownloadProgressWidget()))
      {	  
	  // write the specified command line to the log file and execute the command,
	  // write all output to the specified progress file
	  command = sformat("%1 >> %2 2>> %2", commandline, progress_file);
	  if (environment == .local.bash)
	  {
	      result = WFM::Execute(.local.bash, commandline);
	  }
	  else if (environment == .target.bash)
	  {
	      result = SCR::Execute(.target.bash, commandline);
	  }
	  else
	  {
	      y2error(sformat("OSRExecuteCommandProgress ERROR: wrong environment \"%1\", has to be .local.bash or .target.bash",
			      environment));
	      return -1;
	  }

	  // get the output from the progress file to write it to the log file
	  output_string = SCR::Read(.target.string, progress_file);
	  
	  OSRLogFile::Add(sformat("Command: %1\nProgress file: %2\noutput: %3\nexit: %4\n",
				  commandline, progress_file, output_string, result));
      }
      else
      {
	  // no progress file specified
	  
	  OSRLogFile::Add(sformat("Command: %1\n", commandline));

	  command = sformat("%1 >> %2 2>> %2", commandline, log_file);
	  if (environment == .local.bash)
	  {
	      result = WFM::Execute(.local.bash, commandline);
	  }
	  else if (environment == .target.bash)
	  {
	      result = SCR::Execute(.target.bash, commandline);
	  }
	  else
	  {
	      y2error(sformat("OSRExecuteCommandProgress ERROR: wrong environment \"%1\", has to be .local.bash or .target.bash",
			      environment));
	      return -1;
	  }

	  OSRLogFile::Add(sformat("exit: %1\n", result));
      }
	
      if ( result == 0 )
      {
	  y2debug("OSRExecuteCommandProgress: command succeeded: %1", result);
      }
      else if ( result == 126 )
      {
	  y2debug("OSRExecuteCommandProgress: command found but not executable: %1", result);
      }
      else if ( result == 127 )
      {
	  y2debug("OSRExecuteCommandProgress: command not found: %1", result);
      }
      else if ( result >= 128 )
      {
	  y2debug("OSRExecuteCommandProgress: command terminates with fatal sign N (N=%1-128): %1", result);
      }
      else
      {
	  y2debug("OSRExecuteCommandProgress: command terminates with error code %1", result);
      }
      return result;
  };

  /**
   *  This funnction returns the map that contains all informations about
   *  the specified module.
   *
   *  API function.
   *
   *  @param string module_name Name of the module.
   *  @return map The map that contains all informations about the module.
   */
  global define OSRGetModuleMap(string module_name) ``{

      return lookup(osr_map, module_name, $[]);
  };

  /**
   *  Displays the specified text in the help-RichText widget on
   *  the left of the main window.
   *
   *  API function.
   *
   *  @param string help_text The text to be displayed.
   *  @return boolean True if the widget contents were changed successfully.
   */
  global define OSRDisplayHelpText(string help_text) ``{

      return UI::ChangeWidget(`id(`rich_text_info), `Value, help_text);
  };

  /**
   *  Compares the two specified version numbers. Each version number has to be a string
   *  of the form "21.6-34", "34.4.3", ...
   *
   *  API function.
   *  See the testsuite.
   *
   *  @param string version_1 The first version-number as string.
   *  @param string version_2 The second version-number as string.
   *  @return boolean True if the first version number is newer than the second one.
   *  @example if (!OSRVersionIsHigherOrEqual("21.6", "22.3")) y2error("Something's wrong here.")
   */
  global define OSRVersionIsHigherOrEqual(string version_1, string version_2) ``{

      list    v_1   = [];
      list    v_2   = [];
      integer n_1   = 0;
      integer n_2   = 0;
      integer index = 0;
      integer max   = 0;

      // split the version-strings at the dots- and minus-characters "24.5.6" -> ["24", "5", "6"]
      v_1 = splitstring(version_1, ".-");
      v_2 = splitstring(version_2, ".-");

      // select the smaller one of the two numbers
      if (size(v_1) < size(v_2))
      {
	  max = size(v_1);
      }
      else
      {
	  max = size(v_2);
      }

      // iterate the splitted version-numbers
      while(index < max)
      {
	  n_1 = tointeger(select(v_1, index, 0));
	  n_2 = tointeger(select(v_2, index, 0));

	  if (n_1 > n_2)
	  {
	      return true;
	  }
	  else if (n_1 < n_2)
	  {
	      return false;
	  }
	  index = index + 1;
      }

      // if the splitted numbers were all equal, look if the first version-number
      // consits of more parts than the second one
      return (size(v_1) >= size(v_2));
  };

  /**
   *  This function is a wrapper for the definition of the correct status.
   *
   *  API function,
   *
   *  @return string The status "detect_ok"
   *  @example string status = OSRStatusDetectOK();
   */
  global define OSRStatusDetectOK() ``{

    return "detect_ok";
  };

  /**
   *  This function is a wrapper for the definition of the correct status.
   *
   *  API function,
   *
   *  @return string The status "detect_error"
   *  @example string status = OSRStatusDetectError();
   */
  global define OSRStatusDetectError() ``{

    return "detect_error";
  };

  /**
   *  This function is a wrapper for the definition of the correct status.
   *
   *  API function,
   *
   *  @return string The status "detect_error"
   *  @example string status = OSRStatusDetectError();
   */
  global define OSRStatusDetectProblem() ``{

    return "detect_problem";
  };

  /**
   *  This function is a wrapper for the definition of the correct status.
   *
   *  API function,
   *
   *  @return string The status "repair_ok"
   *  @example string status = OSRStatusRepairOK();
   */
  global define OSRStatusRepairOK() ``{

    return "repair_ok";
  };

  /**
   *  This function is a wrapper for the definition of the correct status.
   *
   *  API function,
   *
   *  @return string The status "repair_error"
   *  @example string status = OSRStatusRepairError();
   */
  global define OSRStatusRepairError() ``{

    return "repair_error";
  };

  /**
   *  This function is a wrapper for the definition of the correct status.
   *
   *  API function,
   *
   *  @return string The status "repair_omit"
   *  @example string status = OSRStatusRepairOmit();
   */
  global define OSRStatusRepairOmit() ``{

    return "repair_omit";
  };

  /**
   *  This function is a wrapper for the definition of the correct status.
   *
   *  API function,
   *
   *  @return string The status "repair_omit"
   *  @example string status = OSRStatusRepairOmit();
   */
  global define OSRStatusExit() ``{

      return "exit";
  };

  /**
   *  Returns the old osr_map stored on a floppy-disk.
   *
   *  API function,
   *
   *  @return map The value of the osr_map in a previous run, $[] if the file could not be read.
   *  @example map old_osr_map = OSRReadFloppy();
   */
  global define OSRReadFloppy() ``{

      boolean file_read        = false;
      //boolean user_read_floppy = true;
      map     return_map       = $[];
      boolean read_old_osr_map = false;
      boolean repeated         = false;
      any     user_input       = `empty;
      string  help_text        = "";
      string  floppy_device    = "";

      help_text = _("<p>If you want to load system-information from a previous session
insert the <b>YaST2 OS Repair-floppy-disk</b> and press <b>Load</b>.</p>");

      help_text = help_text + _("<p>Press <b>Next</b> to start the <b>YaST2 OS Repair</b>
without loading system information.</p>");

      read_old_osr_map = lookup(osr_map, "read_old_osr_map", false);

      UI(``{
	  term contents    = `Empty();
	  term load_button = `Empty();
	  term label       = `Empty();

//	  load_button = `PushButton(`id(`osr_floppy_button), `opt(`default), _("&Load system-information"));
	  load_button = `PushButton(`id(`osr_floppy_button), _("&Load system-information"));
//	  label       = `Label(`id(`osr_floppy_label), `opt(`default), _("You can revert the system-information detected
	  label       = `Label(`id(`osr_floppy_label), _("You can revert the system-information detected
in a previous run of YaST2 OS Repair.

Insert the YaST2 OS Repair-disk in your
floppy-drive and press Load."));

	  contents    = `VBox(
			      `HBox(
				    `HSquash(
					     `Frame(
						    _("Load system-information from floppy-disk"),
						    `HBox(
							  `HSpacing(1),
							  `VBox(
								`VSpacing(1),
								label,
								`VSpacing(1),
								`HCenter(
									 load_button
									 ),
								`VSpacing(1)
								),
							  `HSpacing(1)
							  )
						    )
					     )
				    )
			      );

	  ReplaceWidget(`id(`contents), contents);
	  ChangeWidget(`id(`rich_text_info), `Value, WFM::help_text);
	  SetFocus(`id(`next));
      });


      // if the old osr_map is already in memory, do not load it again from floppy
      if (read_old_osr_map)
      {
	  return old_osr_map;
      }

      repeat
	  {
	      string text = "";

	      if (repeated)
	      {
		  text = _("An error occurred. The system-information was
not loaded correctly from floppy.

Insert the YaST2 OS Repair-disk in your
floppy-drive and press Load.");

		  UI::ChangeWidget(`id(`osr_floppy_label), `Value, WFM::text);
	      }

	      user_input = UI::UserInput();

	      if (user_input == `osr_floppy_button)
	      {
		  //if (user_read_floppy)
		  //{
		  boolean has_floppy    = true;
		  string  floppy_device = "";

		  has_floppy    = lookup(user_settings, "has_floppy", true);

		  floppy_device = OSRRequireString("floppy_device");

		  if (floppy_device == "")
		  {
		      floppy_device = lookup(user_settings, "floppy_device", "/dev/fd0");
		  }
		  
		  if (has_floppy)
		  {
		      UI::OpenDialog(`opt(`decorated), `Label(_("Loading system information...")));

		      // mount the floppy to /media/floppy/
//		      boolean mounted = (WFM::Execute(.local.bash, "/bin/mount " + floppy_device + " /media/floppy -t auto") == 0);
		      boolean mounted = (OSRExecuteCommand(.local.bash, "/bin/mount " + floppy_device + " /media/floppy -t auto") == 0);

		      // be careful: only read the file /media/floppy/osr_map.ycp if the floppy was mounted
		      // correctly!
		      if (mounted)
		      {
			  // get the old osr_map from floppy
			  map r = WFM::Read(.local.ycp, "/media/floppy/osr_map.ycp");

			  if ((r != nil) && (size(r) > 0))
			  {
			      return_map = r;
			      file_read  = true;
			  }
		      }
		      // umount the floppy after reading
		      //WFM::Execute(.local.bash, "/bin/umount /media/floppy");
		      OSRExecuteCommand(.local.bash, "/bin/umount /media/floppy");
		      
		      UI::CloseDialog();

		      if (file_read)
		      {
			  OSRPopupDisplayQuick(_("System information is o.k."), 1000);

			  // store a boolean flag: the old osr_map was already loaded from floppy
			  osr_map = add(osr_map, "read_old_osr_map", true);

			  if (lookup(osr_map, "read_old_osr_map", false) == false)
			  {
			      y2error("OSRReadFloppy(): An error occurred.");
			  }
		      }
		      else
		      {
			  OSRPopupDisplayQuick(_("System information could not be read."), 1000);
		      }
		  }
		  else
		  {
		      OSRPopupDisplayQuick(_("No floppy device detected."), 1000);
		  }
	      }
	      repeated = true;
	      
	  } until (file_read || (user_input != `osr_floppy_button));

      if (user_input == `osr_floppy_button)
      {
	  old_osr_map = return_map;
	  user_input  = `next;
      }

      return user_input;
  };

  /**
   *  Saves the contents of the global osr_map to the file "osr_map.ycp" on floppy-disk.
   *
   *  API function,
   *
   *  @return boolean True if the osr_map was written correctly to the file "osr_map.ycp" on floppy-disk.
   *  @example boolean write_ok = OSRWriteFloppy();
   */
  global define OSRWriteFloppy() ``{

      boolean file_written      = false;
      boolean user_write_floppy = true;
      boolean repeated          = false;
      any     user_input        = `empty;
      string  help_text         = "";
      string  floppy_device     = "";

      help_text = _("<p>If you want to store the system-information from this session of
 <b>YaST2 OS Repair</b> insert a formatted floppy-disk and
 press <b>Store system-information</b>.</p>");

      help_text = help_text + _("<p>Press <b>Next</b> to halt the <b>YaST2 OS Repair</b>.</p>");

      UI(``{
	  term contents     = `Empty();
	  term store_button = `Empty();
	  term label        = `Empty();

//	  store_button = `PushButton(`id(`osr_floppy_button), `opt(`default), _("&Store system-information"));
//	  label       = `Label(`id(`osr_floppy_label), `opt(`default), _("You can store the whole system-information
	  store_button = `PushButton(`id(`osr_floppy_button), _("&Store system-information"));
	  label       = `Label(`id(`osr_floppy_label), _("You can store the whole system-information
to a floppy-disk. This can be helpful for
later system-checks.

Insert a formatted disk in your floppy-drive
and press Store."));

	  contents    = `VBox(
			      `HBox(
				    `HSquash(
					     `Frame(
						    _("Store system-information on floppy-disk"),
						    `HBox(
							  `HSpacing(1),
							  `VBox(
								`VSpacing(1),
								label,
								`VSpacing(1),
								`HCenter(
									 store_button
									 ),
								`VSpacing(1)
								),
							  `HSpacing(1)
							  )
						    )
					     )
				    )
			      );

	  ReplaceWidget(`id(`contents), contents);
	  ChangeWidget(`id(`rich_text_info), `Value, WFM::help_text);
      });

      repeat
	  {
	      if (repeated)
	      {
		  string text = _("An error occurred. The system-information
was not correctly stored to the floppy-disk.

Insert a formatted disk in your floppy-drive
and press Store.");

		  UI::ChangeWidget(`id(`osr_floppy_label), `Value, WFM::text);
	      }

	      user_input = UI::UserInput();

	      if (user_input == `osr_floppy_button)
	      {
		  boolean has_floppy    = true;
		  string  floppy_device = "";
      
		  has_floppy    = lookup(user_settings, "has_floppy", true);
		  floppy_device = OSRRequireString("floppy_device");

		  if (floppy_device == "")
		  {
		      floppy_device = lookup(user_settings, "floppy_device", "/dev/fd0");
		  }

		  //OSRPopupDisplayQuick(sformat("has_floppy: %1", has_floppy), 2000);
      
		  if (has_floppy)
		  {
		      UI::OpenDialog(`opt(`decorated), `Label(_("Storing system information...")));

		      // mount the floppy to /media/floppy/
		      boolean mounted = (OSRExecuteCommand(.local.bash, "/bin/mount " + floppy_device + " /media/floppy -t auto") == 0);

		      // be careful: only write to the directory /media/floppy if the floppy was mounted
		      // correctly, otherwise the file /media/floppy/osr_map.ycp is saved to harddisk!
		      if (mounted)
		      {
			  // save all partition-tables to floppy
			  map target_map = Storage::GetTargetMap();

			  //
			  // TODO: only save the _valid_ primary partition tables
                          //
			  
			  // iterate all harddisks
			  foreach(`target, `values, target_map, ``{

			      // target = "/dev/sda" -> disk_name = "sda"
			      string disk_name = select(splitstring(target, "/"), (size(splitstring(target, "/"))-1));

			      // set the dd-command
			      string command = sformat("dd if=%1 of=/media/floppy/%2.ptbl bs=512 count=1", target, disk_name);
			      
			      // do it!
			      // the partition-table of "/dev/sda" is saved to the file "sda.ptbl" on floppy
//			      integer dd_result = WFM::Execute(.local.bash, command);
			      integer dd_result = OSRExecuteCommand(.local.bash, command);

			      //OSRPopupDisplayQuick(sformat("command: %1\ndd_result: %2", command, dd_result), 3000);

			      if (dd_result == 0)
			      {
				  integer dd_written = SCR::Read(.target.size, "/media/floppy/" + disk_name + ".ptbl");

				  if (dd_written != 512)
				  {
				      y2error("file %1 not written correctly to floppy", "/media/floppy/" + disk_name + ".ptbl");

				      OSRPopupDisplayQuick(sformat(_("The primary partition table of disk %1
was not written correctly to floppy."), target), 1000);
 				  }
			      }
			  });

			  boolean file_write = WFM::Write(.local.ycp, "/media/floppy/osr_map.ycp", osr_map);

			  // get osr_map from floppy as test
			  map r = WFM::Read(.local.ycp, "/media/floppy/osr_map.ycp");

			  if (file_write && (r != nil) && (size(r) > 0) && (r == osr_map))
			  {
			      file_written = true;
			  }
		      }
		      
		      // umount the floppy after reading
//		      WFM::Execute(.local.bash, "/bin/umount /media/floppy");
		      OSRExecuteCommand(.local.bash, "/bin/umount /media/floppy");
  
		      UI::CloseDialog();

		      if (file_written)
		      {
			  OSRPopupDisplayQuick(_("System information is stored."), 1000);

			  osr_map = add(osr_map, "osr_map_stored", true);
		      }
		      else
		      {
			  OSRPopupDisplayQuick(_("System information is not stored."), 1000);
		      }
		  }
		  else
		  {
			  OSRPopupDisplayQuick(_("No floppy device detected."), 1000);
		  } // if (has_floppy)
	      }
	      repeated = true;
	      
	  } until (file_written || (user_input != `osr_floppy_button));

      if (user_input == `osr_floppy_button)
      {
	  //old_osr_map = return_map;
	  user_input  = `next;
      }

      return user_input;
  };
  
  /**
   *  Returns the path of the global temporary directory, e.g. "/tmp/YaST2-02274".
   *
   *  API function,
   *
   *  @return string The path of the temporary directory.
   *  @example string tmpdir = OSRGetTmpDir();
   */
  global define OSRGetTmpDir() ``{

      return (SCR::Read(.target.tmpdir));
  };
  
  /**
   *  Stores the given list with the specified name into the global_provides map
   *  in the osr_map.
   *
   *  API function,
   *
   *  @param string name The name of the provided value.
   *  @param list value The provided value.
   *  @return boolean True.
   */
  global define OSRProvideList(string name, list value) ``{

      map global_provides_map  = $[];
      map provides_map         = $[];

      provides_map        = $[ "type" : "list", "value" : value, "status" : "known" ];
      global_provides_map = lookup(osr_map, "global_provides", $[]);
      global_provides_map = add(global_provides_map, name, provides_map);
      osr_map             = add(osr_map, "global_provides", global_provides_map);

      return true;
  };

  /**
   *  Stores the given map with the specified name into the global_provides map
   *  in the osr_map.
   *
   *  API function,
   *
   *  @param string name The name of the provided value.
   *  @param map value The provided value.
   *  @return boolean True.
   */
  global define OSRProvideMap(string name, map value) ``{

      map global_provides_map  = $[];
      map provides_map         = $[];

      provides_map        = $[ "type" : "map", "value" : value, "status" : "known" ];
      global_provides_map = lookup(osr_map, "global_provides", $[]);
      global_provides_map = add(global_provides_map, name, provides_map);
      osr_map             = add(osr_map, "global_provides", global_provides_map);

      return true;
  };

  /**
   *  Stores the given string with the specified name into the global_provides map
   *  in the osr_map.
   *
   *  API function,
   *
   *  @param string name The name of the provided value.
   *  @param string value The provided value.
   *  @return boolean True.
   */
  global define OSRProvideString(string name, string value) ``{

      map global_provides_map  = $[];
      map provides_map         = $[];

      provides_map        = $[ "type" : "string", "value" : value, "status" : "known" ];
      global_provides_map = lookup(osr_map, "global_provides", $[]);
      global_provides_map = add(global_provides_map, name, provides_map);
      osr_map             = add(osr_map, "global_provides", global_provides_map);

      return true;
  };

  /**
   *  Stores the given path with the specified name into the global_provides map
   *  in the osr_map.
   *
   *  API function,
   *
   *  @param string name The name of the provided value.
   *  @param path value The provided value.
   *  @return boolean True.
   */
  global define OSRProvidePath(string name, path value) ``{

      map global_provides_map  = $[];
      map provides_map         = $[];

      provides_map        = $[ "type" : "path", "value" : value, "status" : "known" ];
      global_provides_map = lookup(osr_map, "global_provides", $[]);
      global_provides_map = add(global_provides_map, name, provides_map);
      osr_map             = add(osr_map, "global_provides", global_provides_map);

      return true;
  };
  
  /**
   *  Stores the given boolean value with the specified name into the global_provides map
   *  in the osr_map.
   *
   *  API function,
   *
   *  @param string name The name of the provided value.
   *  @param boolean value The provided value.
   *  @return boolean True.
   */
  global define OSRProvideBoolean(string name, boolean value) ``{

      map global_provides_map  = $[];
      map provides_map         = $[];

      provides_map        = $[ "type" : "boolean", "value" : value, "status" : "known" ];
      global_provides_map = lookup(osr_map, "global_provides", $[]);
      global_provides_map = add(global_provides_map, name, provides_map);
      osr_map             = add(osr_map, "global_provides", global_provides_map);

      return true;
  };

  /**
   *  Returns the required string from the global_provides map
   *  in the osr_map.
   *
   *  API function,
   *
   *  @param string name The name of the required value.
   *  @return string value The required string, "" as default.
   */
  global define OSRRequireString(string name) ``{

      if (lookup(lookup(lookup(osr_map, "global_provides", $[]), name, $[]), "status", "") != "known")
      {
	  y2error("The required value \"%1\" is not yet set.", name);
      }
      
      return lookup(lookup(lookup(osr_map, "global_provides", $[]), name, $[]), "value", "");
  };

  /**
   *  Returns the required list from the global_provides map
   *  in the osr_map.
   *
   *  API function,
   *
   *  @param string name The name of the required value.
   *  @return string The required list, [] as default.
   */
  global define OSRRequireList(string name) ``{

      if (lookup(lookup(lookup(osr_map, "global_provides", $[]), name, $[]), "status", "") != "known")
      {
	  y2error("The required value \"%1\" is not yet set.", name);
      }

      return lookup(lookup(lookup(osr_map, "global_provides", $[]), name, $[]), "value", []);
  };

  /**
   *  Returns the required map from the global_provides map
   *  in the osr_map.
   *
   *  API function,
   *
   *  @param string name The name of the required value.
   *  @return map The required map, $[] as default.
   */
  global define OSRRequireMap(string name) ``{

      if (lookup(lookup(lookup(osr_map, "global_provides", $[]), name, $[]), "status", "") != "known")
      {
	  y2error("The required value \"%1\" is not yet set.", name);
      }

      return lookup(lookup(lookup(osr_map, "global_provides", $[]), name, $[]), "value", $[]);
  };

  /**
   *  Returns the required path from the global_provides map
   *  in the osr_map.
   *
   *  API function,
   *
   *  @param string name The name of the required value.
   *  @return path value The required path, . as default.
   */
  global define OSRRequirePath(string name) ``{

      if (lookup(lookup(lookup(osr_map, "global_provides", $[]), name, $[]), "status", "") != "known")
      {
	  y2error("The required value \"%1\" is not yet set.", name);
      }

      return lookup(lookup(lookup(osr_map, "global_provides", $[]), name, $[]), "value", .);
  };

  /**
   *  Returns the required boolean value from the global_provides map
   *  in the osr_map.
   *
   *  API function,
   *
   *  @param string name The name of the required value.
   *  @return boolean value The required boolean value, false as default.
   */
  global define OSRRequireBoolean(string name) ``{

      if (lookup(lookup(lookup(osr_map, "global_provides", $[]), name, $[]), "status", "") != "known")
      {
	  y2error("The required value \"%1\" is not yet set.", name);
      }

      return lookup(lookup(lookup(osr_map, "global_provides", $[]), name, $[]), "value", false);
  };

  /**
   *  Returns the level of severity of the detected error. This severity involves
   *  the rescue system to stop the further execution if the detected error is
   *  not repaired. E.g. if the rescue system does not detect any harddisks it
   *  makes no sense to go on checking for any errors. The rescue system will halt.
   *
   *  API function.
   *
   *  @return string The severity of the detected error.
   */
  global define OSRErrorSeverityBlocking() ``{

      return "blocking";
  };

  /**
   *  Returns the level of severity of the detected error. This severity means
   *  that the detected error involves to jump to the next detection module
   *  without executing any further method of the current module. E.g. if the
   *  rescue system detects that the LILO package is not installed on the system
   *  and this error could not be repaired, it makes no sense to check the LILO
   *  configuration file for any errors. So the rescue system jumps to the next
   *  module in the module sequence.
   *
   *  API function.
   *
   *  @return string The severity of the detected error.
   */
  global define OSRErrorSeverityModuleBlocking() ``{

      return "module_blocking";
  };
}
