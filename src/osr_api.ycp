 /**
 *  File:
 *    osr_api.ycp
 *
 *  Module:
 *    YaST2 OS Repair - automatic error detection & repair tool for Linux.
 *
 *  Summary:
 *    This file provides the api functions of the YaST2 OS Repair tool that can be used
 *    by the error detection and repair modules.
 *
 *  Author:
 *    Michael Koehrmann <curry@suse.de>
 */
{
  textdomain "osr";

  /**
   *  Executes the given commandline in a bash and writes all execution-information
   *  to the specified logfile. This function returns all output from the commandline
   *  in a result map.
   *
   *  API function.
   *
   *  @param string commandline The commandline.
   *  @param string log_file The path of the logfile.
   *  @param path environment The environment-path, has to be .local or .target.
   *  @return map The result map with all output from the command.
   *  @example map result_map = OSRExecuteCommandOutput("rpm -qi -r /mnt/ lilo", "/tmp/osr.log", .local);
   */
  global define OSRExecuteCommandOutput(string commandline, string log_file, path environment) ``{

      map     result_map  = $[];
      integer result      = 0;
      string  command     = "";
      string  demo_string = "";
      string  stdout      = "";
      string  stderr      = "";

      if (log_file == "")
      {
	  log_file = OSRLogFile::GetFile();
	  y2error("OSRExecuteCommandOutput ERROR: no logfile specified, using standard.");
      }
      
      // in demo-mode set "echo" in front of every commandline
      if (demo_mode) demo_string = "echo";

      // execute the given commandline and write the commandline and output information to logfile
      //commandline = sformat("%1 %2 2> /dev/null", demo_string, commandline);
      //commandline = sformat("%2 2> /dev/null", demo_string, commandline);

      //y2error("COMMAND: %1", commandline);
      
      //command     = sformat("echo \"*** %1 ***\" >> %2; %1 >> %2 2>> %2", commandline, log_file);

      if (environment == .local)
      {
	  result_map = WFM::Execute(.local.bash_output, commandline);
      }
      else if (environment == .target)
      {
	  result_map = SCR::Execute(.target.bash_output, commandline);
      }
      else
      {
	  y2error(sformat("OSRExecuteCommandOutput ERROR: wrong environment \"%1\", has to be .local or .target", environment));
	  return $[];
      }
      
      //result_map  = SCR::Execute(.target.bash_output, commandline);
      result      = lookup(result_map, "exit", 0);
      stdout      = lookup(result_map, "stdout", "");
      stderr      = lookup(result_map, "stderr", "");
      
      //command = sformat("echo \"*** %1 ***\" >> %5; echo \"%3\" >> %5; echo \"%4\" >> %5; echo \"*** exit code: %2 ***\n\n\" >> %5",
      //		commandline, result, stdout, stderr, log_file);
      //command = sformat("", commandline);
      //y2error("COMMAND: %1", command);

      //SCR(`Execute(.target.bash, command));
	
      if ( result == 0 )
      {
	  y2debug("OSRExecuteCommandOutput: command succeeded: %1", result);
      }
      else if ( result == 126 )
      {
	  y2debug("OSRExecuteCommandOutput: command found but not executable: %1", result);
      }
      else if ( result == 127 )
      {
	  y2debug("OSRExecuteCommandOutput: command not found: %1", result);
      }
      else if ( result >= 128 )
      {
	  y2debug("OSRExecuteCommandOutput: command terminates with fatal sign N (N=%1-128): %1", result);
      }
      else
      {
	  y2debug("OSRExecuteCommandOutput: command terminates with error code %1", result);
      }
      return result_map;
  }

  /**
   *  Executes the given commandline in a bash and writes all execution-information
   *  to the specified logfile.
   *
   *  API function.
   *
   *  @param string commandline The commandline.
   *  @param string log_file The logfile path.
   *  @param path environment The environment-path, has to be .local or .target.
   *  @return integer The exit code of the execution.
   *  @example OSRExecuteCommand("rpm -qi -r /mnt/ lilo", "/tmp/osr.log", .local);
   *
   *   $ cat /tmp/osr.log
   *   *** /bin/rpm -qi lilo ***
   *   Name      : lilo         Relocations: (not relocateable)
   *   Version   : 21.6              Vendor: SuSE GmbH, Nuernberg, Germany
   *   [...]
   *   SuSE series: a
   *   *** exit code: 0 ***
   */
  global define OSRExecuteCommand(string commandline, string log_file, path environment) ``{

      return OSRExecuteCommandProgress(commandline, log_file, environment, "");
  }
  
  /**
   *  Executes the given commandline in a bash and writes all execution-information
   *  to the specified logfile.
   *
   *  API function.
   *
   *  @param string commandline The commandline.
   *  @param string log_file The logfile path.
   *  @param path environment The environment-path, has to be .local or .target.
   *  @param string progress_file The path of the progress file.
   *  @return integer The exit code of the execution.
   *  @example OSRExecuteCommandProgress("rpm -qi -r /mnt/ lilo", "/tmp/osr.log", .local, "/tmp/progress_file");
   *
   *   $ cat /tmp/osr.log
   *   *** /bin/rpm -qi lilo ***
   *   Name      : lilo         Relocations: (not relocateable)
   *   Version   : 21.6              Vendor: SuSE GmbH, Nuernberg, Germany
   *   [...]
   *   SuSE series: a
   *   *** exit code: 0 ***
   */
  global define OSRExecuteCommandProgress(string commandline, string log_file, path environment, string progress_file) ``{

      integer result      = 0;
      string  command     = "";
      string  demo_string = "";
      list    string_list = [];

      if (log_file == "")
      {
	  log_file = OSRLogFile::GetFile();
	  y2error("OSRExecuteCommandProgress ERROR: no logfile specified, using standard.");
      }
      
      // in demo-mode set "echo" in front of every commandline and delete all ";" from
      // the commandline
      if (demo_mode)
      {
	  commandline = sformat("%1", "echo ", mergestring(splitstring(commandline, ";"), " "));
      }
      
      if (progress_file != "")
      {
	  //command     = sformat("rm -f %2; %1 >> %2 2>> %2", commandline, progress_file);
	  command     = sformat("%1 >> /dev/null 2>> /dev/null", commandline);
          //result      = SCR::Execute(.target.bash, command);

	  if (environment == .local)
	  {
	      result = WFM::Execute(.local.bash, commandline);
	  }
	  else if (environment == .target)
	  {
	      result = SCR::Execute(.target.bash, commandline);
	  }
	  else
	  {
	      y2error(sformat("OSRExecuteCommandProgress ERROR: wrong environment \"%1\", has to be .local or .target", environment));
	      return -1;
	  }
	  

	  command     = sformat("echo \"*** %1 ***\" >> %2; cat %3 >> %2; echo \"*** exit code: %4 ***\n\n\" >> %2",
				commandline, log_file, progress_file, result);
	  //SCR(`Execute(.target.bash, command));
      }
      else
      {  
	  // execute the given commandline and write the commandline and output information to logfile
	  //commandline = sformat("%1 %2", demo_string, commandline);
	  //command     = sformat("echo \"*** %1 ***\" >> %2; %1 >> %2 2>> %2", commandline, log_file);
	  command     = sformat("%1 >> /dev/null 2>> /dev/null", commandline);

	  if (environment == .local)
	  {
	      result = WFM::Execute(.local.bash, commandline);
	  }
	  else if (environment == .target)
	  {
	      result = SCR::Execute(.target.bash, commandline);
	  }
	  else
	  {
	      y2error(sformat("OSRExecuteCommandProgress ERROR: wrong environment \"%1\", has to be .local or .target", environment));
	      return -1;
	  }

	  //result      = SCR::Execute(.target.bash, command);

	  command = sformat("echo \"*** exit code: %1 ***\n\n\" >> %2", result, log_file);
	  //SCR::Execute(.target.bash, command);
      }
	
      if ( result == 0 )
      {
	  y2debug("OSRExecuteCommandProgress: command succeeded: %1", result);
      }
      else if ( result == 126 )
      {
	  y2debug("OSRExecuteCommandProgress: command found but not executable: %1", result);
      }
      else if ( result == 127 )
      {
	  y2debug("OSRExecuteCommandProgress: command not found: %1", result);
      }
      else if ( result >= 128 )
      {
	  y2debug("OSRExecuteCommandProgress: command terminates with fatal sign N (N=%1-128): %1", result);
      }
      else
      {
	  y2debug("OSRExecuteCommandProgress: command terminates with error code %1", result);
      }
      return result;
  }


  /**
   *  This funnction returns the map that contains all informations about
   *  the specified module.
   *
   *  API function.
   *
   *  @param string module_name Name of the module.
   *  @return map The map that contains all informations about the module.
   */
  global define OSRGetModuleMap(string module_name) ``{

      return lookup(osr_map, module_name, $[]);
  }

  /**
   *  Displays the specified text in the help-RichText widget on
   *  the left of the main window.
   *
   *  API function.
   *
   *  @param string help_text The text to be displayed.
   *  @return boolean True if the widget contents were changed successfully.
   */
  global define OSRDisplayHelpText(string help_text) ``{

      return UI::ChangeWidget(`id(`help), `Value, help_text);
  }

    /**
   *  Stores the given list with the specified name into the global_provides map
   *  in the osr_map.
   *
   *  API function,
   *
   *  @param string name The name of the provided value.
   *  @param list value The provided value.
   *  @return boolean True.
   */
  global define OSRProvideList(string name, list value) ``{

      map global_provides_map  = $[];
      map provides_map         = $[];

      provides_map        = $[ "type" : "list", "value" : value, "status" : "known" ];
      global_provides_map = lookup(osr_map, "global_provides", $[]);
      global_provides_map = add(global_provides_map, name, provides_map);
      osr_map             = add(osr_map, "global_provides", global_provides_map);

      return true;
  }

  /**
   *  Stores the given map with the specified name into the global_provides map
   *  in the osr_map.
   *
   *  API function,
   *
   *  @param string name The name of the provided value.
   *  @param map value The provided value.
   *  @return boolean True.
   */
  global define OSRProvideMap(string name, map value) ``{

      map global_provides_map  = $[];
      map provides_map         = $[];

      provides_map        = $[ "type" : "map", "value" : value, "status" : "known" ];
      global_provides_map = lookup(osr_map, "global_provides", $[]);
      global_provides_map = add(global_provides_map, name, provides_map);
      osr_map             = add(osr_map, "global_provides", global_provides_map);

      return true;
  }

  /**
   *  Stores the given string with the specified name into the global_provides map
   *  in the osr_map.
   *
   *  API function,
   *
   *  @param string name The name of the provided value.
   *  @param string value The provided value.
   *  @return boolean True.
   */
  global define OSRProvideString(string name, string value) ``{

      map global_provides_map  = $[];
      map provides_map         = $[];

      provides_map        = $[ "type" : "string", "value" : value, "status" : "known" ];
      global_provides_map = lookup(osr_map, "global_provides", $[]);
      global_provides_map = add(global_provides_map, name, provides_map);
      osr_map             = add(osr_map, "global_provides", global_provides_map);

      return true;
  }

  /**
   *  Stores the given path with the specified name into the global_provides map
   *  in the osr_map.
   *
   *  API function,
   *
   *  @param string name The name of the provided value.
   *  @param path value The provided value.
   *  @return boolean True.
   */
  global define OSRProvidePath(string name, path value) ``{

      map global_provides_map  = $[];
      map provides_map         = $[];

      provides_map        = $[ "type" : "path", "value" : value, "status" : "known" ];
      global_provides_map = lookup(osr_map, "global_provides", $[]);
      global_provides_map = add(global_provides_map, name, provides_map);
      osr_map             = add(osr_map, "global_provides", global_provides_map);

      return true;
  }

  /**
   *  Returns the required path from the global_provides map
   *  in the osr_map.
   *
   *  API function,
   *
   *  @param string name The name of the required value.
   *  @return path value The required path, . as default.
   */
  global define OSRRequirePath(string name) ``{

      // TODO: only return the value if it's status is "known"
      return lookup(lookup(lookup(osr_map, "global_provides", $[]), name, $[]), "value", .);
  }

  /**
   *  Returns the required string from the global_provides map
   *  in the osr_map.
   *
   *  API function,
   *
   *  @param string name The name of the required value.
   *  @return string value The required string, "" as default.
   */
  global define OSRRequireString(string name) ``{

      // TODO: only return the value if it's status is "known"
      return lookup(lookup(lookup(osr_map, "global_provides", $[]), name, $[]), "value", "");
  }

  /**
   *  Returns the required list from the global_provides map
   *  in the osr_map.
   *
   *  API function,
   *
   *  @param string name The name of the required value.
   *  @return string The required list, [] as default.
   */
  global define OSRRequireList(string name) ``{

      // TODO: only return the value if it's status is "known"
      return lookup(lookup(lookup(osr_map, "global_provides", $[]), name, $[]), "value", []);
  }

  /**
   *  Returns the required map from the global_provides map
   *  in the osr_map.
   *
   *  API function,
   *
   *  @param string name The name of the required value.
   *  @return map The required map, $[] as default.
   */
  global define OSRRequireMap(string name) ``{

      // TODO: only return the value if it's status is "known"
      return lookup(lookup(lookup(osr_map, "global_provides", $[]), name, $[]), "value", $[]);
  }

  /**
   *  Compares the two specified version numbers. Each version number has to be a string
   *  of the form "21.6"!
   *
   *  API function,
   *
   *  @return boolean True if the first version number is newer than the second one.
   *  @example if (!OSRVersionIsNewerOrEqual("21.6", "22.3")) y2error("Something's wrong here.")
   */
  global define OSRVersionIsNewerOrEqual(string version_1, string version_2) ``{

      integer main_version_1 = 0;
      integer sub_version_1  = 0;
      integer main_version_2 = 0;
      integer sub_version_2  = 0;
      
      main_version_1 = tointeger(select(splitstring(version_1, "."), 0, "0"));
      sub_version_1  = tointeger(select(splitstring(version_1, "."), 1, "0"));
      main_version_2 = tointeger(select(splitstring(version_2, "."), 0, "0"));
      sub_version_2  = tointeger(select(splitstring(version_2, "."), 1, "0"));

      return ((main_version_1 > main_version_2) ||
	      ((main_version_1 == main_version_2) &&
	       (sub_version_1 >= sub_version_2)));
  }

  /**
   *  This function is a wrapper for the definition of the correct status.
   *
   *  API function,
   *
   *  @return string The status "detect_ok"
   *  @example string status = OSRStatusDetectOK();
   */
  global define OSRStatusDetectOK() ``{

    return "detect_ok";
  }

  /**
   *  This function is a wrapper for the definition of the correct status.
   *
   *  API function,
   *
   *  @return string The status "detect_error"
   *  @example string status = OSRStatusDetectError();
   */
  global define OSRStatusDetectError() ``{

    return "detect_error";
  }

  /**
   *  This function is a wrapper for the definition of the correct status.
   *
   *  API function,
   *
   *  @return string The status "repair_ok"
   *  @example string status = OSRStatusRepairOK();
   */
  global define OSRStatusRepairOK() ``{

    return "repair_ok";
  }

  /**
   *  This function is a wrapper for the definition of the correct status.
   *
   *  API function,
   *
   *  @return string The status "repair_error"
   *  @example string status = OSRStatusRepairError();
   */
  global define OSRStatusRepairError() ``{

    return "repair_error";
  }

  /**
   *  This function is a wrapper for the definition of the correct status.
   *
   *  API function,
   *
   *  @return string The status "repair_omit"
   *  @example string status = OSRStatusRepairOmit();
   */
  global define OSRStatusRepairOmit() ``{

    return "repair_omit";
  }

  /**
   *  Returns the old osr_map stored on a floppy-disk.
   *
   *  API function,
   *
   *  @return map The value of the osr_map in a previous run, $[] if the file could not be read.
   *  @example map old_osr_map = OSRMapReadFloppy();
   */
  global define OSRMapReadFloppy() ``{

      boolean file_read        = false;
      //boolean user_read_floppy = true;
      map     return_map       = $[];
      boolean read_old_osr_map = false;
      boolean repeated         = false;
      any     user_input       = `empty;
      string  help_text         = "";

      help_text = _("<p>If you want to load system-information from a previous session
insert the <b>YaST2 OS Repair-floppy-disk</b> and press <b>Load</b>.</p>");

      help_text = help_text + _("<p>Press <b>Next</b> to start the <b>YaST2 OS Repair</b>
without loading system information.</p>");

      read_old_osr_map = lookup(osr_map, "read_old_osr_map", false);

      UI(``{
	  term contents    = `Empty();
	  term load_button = `Empty();
	  term label       = `Empty();

	  load_button = `PushButton(`id(`osr_floppy_button), `opt(`default), _("&Load system-information"));
	  label       = `Label(`id(`osr_floppy_label), `opt(`default), _("You can revert the system-information detected
in a previous run of YaST2 OS Repair.

Insert the YaST2 OS Repair-disk in your
floppy-drive and press Load."));

	  contents    = `VBox(
			      `HBox(
				    `HSquash(
					     `Frame(
						    _("Load system-information from floppy-disk"),
						    `HBox(
							  `HSpacing(1),
							  `VBox(
								`VSpacing(1),
								label,
								`VSpacing(1),
								`HCenter(
									 load_button
									 ),
								`VSpacing(1)
								),
							  `HSpacing(1)
							  )
						    )
					     )
				    )
			      );

	  ReplaceWidget(`id(`contents), contents);
	  ChangeWidget(`id(`help), `Value, WFM::help_text);
	  SetFocus(`id(`next));
      });


      // if the old osr_map is already in memory, do not load it again from floppy
      if (read_old_osr_map)
      {
	  return old_osr_map;
      }

      repeat
	  {
	      string text = "";

	      if (repeated)
	      {
		  text = _("An error occurred. The system-information was
not loaded correctly from floppy.

Insert the YaST2 OS Repair-disk in your
floppy-drive and press Load.");

		  UI::ChangeWidget(`id(`osr_floppy_label), `Value, WFM::text);
	      }

	      user_input = UI::UserInput();

	      if (user_input == `osr_floppy_button)
	      {
		  //if (user_read_floppy)
		  //{
		  boolean has_floppy    = true;
		  string  floppy_device = "";

		  has_floppy    = lookup(user_settings, "has_floppy", false);
		  floppy_device = lookup(user_settings, "floppy_device", "/dev/fd0");

		  if (has_floppy)
		  {
		      UI::OpenDialog(`opt(`decorated), `Label(_("Loading system information...")));

		      // mount the floppy to /media/floppy/
		      boolean mounted = (WFM::Execute(.local.bash, "/bin/mount " + floppy_device + " /media/floppy -t auto") == 0);

		      // be careful: only read the file /media/floppy/osr_map.ycp if the floppy was mounted
		      // correctly!
		      if (mounted)
		      {
			  // get the old osr_map from floppy
			  map r = WFM::Read(.local.ycp, "/media/floppy/osr_map.ycp");

			  if ((r != nil) && (size(r) > 0))
			  {
			      return_map = r;
			      file_read  = true;
			  }
		      }
		      // umount the floppy after reading
		      WFM::Execute(.local.bash, "/bin/umount /media/floppy");
  
		      UI::CloseDialog();

		      if (file_read)
		      {
			  OSRPopupDisplayQuick(_("System information is o.k."), 1000);

			  // store that the old osr_map was already loaded from floppy
			  osr_map = add(osr_map, "read_old_osr_map", true);

			  if (lookup(osr_map, "read_old_osr_map", false) == false)
			  {
			      // TODO
			      OSRPopupDisplayQuick("osr_api.ycp:Da is wohl was daneben gegangen.\nread_old_osr_map = false??", 2000);
			  }
		      }
		  }
		  else
		  {

		  }
	      }
	      repeated = true;
	      
	  } until (file_read || (user_input != `osr_floppy_button));

      if (user_input == `osr_floppy_button)
      {
	  old_osr_map = return_map;
	  user_input  = `next;
      }

      return user_input;
  }

  /**
   *  Saves the contents of the global osr_map to the file "osr_map.ycp" on floppy-disk.
   *
   *  API function,
   *
   *  @return boolean True if the osr_map was written correctly to the file "osr_map.ycp" on floppy-disk.
   *  @example boolean write_ok = OSRMapWriteFloppy();
   */
  global define OSRMapWriteFloppy() ``{

      boolean file_written      = false;
      boolean user_write_floppy = true;
      boolean repeated          = false;
      any     user_input        = `empty;
      string  help_text         = "";

      help_text = _("<p>If you want to store the system-information from this session of
 <b>YaST2 OS Repair</b> insert a formatted floppy-disk and
 press <b>Store system-information</b>.</p>");

      help_text = help_text + _("<p>Press <b>Next</b> to halt the <b>YaST2 OS Repair</b>.</p>");

      UI(``{
	  term contents    = `Empty();
	  term load_button = `Empty();
	  term label       = `Empty();

	  load_button = `PushButton(`id(`osr_floppy_button), `opt(`default), _("&Store system-information"));
	  label       = `Label(`id(`osr_floppy_label), `opt(`default), _("You can store the whole system-information
to a floppy-disk. This can be helpful for
later system-checks.

Insert a formatted disk in your floppy-drive
and press Store."));

	  contents    = `VBox(
			      `HBox(
				    `HSquash(
					     `Frame(
						    _("Store system-information on floppy-disk"),
						    `HBox(
							  `HSpacing(1),
							  `VBox(
								`VSpacing(1),
								label,
								`VSpacing(1),
								`HCenter(
									 load_button
									 ),
								`VSpacing(1)
								),
							  `HSpacing(1)
							  )
						    )
					     )
				    )
			      );

	  ReplaceWidget(`id(`contents), contents);
	  ChangeWidget(`id(`help), `Value, WFM::help_text);
      });

      repeat
	  {
	      if (repeated)
	      {
		  string text = _("An error occurred. The system-information
was not correctly stored to the floppy-disk.

Insert a formatted disk in your floppy-drive
and press Store.");

		  UI::ChangeWidget(`id(`osr_floppy_label), `Value, WFM::text);
	      }

	      user_input = UI::UserInput();

	      if (user_input == `osr_floppy_button)
	      {
		  boolean has_floppy    = true;
		  string  floppy_device = "";
      
		  has_floppy    = lookup(user_settings, "has_floppy", false);
		  floppy_device = lookup(user_settings, "floppy_device", "/dev/fd0");
      
		  if (has_floppy)
		  {
		      UI::OpenDialog(`opt(`decorated), `Label(_("Storing system information...")));

		      // mount the floppy to /media/floppy/
		      boolean mounted = (WFM::Execute(.local.bash, "/bin/mount " + floppy_device + " /media/floppy -t auto") == 0);

		      // be careful: only write to the directory /media/floppy if the floppy was mounted
		      // correctly, otherwise the file /media/floppy/osr_map.ycp is saved to harddisk!
		      if (mounted)
		      {
			  boolean file_write = WFM::Write(.local.ycp, "/media/floppy/osr_map.ycp", osr_map);

			  // get osr_map from floppy as test
			  map r = WFM::Read(.local.ycp, "/media/floppy/osr_map.ycp");

			  if (file_write && (r != nil) && (size(r) > 0) && (r == osr_map))
			  {
			      file_written = true;
			  }
		      }
		      // umount the floppy after reading
		      WFM::Execute(.local.bash, "/bin/umount /media/floppy");
  
		      UI::CloseDialog();

		      if (file_written)
		      {
			  OSRPopupDisplayQuick(_("System information is stored."), 1000);

			  osr_map = add(osr_map, "osr_map_stored", true);
		      }
		      else
		      {
			  OSRPopupDisplayQuick(_("System information is not stored."), 1000);
		      }
		  }
	      }
	      repeated = true;
	      
	  } until (file_written || (user_input != `osr_floppy_button));

      if (user_input == `osr_floppy_button)
      {
	  old_osr_map = return_map;
	  user_input  = `next;
      }

      return user_input;
  };

  /**
   *  Checks if the specified partition is of filesystem-type ext2fs.
   *
   *  API function,
   *
   *  @return boolean True if the specified partition is of type ext2fs.
   *  @example boolean is_ext2fs = OSRIsExt2fs("/dev/hda1");
   */
  global define OSRIsExt2fs(string partition) ``{

      integer result = 0;

      result = WFM::Execute(.local.bash, "/sbin/dumpe2fs -h " + partition);

      return (result == 0);
  };

  /**
   *  Checks if the specified partition is of filesystem-type reiserfs.
   *
   *  API function,
   *
   *  @return boolean True if the specified partition is of type reiserfs.
   *  @example boolean is_reiserfs = OSRIsReiserfs("/dev/hda1");
   */
  global define OSRIsReiserfs(string partition) ``{

      integer result = 0;

      result = WFM::Execute(.local.bash, "/sbin/debugreiserfs " + partition);

      return (result == 0);
  };
  
}
