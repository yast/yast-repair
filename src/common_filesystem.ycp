/**
 * File:
 *   common_filesystem.ycp
 *
 * Module:
 *
 * Summary:
 *
 * Author:
 *   Michael Koehrmann <curry@suse.de>
 *
 * $Id$
 */

{
  textdomain "common_filesystem";

  include "partitioning/partition_defines.ycp";
  
  /**
   *  Find the list of valid linux-partitions in the target-map.
   *
   *  Requires: function "get_device_name(string disk, any partition)" from
   *            "include/partitioning/partition_defines.ycp"
   *
   *  @param map target_map The map of targets from the global map "user_settings".
   *  @return list The list of names of valid linux-partitions.
   */
  global define GetLinuxPartitions(map target_map) ``{

      list linux_partition_list = [];

      foreach(`device , `description, target_map, ``{
	  foreach ( `partition, lookup ( description, "partitions", [] ), ``{

	      if ((lookup( partition, "fsid", 0 ) == 131)                 // Linux native partitions
		  || (lookup( partition, "type", `primary ) == `lvm)      // LVM partitions
		  || ((lookup( partition, "fsid", 0 ) == 0)               // empty partitions ??
		      && (lookup( partition, "type", 0 ) == `pdisk)))     // ??
	      {
		  string partition_name = get_device_name( device, lookup ( partition, "nr", 0 ) );

		  linux_partition_list = add(linux_partition_list, partition_name);
	      }
	  });
      });
      
      return linux_partition_list;
  };

  /**
   *  Returns the map of the currently mounted root-partition with the mountpoint "/".
   *
   *  @return map A map for the currently mounted root-partition.
   *  @example GetMountedRootPartition() ->
   *             $[ "name" : "/dev/hda1", "mountpoint" : "/",
   *                "fstype" : "reiserfs", "perm" : "(rw)" ]
   */
  global define GetMountedRootPartition() ``{

      list    mounted_partitions  = [];
      map     root_partition_map  = $[];

      // get a list of all currently mounted partitions
      mounted_partitions = GetMountedPartitions();
      
      // search for the mountpoint "/" in the list of mounted partitions
      //root_partition_list = filter(`partition, mounted_partitions,
      //			   ``(lookup(partition, "mountpoint", "") == "/"));

      // search for the first partition in the list with the mountpoint "/"
      root_partition_map = find(`partition, mounted_partitions, ``(lookup(partition, "mountpoint", "") == "/"));
      
      //list_size = size(root_partition_list);

      if (root_partition_map == nil)
      {
	  y2error("root_partition_map == nil??");
	  
	  return $[];
      }
      else if (root_partition_map == $[])
      {
	  y2debug("No mounted root-partition found");
	  
	  return $[];
      }
      else
      {
	  y2milestone("One root-partition found: %1", root_partition_map);
	  
	  return root_partition_map;
      }

      /*
      if (list_size == 1)
      {
	  y2milestone("One root-partition found: %1", root_partition_list);

	  return select(root_partition_list, 0, "");
      }
      else if (list_size == 0)
      {
	  y2milestone("Currently no partition mounted as root-partition on \"/\"");

	  return $[];
      }
      else if (list_size > 1)
      {
	  y2error("More than one root-partition found?? root-partitions: %1", root_partition_list);
	  y2error("Returning the first detected root-partition: %1", select(root_partition_list, 0));

	  return select(root_partition_list, 0, "");	  
      }
      else
      {
	  y2error("List-size of found root-partitions < 0?? root-partitions: %1", root_partition_list);
      }
      return $[];
      */
  };
  
  /**
   *  Mounts the specified partition as root-partition to /mnt and mounts all
   *  entries in the /mnt/etc/fstab to the system. Also if the currently mounted
   *  root-partition (at mountpoint "/") is the specified one.
   *
   *  @param string partition The name of the partition to mount as root.
   *  @return boolean True if the specified partition was mounted successfully.
   *  @example boolean mounted = MountRoot("/dev/hda1");
   */
  global define MountRoot(string partition) ``{

      boolean success            = true;
      boolean mount_successful   = true;
      list    fstab              = [];
      string  message            = "";
      map     root_partition_map = $[];
      list    mounted_partitions = [];

      y2milestone("selected partition: %1", partition );

      /*
      root_partition_map = GetMountedRootPartition();

      if (lookup(root_partition_map, "name", "") == partition)
      {
	  y2debug("The specified partition \"%1\" is the currently mounted partition: %2", partition, root_partition_map);

	  //return true;
      }
      */

      // check if the specified partition is already mounted to "/mnt", mount only if it is not already done.
      if (!IsMountedTo(partition, "/mnt"))
      {
	  // Mount selected partition to /mnt
	  mount_successful = SCR::Execute(.target.mount, [partition,"/mnt"]);
      }
      else
      {
	  mount_successful = true;
      }
      
      //if ( !test_mode )
      //{
	  if (mount_successful)
	  {
	      // searching for the file /etc/fstab
	      list mountpoint_list = GetMountpoints(partition);

	      // select one of the mountpoints from the list, not important which one of them is chosen
	      string mountpoint = select(mountpoint_list, 0, "");
	      
	      integer fstab_size = SCR::Read(.target.size, "" + mountpoint + "/etc/fstab");

	      if (fstab_size == nil)
	      {
		  y2error("Agent-error, SCR::Read(.target.size, \"%1\") returns nil", "" + mountpoint + "/etc/fstab");
	      }
	      else if (fstab_size < 0)
	      {
		  y2error("No fstab found at %1", "" + mountpoint + "/etc/fstab");
	      }
	      else if (fstab_size == 0)
	      {
		  y2debug("The file %1 exists but is empty??", "" + mountpoint + "/etc/fstab");
	      }
	      else
	      {
		  y2debug("Fstab found, size of the file %1: %2", "" + mountpoint + "/etc/fstab", fstab_size);
	      }

	      UI::OpenDialog(`opt(`decorated), `Label(sformat("Searching /etc/fstab\nfile-size: %1", fstab_size)));
	      sleep(2000);
	      UI::CloseDialog();

	      // Reading fstab and mount all required mount-points to /mnt
	      fstab = SCR::Read(.etc.fstab);

	      if (fstab == nil)
	      {
		  y2error("something's wrong with the .etc.fstab-agent" );
		  message =  UI(_("No fstab found!!"));
		  success = false;
	      }
	      else if (size(fstab) == 0)
	      {
		  y2error("no fstab found !!" );
		  message =  UI(_("No fstab found!!"));
		  success = false;
	      }
	      else
	      {
		  y2milestone("fstab :%1 ", fstab );

		  // mount resp. swapon all partitions mentioned in the fstab
		  foreach( `fstab_entry, fstab, ``{
		  
		      string vfstype = lookup(fstab_entry, "vfstype", "");
		      string mntops  = lookup(fstab_entry, "mntops", "");
		      string spec    = lookup(fstab_entry, "spec", "");
		      string file    = lookup(fstab_entry, "file", "");

		      // mounting the "normal" filesystems
		      // attention: "nfs"-filesystems are not mounted here!
		      if ((vfstype == "ext" || vfstype == "ext2" || vfstype == "minix" || vfstype == "reiserfs" ||
			   vfstype == "xiafs" || vfstype == "hpfs" || vfstype == "vfat") &&
			  (file != "/") && (!issubstring(mntops,"noauto")))
		      {
			  if (MountFstabEntry(fstab_entry))
			  {
			      success = true;
			  }
		      }

		      // include swap-partitions
		      if ((vfstype == "swap")  && (file == "swap"))
		      {
			  if (SwaponFstabEntry(fstab_entry))
			  {
			      success = true;
			  }
		      }
		  });
	      }
	  }
	  else
	  {
	      message = _("Partitions could not be mounted.
Check log-file : /var/log/y2log.");
	      y2error("Could not mount root-partition to /mnt");
	      success = false;
	  } // end: if (mount_successful)
	  
	  //} //end: if (test_mode)
      
      if (!success)
      {
	  UI::OpenDialog(`opt(`decorated), `Label(message));
	  sleep(2000);
	  UI::CloseDialog();
      }
      return success;
  };

  /**
   *  Returns a list of names of all mountable partitions that contain a file /etc/fstab
   *  out of the specified list.
   *
   *  @param list linux_partition_list A list of valid linux-partitions out of which
   *         the mountable partitions are to be returned.
   *  @return list The list of partition-names that were successfully mounted to /mnt and contain a filesystem table.
   */
  global define GetValidRootPartitions(list linux_partition_list) ``{

      list valid_root_partitions = [];
      
      foreach(`partition_item, linux_partition_list, ``{

	  boolean ret_bool = true;
	  list    fstab    = [];

	  // as default: umount /mnt before mount anything else
	  SCR::Execute(.target.umount, "/mnt");
	  
	  // Mount partition to /mnt
	  // TODO: demo_mode && test_mode
	  ret_bool = SCR::Execute(.target.mount, [partition_item, "/mnt"]);

	  if ( ret_bool )
	  {
	      // use the .target.size agent instead of the .etc.fstab agent because it finds the
	      // fstab of the currently mounted root partition
	      if (SCR::Read(.target.size, "/mnt" + "/etc/fstab") > 0)
	      {
		  y2debug("Partition %1: fstab found", partition_item);
		  
		  valid_root_partitions = add(valid_root_partitions, partition_item);
	      }
	      else
	      {
		  y2debug("Partition: %1; no fstab found", partition_item);
	      }
	  }
	  else
	  {
	      y2error("Partition: %1; not possible to mount to /mnt", partition_item);
	  }
      });
      
      // umount the partition
      SCR::Execute(.target.umount, "/mnt");

      return valid_root_partitions;
  };
  
  /**
   *  Returns a list of names of all mountable partitions out of the specified list.
   *
   *  @param list linux_partition_list A list of valid linux-partitions out of which
   *         the mountable partitions are to be returned.
   *  @return list The list of partition-names that were successfully mounted to /mnt.
   */
  global define GetMountablePartitions(list linux_partition_list) ``{

      list mount_possible_list = [];
      
      foreach(`partition_item, linux_partition_list, ``{

	  // as default: umount /mnt before mount anything else
	  SCR::Execute(.target.umount, "/mnt");
	  
	  // Mount partition to /mnt
	  // TODO: demo_mode && test_mode
	  boolean ret_bool = SCR::Execute(.target.mount, [partition_item, "/mnt"]);

	  if ( ret_bool )
	  {
	      mount_possible_list = add(mount_possible_list, partition_item);

	      SCR::Execute(.target.umount, "/mnt");
	  }
      });
      
      return mount_possible_list;
  };

  /**
   *  Get all valid swap-partitions.
   *
   *  @param map target_map The map that contains all informations about all detected harddisks and all partitions.
   *  @return list The list of valid swap-partitions.
   */
  global define GetSwapPartitions(map target_map) ``{

      list swap_partition_list = [];
      
      foreach(`device , `description, target_map, ``{
	  foreach ( `partition, lookup ( description, "partitions", [] ), ``{
	      
	      if (lookup( partition, "fsid", 0 ) == 130)                 // Linux swap partitions
	      {
		  string partition_name = get_device_name(device, lookup(partition, "nr", 0));

		  swap_partition_list = add(swap_partition_list, partition_name);
	      }
	  });
      });

      return swap_partition_list;
  };

  /**
   *  Umounts all partitions from the specified mountpoint and deeper, e.g. "/mnt", "/mnt/usr", "/mnt/usr/local", ...
   *
   *  @param string mountpoint The mountpoint.
   *  @return boolean True if all partitions were umounted from the specified mountpoint.
   */
  global define UmountAllFrom(string mountpoint) ``{

      list    mounted_partitions = [];
      list    mnt_list           = [];
      integer counter            = 0;
      integer counter_max        = 0;

      // returns a list like:
      // [$["name" : "/dev/hda1", "mountpoint" : "/", "fstype" : "reiserfs", "perm" : "(rw)"], ...]
      mounted_partitions = GetMountedPartitions();

      // filter the list of partitions that are mounted to "/mnt" or deeper
      mnt_list = filter(`s, mounted_partitions, ``(substring(lookup(s, "mountpoint", ""), 0, size(mountpoint)) == mountpoint));

      // the repeat loop should only be evaluated as many times as there are mounted partitions in the list
      counter_max = size(mnt_list);

      if (size(mnt_list) == 0)
      {
	  return true;
      }
      
      // umount all partitions from "/mnt" or deeper, as long as there are no more mounted partitions with
      // mountpoint "/mnt..."
      repeat
	  {
	      // umount these
	      foreach(`k, mnt_list, ``{

		  SCR::Execute(.target.umount, lookup(k, "mountpoint", ""));
	      });

   	      // returns a list like:
	      // [$["name" : "/dev/hda1", "mountpoint" : "/", "fstype" : "reiserfs", "perm" : "(rw)"], ...]
	      mounted_partitions = GetMountedPartitions();

	      // filter the list of partitions that are mounted to "/mnt" or deeper
	      mnt_list = filter(`s, mounted_partitions, ``(substring(lookup(s, "mountpoint", ""), 0, size(mountpoint)) == mountpoint));

	      counter = counter + 1;

	  } until ((size(mnt_list) == 0) || (counter > counter_max));

      if (size(mnt_list) == 0)
      {
	  return true;
      }

      return false;
  };
  
  /**
   *  Checks if the partition is already mounted to the specified mountpoint.
   *
   *  @param string partition The name of the partition to check.
   *  @param string mountpoint The name of the mountpoint to check.
   *  @return boolean True if the specified partition is already mounted to the specified mountpoint.
   */
  global define IsMountedTo(string partition, string mountpoint) ``{

      boolean already_mounted    = false;
      list    mounted_partitions = [];
      
      // returns a list like:
      // [$["name" : "/dev/hda1", "mountpoint" : "/", "fstype" : "reiserfs", "perm" : "(rw)"], ...]
      mounted_partitions = GetMountedPartitions();

      // iterate all mounted partitions
      foreach(`mounted_partition, mounted_partitions, ``{

	  // check if the specified partition is already mounted to the mountpoint
	  if ((lookup(mounted_partition, "name", "") == partition) && (lookup(mounted_partition, "mountpoint", "") == mountpoint))
	  {
	      already_mounted = true;
	  }
      });
      return already_mounted;
  };

  /**
   *  Checks if the specified partition is of filesystem-type ext2fs.
   *
   *  @param string partition The device-name of the partition.
   *  @return boolean True if the partition is ext2fs.
   *  @example boolean is_ext2fs = IsExt2fs("/dev/hda1");
   */
  global define IsExt2fs(string partition) ``{

      integer is_ext2fs = 0;
      
      is_ext2fs = WFM::Execute(.local.bash, "/sbin/dumpe2fs -h " + partition );

      if (is_ext2fs == 0)
      {
	  y2milestone("partition %1 is ext2fs", partition);
      }
      else if (is_ext2fs == nil)
      {
	  y2error("IsExt2fs ERROR: something's wrong with the command \"/sbin/dumpe2fs -h %1\" or the bash-agent.", partition);
      }
      else
      {
	  y2milestone("partition %1 is NOT ext2fs", partition);
      }

      return (is_ext2fs == 0);
  };

  /**
   *  Checks if the specified partition is of filesystem-type reiserfs.
   *
   *  @param string partition The device-name of the partition.
   *  @return boolean True if the partition is reiserfs.
   *  @example boolean is_reiserfs = IsReiserfs("/dev/hda1");
   */
  global define IsReiserfs(string partition) ``{

      integer is_reiserfs = 0;
      
      is_reiserfs = WFM::Execute(.local.bash, "/sbin/debugreiserfs " + partition);
      
      if (is_reiserfs == 0)
      {
	  y2milestone("partition %1 is reiserfs", partition);
      }
      else if (is_reiserfs == nil)
      {
	  y2error("IsReiserfs ERROR: something's wrong with the command \"/sbin/debugreiserfs %1\"", partition);
      }
      else
      {
	  y2milestone("partition %1 is NOT reiserfs", partition);
      }
      return (is_reiserfs == 0);
  };

  /**
   *  Checks the specified partition for consistency with "/sbin/e2fsck".
   *
   *  @param string partition The device-name of the partition.
   *  @return integer The exit code of the e2fsck command. See man 8 e2fsck for details.
   *      The exit code returned by e2fsck is the sum of the following conditions:
   *      0 - No errors,
   *      1 - File system errors corrected,
   *      2 - File system errors corrected, system should be rebooted if file system was mounted,
   *      4 - File system errors left uncorrected,
   *      8 - Operational error,
   *      16 - Usage or syntax error,
   *      128 - Shared library error.
   *  @example integer check_ext2fs = CheckExt2fs("/dev/hda1");
   */
  global define CheckExt2fs(string partition) ``{

      integer check_ext2fs = 0;
      string  command      = "/sbin/e2fsck -y " + partition;
      
      check_ext2fs = WFM::Execute(.local.bash, command);

      if (check_ext2fs == nil)
      {
	  y2error("CheckExt2fs ERROR: something's wrong with the command \"%1\" or the calling agent", command);
      }
      else if (check_ext2fs == 0)
      {
	  y2milestone("partition %1 is o.k., /sbin/e2fsck reports no errors", partition);
      }
      else if (check_ext2fs == 1)
      {
	  y2milestone("/sbin/e2fsck reports \"File system errors corrected\" for partition %1", partition);
      }
      else if (check_ext2fs == 2)
      {
	  y2milestone("/sbin/e2fsck reports \"File system errors corrected, system should \
be rebooted if file system was mounted\" for partition %1", partition);
      }
      else if (check_ext2fs == 4)
      {
	  y2error("/sbin/e2fsck reports \"File system errors left uncorrected\" for partition %1", partition);
      }
      else if (check_ext2fs == 8)
      {
	  y2error("/sbin/e2fsck reports \"Operational error\" for partition %1, command line: %2", partition, command);
      }
      else if (check_ext2fs == 16)
      {
	  y2error("/sbin/e2fsck reports \"Usage or syntax error\" for partition %1, command line: %2", partition, command);
      }
      else if (check_ext2fs == 128)
      {
	  y2error("/sbin/e2fsck reports \"Shared library error\" for partition %1, command line: %2", partition, command);
      }
      else
      {
	  y2error("/sbin/e2fsck reports an error: %1, command line: %2", check_ext2fs, command);
      }

      return check_ext2fs;
  };

  /**
   *  Checks the specified partition for consistency with "/sbin/reiserfsck".
   *
   *  @param string partition The device-name of the partition.
   *  @param string logfile The name of the log file. If the empty string is specified, no log file will be used.
   *  @return integer The exit code of the reiserfsck command. See man 8 fsck for details.
   *      The exit code returned by fsck is the sum of the following conditions:
   *      0 - No errors,
   *      1 - File system errors corrected,
   *      2 - File system errors corrected, system should be rebooted if file system was mounted,
   *      4 - File system errors left uncorrected,
   *      8 - Operational error,
   *      16 - Usage or syntax error,
   *      128 - Shared library error.
   *  @example integer check_reiserfs = CheckReiserfs("/dev/hda1", "/tmp/reiserfsck.log");
   */
  global define CheckReiserfs(string partition, string logfile) ``{

      integer check_reiserfs = 0;
      string  command        = "";
      string  output         = logfile;
      
      // check if a log file was specified
      if (logfile == "")
      {
	  command = sformat("echo Yes | /sbin/reiserfsck -x %1", partition);
      }
      else
      {
	  command = sformat("echo Yes | /sbin/reiserfsck -x -l %1 %2 2> %3", logfile, partition, output);
      }

      // execute the reiserfsck command
      check_reiserfs = WFM::Execute(.local.bash, command);

      if (check_reiserfs == nil)
      {
	  y2error("CheckReiserfs ERROR: something's wrong with the command \"%1\" or the calling agent", command);
      }
      else if (check_reiserfs == 0)
      {
	  y2milestone("partition %1 is o.k., /sbin/reiserfsck reports no errors", partition);
      }
      else if (check_reiserfs == 1)
      {
	  y2milestone("/sbin/reiserfsck reports \"File system errors corrected\" for partition %1", partition);
      }
      else if (check_reiserfs == 2)
      {
	  y2milestone("/sbin/reiserfsck reports \"File system errors corrected, system should \
be rebooted if file system was mounted\" for partition %1", partition);
      }
      else if (check_reiserfs == 4)
      {
	  y2error("/sbin/reiserfsck reports \"File system errors left uncorrected\" for partition %1", partition);
      }
      else if (check_reiserfs == 8)
      {
	  y2error("/sbin/reiserfsck reports \"Operational error\" for partition %1, command line: %2", partition, command);
      }
      else if (check_reiserfs == 16)
      {
	  y2error("/sbin/reiserfsck reports \"Usage or syntax error\" for partition %1, command line: %2", partition, command);
      }
      else if (check_reiserfs == 128)
      {
	  y2error("/sbin/reiserfsck reports \"Shared library error\" for partition %1, command line: %2", partition, command);
      }
      else
      {
	  y2error("/sbin/reiserfsck reports an error: %1, command line: %2", check_reiserfs, command);
      }

      return check_reiserfs;
  };

  /**
   *  Use the specified partition as swap-partition.
   *
   *  @param map fstab_entry The fstab-entry of the partition to be swapped-on.
   *  @return boolean True if the specified partition was successfully swapped-on.
   *  @example map fstab_entry = $["file":"swap", "freq":0, "mntops":"pri=41", "passno":0, "spec":"/dev/hda2", "vfstype":"swap"];
   *  @example boolean swapon = SwaponFstabEntry(fstab_entry);
   */
  global define SwaponFstabEntry(map fstab_entry) ``{

      // an entry in the fstab looks like
      //  $["file":"swap", "freq":0, "mntops":"pri=41", "passno":0, "spec":"/dev/hda2", "vfstype":"swap"]
      
      string  vfstype       = lookup(fstab_entry, "vfstype", "");
      string  spec          = lookup(fstab_entry, "spec", "");
      string  file          = lookup(fstab_entry, "file", "");
      string  command       = "";
      integer swapon_result = -1;
      list    proc_swaps    = [];

      // looks like:
      // [$["file":"/dev/sda1", "priority":"42", "size":"52200", "type":"partition", "used":"21336"]]
      proc_swaps = SCR::Read(.proc.swaps);

      // Check if the specified swap-partition is already "swapped", if true don't swapon.
      // filter(...) returns a list of all "swapped" partitions where the name equals to the specified partition
      if (size(filter(`swap_partition, proc_swaps, ``(lookup(swap_partition, "file", "") == spec))) > 0)
      {
	  y2debug("Swap-partition \"%1\" is already swapped-on!", spec);

	  /*
	      UI::OpenDialog(`opt(`decorated), `Label(sformat("Swapon: %1 already swapped-on\n%2", spec, proc_swaps)));
	      sleep(5000);
	      UI::CloseDialog();
	  */
	  
	  return true;
      }
	  
      // include swap-partitions
      if ((vfstype == "swap")  && (file == "swap"))
      {
	  if (spec != "")
	  {
	      //swap-partition
	      command = "/sbin/swapon " + spec;
	      
	      // run /sbin/swapon
	      swapon_result = WFM::Execute (.local.bash, command);

	      if (swapon_result == nil)
	      {
		  y2error("an error occurred during execution of \"%1\"", command);
	      }
	      else if (swapon_result == 0)
	      {
		  y2milestone("swapon succeeded: \"%1\"", command);
	      }
	      else
	      {
		  y2error("swapon failed: \"%1\"", command);
	      }
	  }
	  else
	  {
	      y2error("not a valid fstab-entry: %1", fstab_entry);
	  }
      }
      else
      {
	  y2error("not a valid fstab-entry: %1", fstab_entry);
      }

      /*
      	      UI::OpenDialog(`opt(`decorated), `Label(sformat("Swapon result: %1", swapon_result)));
	      sleep(2000);
	      UI::CloseDialog();
      */
      
      return (swapon_result == 0);
  };

  /**
   *  Mount the specified partition to /mnt/<file>.
   *
   *  @param map fstab_entry The fstab-entry of the partition to mount.
   *  @return boolean True if the specified entry in the fstab was successfully mounted.
   */
  global define MountFstabEntry(map fstab_entry) ``{

      string  vfstype         = lookup(fstab_entry, "vfstype", "");
      string  mntops          = lookup(fstab_entry, "mntops", "");
      string  spec            = lookup(fstab_entry, "spec", "");
      string  file            = lookup(fstab_entry, "file", "");
      boolean success         = false;

      // mounting the "normal" filesystems
      // attention: "nfs"-filesystems are not mounted here!
      if ((vfstype == "ext" || vfstype == "ext2" || vfstype == "minix" || vfstype == "reiserfs" ||
	   vfstype == "xiafs" || vfstype == "hpfs" || vfstype == "vfat") &&
	  ((file != "/") && (!issubstring(mntops,"noauto"))))
      {
	  y2milestone("mounting %1 to /mnt%2", spec, file);

	  // check the fs-type: ext2 or reiserfs, others have to be implemented
	  if ((vfstype == "ext2") && (IsExt2fs(spec)))
	  {
	      // run fsck.ext2, see man 8 fsck for details on the error codes
	      if (CheckExt2fs(spec) == 0)
	      {
		  y2milestone("Partition %1 is a consistent ext2-filesystem", spec);
	      }
	      else
	      {
		  y2error("Partition %1 is not a consistent ext2-filesystem", spec);
	      }
	  }
	  else if((vfstype == "reiserfs") && (IsReiserfs(spec)))
	  {
	      // run fsck.reiserfs, see man 8 fsck for details on the error codes
	      if (CheckReiserfs(spec, "") == 0)
	      {
		  y2milestone("Partition %1 is a consistent reiserfs", spec);
	      }
	      else
	      {
		  y2error("Partition %1 is not a consistent reiserfs", spec);
	      }
	  }

	  // if the mount-options contain "ro", it is not possible to mount the specified partition to /mnt/...
	  if (issubstring(mntops,"ro,") || issubstring(mntops,",ro") || mntops == "ro")
	  {
	      y2error("Mounting %1 on %2 is only possible for permissions \"ro\" after reboot.", spec, "/mnt"+file);
	      y2error("Please change /etc/fstab");
 	      success = false;
	  }
	  else
	  {
	      // mount the partition to /mnt/...
	      boolean mount_partition = SCR::Execute(.target.mount, [spec, "/mnt" + file]);

	      if (mount_partition == nil)
	      {
		  y2error("error: %1", spec, "/mnt"+file);
		  success = false;
	      }
	      else if (!mount_partition)
	      {
		  y2error("mounting %1 on %2 failed", spec, "/mnt"+file);
		  success = false;
	      }
	      else
	      {
		  y2milestone("mounting succeeded: %1 on %2", spec, "/mnt"+file);
		  success = true;
	      }
	  }
      }
      return success;
  };

  /**
   *  Get the list of maps of all currently mounted partitions.
   *
   *  @return list A list of maps, one map for each mounted partition.
   *  @example list mounted = GetMountedPartitions();
   *           -> [$["name" : "/dev/hda1", "mountpoint" : "/", "fstype" : "reiserfs", "perm" : "(rw)"], ...]
   */
  global define GetMountedPartitions() ``{

      map    return_map         = $[];
      list   row_list           = [];
      list   mounted_partitions = [];

      // looks like:
      // ($[
      //    "exit":0,
      //    "stderr":"",
      //    "stdout":"/dev/hda1 on / type reiserfs (rw)\n
      //              proc on /proc type proc (rw)\n
      //              devpts on /dev/pts type devpts (rw,mode=0620,gid=5)\n
      //              shmfs on /dev/shm type shm (rw)\n
      //              /dev/hda1 on /mnt type reiserfs (rw)\n
      //              usbdevfs on /proc/bus/usb type usbdevfs (rw)\n"
      // ])
      return_map = SCR::Execute(.target.bash_output, "/bin/mount");

      if (lookup(return_map, "exit", 1) == 0)
      {
	  row_list = splitstring(lookup(return_map, "stdout", ""), "\\\n");
      }

      foreach(`row, row_list, ``{
	  
	  // each row looks like this:
	  // <partition_name> on <mountpoint> type <fs_type> <permissions>
	  list   string_list    = splitstring(row, " ");
	  string partition_name = select(string_list, 0, "");
	  string mountpoint     = select(string_list, 2, "");
	  string fs_type        = select(string_list, 4, "");
	  string permissions    = select(string_list, 5, "");

	  // only add "real" partitions to the list, like
	  // "/dev/hda1 on / type reiserfs (rw)",
	  // not mounted devices like
	  // "proc on /proc type proc (rw)", "devpts on /dev/pts type devpts (rw,mode=0620,gid=5)",
	  // "shmfs on /dev/shm type shm (rw)", "usbdevfs on /proc/bus/usb type usbdevfs (rw)", ...
	  if ((partition_name != nil) &&
	      (partition_name != "") &&
	      (mountpoint != nil) &&
	      (mountpoint != "") &&
	      (substring(partition_name, 0, 5) == "/dev/"))
	  {
	      map partition_map  = $[
				     "name"       : partition_name,
				     "mountpoint" : mountpoint,
				     "fstype"     : fs_type,
				     "perm"       : permissions
	      ];
	      
	      mounted_partitions = add(mounted_partitions, partition_map);
	  }
	  else
	  {
	      //y2error("partition: \"%1\", mountpoint: \"%2\", fstype: \"%3\", perm: \"%4\"", partition_name, mountpoint, fs_type, permissions);
	  }

      });
      return mounted_partitions;
  };


 /**
  *  Get the list of mountpoints of the specified partition.
  *
  *  @param string partition The name of the partition.
  *  @return list The list of mountpoints of the specified device, the empty list if the partition is not mounted.
  */
  global define GetMountpoints(string partition) ``{

      list mounted_partitions = [];
      list partition_list     = [];
      list mountpoints        = [];

      // get the currently mounted partitions
      mounted_partitions = GetMountedPartitions();

      // filters all partition-maps of the specified partition
      partition_list = filter(`part, mounted_partitions, ``(lookup(part, "name", "") == partition));

      // get the list of mountpoints
      mountpoints = maplist(`v, partition_list, ``(lookup(v, "mountpoint", "")));

      /*
      UI::OpenDialog(`opt(`decorated), `Label(sformat("GetMountpoints(%1)\nMounted partitions\n\"%2\"\nPartition_list:\n%3\nMountpoints: %4", partition, mounted_partitions, partition_list, mountpoints)));
      sleep(10000);
      UI::CloseDialog();      
      */
      
      return mountpoints;
  };

 /**
  *  Get the filesystem type of the specified partition.
  *
  *  @param string partition The name of the partition.
  *  @return string The filesystem type. Possible values are "ext2", "reiserfs", "unknown".
  */  
  global define GetFilesystemType(string partition) ``{

      string partition_type = "";

      if (IsExt2fs(partition))
      {
	  partition_type = "ext2";
      }
      else if (IsReiserfs(partition))
      {
	  partition_type = "reiserfs";
      }
      else
      {
	  partition_type = "unknown";
      }
      return partition_type;
  };
}
