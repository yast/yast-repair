/**
 * functions used for checkning GRUB configuration
 * originaly from bootloader/src/grub/misc.ycp, yast2-bootloader now
 * doesn't provide this API
 *
 * Author: Jiri Suchomel <jsuchome@suse.cz>
 *
 * $Id$
 */
{
    import "BootCommon";

    map<string,string> device_map	= $[];



    global define void readDeviceMap () {

	BootCommon::InitializeLibrary (true, "grub");
	BootCommon::ReadFiles ();
	device_map	= BootCommon::GetDeviceMap ();
	y2debug ("device map: %1", device_map);
    }


    /**
      * translate grub device (hd0) to UNIX device /dev/hda
      * @param o_dev string grub device
      * @return string UNIX device
      */
    global define string grubDev2unixDev (string o_dev) {

	string ret	= "";
	foreach (string k, string v, device_map, {
	    y2debug ("key: %1, val: %2, o_dev: %3", k, v, o_dev);
	    if (v == o_dev)
	    {
		ret	= k;
	    }
	});
	return ret;
    }

    /**
      * parse /etc/grub file from other file
      * @param file string contents of grub.conf file
      * @return map of settings
      */
    global define map<string,string> parseGrubConf (string file) {

	if (file == "" || file == nil)
	    return $[];

	if (size (device_map) == 0)
	    readDeviceMap ();

	list<string> lines = splitstring (file, "\n");
	lines = filter (string l, lines, ``(l != ""));
	map<string,string> settings = $[];
	list<string> devices = [];
	string root = "";
	foreach (string l, lines, ``{
	    list<string> entries = splitstring (l, " ");
	    entries = filter (string e, entries, ``(e != ""));
	    if (entries[0]:"" == "root")
	        root = entries[1]:"";
	    else if (entries[0]:"" == "install")
	    {
	        integer shift = 0;
		integer shift1 = 1 + shift;
	        string tmp = entries[shift1]:"";
	        while (substring (tmp, 0, 2) == "--")
	        {
		    string prefix = settings["prefix"]:"";
		    prefix = prefix + " " + tmp;
	            settings = add (settings, "prefix", prefix);
	            shift = shift + 1;
		    shift1 = 1 + shift;
	            tmp = entries[shift1]:"";
	        }
	        settings = add (settings, "stage1", tmp);
		integer shift2 = 2 + shift;
	        tmp = entries[shift2]:"";
	        if ("d" == tmp)
	        {
	            settings = add (settings, "discswitch", "d");
	            shift = shift + 1;
		    integer shift2 = 2 + shift;
	            tmp = entries[shift2]:"";
	        }
		devices = add (devices, tmp);
	        settings = add (settings, "device", grubDev2unixDev (tmp));
		integer shift3 = 3 + shift;
	        tmp = entries[shift3]:"";
	        settings = add (settings, "stage2", tmp);
		integer shift4 = 4 + shift;
	        tmp = entries[shift4]:"";
	        settings = add (settings, "addr", tmp);
		integer shift5 = 5 + shift;
	        tmp = entries[shift5]:"";
	        if (substring (tmp, 0, 1) == "/")
	            tmp = sformat ("%1%2", root, tmp);
	        settings = add (settings, "menu", tmp);
		settings = add (settings, "command", "install");
	    }
	    else if (entries[0]:"" == "setup")
	    {
	        integer shift = 0;
		integer shift1 = 1 + shift;
	        string tmp = entries[shift1]:"";
	        while (substring (tmp, 0, 2) == "--")
	        {
		    string prefix = settings["prefix"]:"";
		    prefix = prefix + " " + tmp;
	            settings = add (settings, "prefix", prefix);
	            shift = shift + 1;
		    shift1 = 1 + shift;
	            tmp = entries[shift1]:"";
	        }
	        settings = add (settings, "device", tmp);
		settings = add (settings, "command", "setup");
	    }
	    settings = add (settings, "root", root);
	});
	return settings;
    }

    global list<string> GetSpecialOptions () {
       list<string> special = [];
       string bl = BootCommon::getLoaderType (false);
       if (bl != "grub")
       {
           special = [ "change-rules", "type", "reset", "normal", "hidden",
               "disk", "heads", "inaccessible", "cylinders", "bios",
               "sectors", "change", "set", "partition", "deactivate",
               "partition", "automatic", "map-drive", "to",
           ];
       }
       if (bl != "ppc")
       {
           special = add (special, "activate");
       }
       return special;
    }

    /**
      * return true if given option is special
      * @param opt option name
      * @return boolean special/not
      */
    global define boolean isSpecial(string opt) {
       list<string> special = GetSpecialOptions ();
       return (contains (special, opt));
    }
}
