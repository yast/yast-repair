/**
 *  File:
 *    osr_system.ycp
 *
 *  Module:
 *    YaST2 OS Repair - automatic error detection & repair tool for Linux.
 *
 *  Summary:
 *    This file provides the framework of the YaST2 OS Repair tool. It contains some
 *    main functions that control the detection and repair process and some additional
 *    functions which form the interface for the detection and repair modules.
 *
 *  Author:
 *    Michael Koehrmann <curry@suse.de>
 */

{
  textdomain "osr";
  
  /**
   *  Checks if the first specified list (of strings) is a subset of the second one. The sequence
   *  of entries in the lists is nonrelevant.
   *
   *  For internal use only.
   *
   *  @example OSRIsSubSet([], ["a", "b"]) -> true;
   *  @example OSRIsSubSet(["a"], ["a", "b"]) -> true;
   *  @example OSRIsSubSet(["c"], ["a", "b"]) -> false;
   *  @example OSRIsSubSet(["a", "b", "c"], ["a", "b"]) -> false;
   *  @param list The first list.
   *  @param list The second list.
   *  @return boolean True if all elements of l1 are contained in l2 or if l1 is empty.
   */
  global define OSRIsSubSet(list l1, list l2) ``{

      integer index = 0;

      // remove duplicate entries and sort the lists
      l1 = toset(l1);
      l2 = toset(l2);

      // check special cases
      if ((size(l1) < 0) || (size(l2) < 0))
      {
	  y2error("ERROR OSRIsSubSet: list size can't be negative: size of %1 = %2; size of %3 = %4", l1, size(l1), l2, size(l2));
	  return false;
      }
      else if (size(l1) > size(l2))
      {
	  y2debug("OSRIsSubSet: %1 is greater than %2!", l1, l2);
	  return false;
      }
      else if ((size(l1) == 0))
      {
	  y2debug("OSRIsSubSet: %1 is empty -> l1 is subset of l2!", l1);
	  return true;
      }
      else if (size(l1) <= size(l2))
      {
	  y2debug("OSRIsSubSet: comparing the elements: %1, %2", l1, l2);

	  // this is the main subset-checker
	  while ((index >= 0) && (index < size(l1)))
	  {
	      if ( !contains(l2, select(l1, index)) )
	      {
		  y2debug("OSRIsSubSet: element %1 not contained in %2", select(l1, index), l2);
		  return false;
	      }
	      index = index + 1;
	  }
	  y2debug("OSRIsSubSet: %1 is a real subset of %2", l1, l2);	  
	  return true;
      }
      else
      {
	  y2error("ERROR OSRIsSubSet: something's wrong with %1 and %2", l1, l2);	  
	  return false;
      }
  };

  /**
   *  This method resolves the requirements and provides of the modules and computes
   *  the correct sequence of detection modules.
   *
   *  For internal use only.
   *
   *  @return boolean True if the module sequence was successfully created.
   */
  global define OSRComputeModuleSequence() ``{

      integer index                = 0;
      string  module_name          = "";
      list    global_provides_list = [];
      list    module_provides_list = [];
      list    module_requires_list = [];
      list    module_list          = [];
      list    module_sequence      = [];

      // get the lists from the global osr_map
      module_list     = lookup(osr_map, "module_list");
      module_sequence = lookup(osr_map, "module_sequence");

      while ((index >= 0) && (index < size(module_list)))
      {
	  // get the module name and its requirements
	  module_name          = select(module_list, index);
	  module_requires_list = lookup(lookup(osr_map, module_name), "requires");

	  // check if the requirements of the current module are resolved by the global provides
	  if (OSRIsSubSet(module_requires_list, global_provides_list))
	  {
	      // if true add this module as next module in the sequence list, remove it from the
	      // list of modules and decrease the size of the list
	      module_sequence  = add(module_sequence, module_name);
	      module_list      = remove(module_list, index);
	      index            = 0;

	      // get the module_provides_list from the osr_map, use maplist to only put the key-names to the list
	      module_provides_list = maplist(`k, `v, lookup(lookup(osr_map, module_name), "provides"), ``(k));

	      // concatenate, sort and remove duplicates of the global_provides_list and the module_provides_list
	      global_provides_list = toset(union(global_provides_list, module_provides_list));
	  }
	  else
	  {
	      index = index + 1;
	  }
      }

      // add the new module sequence and the global provides to the osr_map
      osr_map = add(osr_map, "module_sequence",      module_sequence);
      osr_map = add(osr_map, "module_list",          module_list);
      osr_map = add(osr_map, "global_provides_list", global_provides_list);

      if (size(module_list) != 0)
      {
	  y2error("ERROR OSRComputeModuleSequence: module(s) not added to the sequence list: %1", module_list);
	  return false;
      }
      return true;
  };

  /**
   *  Only for the testsuite.
   *
   *  For internal use only.
   *
   *  @return map The global osr_map.
   */
  global define OSRTestGetOsrMap() ``{

      return osr_map;
  };

  /**
   *  Returns true if the special DownloadProgress widget is supported by
   *  the running UI. True with QT, false with ncurses.
   *
   *  For internal use only.
   *
   *  @return boolean True if the DownloadProgress widget is supported.
   */
  global define OSRHasDownloadProgressWidget() ``{

      return lookup(osr_map, "has_download_progress_widget", true);
  };

  /**
   *
   *
   *  For internal use only.
   *
   *  @return boolean True if 
   */
  global define OSROpenMainWindow() ``{

      string header         = "";
      string execution_mode = "";

      execution_mode = lookup(osr_map, "execution_mode", "linux");
      
      if (execution_mode == "linux")
      {

      }
      else if (execution_mode == "cdrom")
      {
	  UI::ChangeWidget(`id(`abort), `Label, _("&Abort"));
      }
      else if (execution_mode == "nfs")
      {
	  UI::ChangeWidget(`id(`abort), `Label, _("&Abort"));
      }
      else
      {
	  y2error("unknown execution_mode: %1", execution_mode);
      }

      if (!script_mode)
      {
	  header = _("YaST2 OS Repair");

	  if (demo_mode)
	  {
	      header = _("YaST2 OS Repair: demo mode");
	  }
	  else if (automatic_mode)
	  {
	      header = _("YaST2 OS Repair: automatic mode");
	  }
      
	  // display the main window to indicate progress

	  if (execution_mode == "linux")
	  {
	      UI(``{
		  OpenDialog(`opt(`defaultsize),
			     `VBox(`Image(`suseheader, "SuSE"),
				   `HBox(`HWeight(30, `RichText(`id(`help), "")),
					 `HWeight(70, `VBox(
							    `Left(`Heading(`id(`title), `opt(`hstretch),
									   WFM::header + _("\nInitialization..."))),
							    `HVCenter(`ReplacePoint(`id(`contents), `Empty())),
							    `HBox(
								  // Back pushbutton: the user input is ignored and the last dialog is called
								  `PushButton(`id(`back), `opt(`disabled), _("&Back")),
								  `HStretch(),

								  // Skip pushbutton
								  //`PushButton(`id(`skip), `opt(`disabled), _("&Skip")),
								  //`HStretch(),

								  // Abort pushbutton
								  `PushButton(`id(`abort), `opt(`disabled), _("&Abort")),
								  `HStretch(),

								  // Next pushbutton
								  `PushButton(`id(`next), `opt(`disabled), _("&Next"))
								  )
							    )
						  )
					 )
				   )
			     );
		  ChangeWidget(`id(`back), `Enabled, true);
		  ChangeWidget(`id(`abort), `Enabled, true);
		  ChangeWidget(`id(`next), `Enabled, true);
		  SetFocus(`id(`next));
	      });
	  }

	  /*
	    if (!UI::HasSpecialWidget(`DownloadProgress))
	    {
	    //osr_map = add(osr_map, "has_download_progress_widget", false);

	    if (!automatic_mode)
	    {
	    // show error message
	    UI::ErrorPopup(_("Some special widgets are not available."));

	    return false;
	    }
	    }
	  */
      }

      return true;

  };
}
