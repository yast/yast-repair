/**
 *  File:
 *    osr_system.ycp
 *
 *  Module:
 *    YaST2 OS Repair - automatic error detection & repair tool for Linux.
 *
 *  Summary:
 *    This file provides the framework of the YaST2 OS Repair tool. It contains some
 *    main functions that control the detection and repair process and some additional
 *    functions which form the interface for the detection and repair modules.
 *
 *  Author:
 *    Michael Koehrmann <curry@suse.de>
 */

{
  textdomain "osr";
  
  /**
   *  Checks if the first specified list (of strings) is a subset of the second one. The sequence
   *  of entries in the lists is nonrelevant.
   *
   *  For internal use only.
   *
   *  @example OSRIsSubSet([], ["a", "b"]) -> true;
   *  @example OSRIsSubSet(["a"], ["a", "b"]) -> true;
   *  @example OSRIsSubSet(["c"], ["a", "b"]) -> false;
   *  @example OSRIsSubSet(["a", "b", "c"], ["a", "b"]) -> false;
   *  @param list The first list.
   *  @param list The second list.
   *  @return boolean True if all elements of l1 are contained in l2 or if l1 is empty.
   */
  global define OSRIsSubSet(list l1, list l2) ``{

      integer index = 0;

      // remove duplicate entries and sort the lists
      l1 = toset(l1);
      l2 = toset(l2);

      // check special cases
      if ((size(l1) < 0) || (size(l2) < 0))
      {
	  y2error("ERROR OSRIsSubSet: list size can't be negative: size of %1 = %2; size of %3 = %4", l1, size(l1), l2, size(l2));
	  return false;
      }
      else if (size(l1) > size(l2))
      {
	  y2debug("OSRIsSubSet: %1 is greater than %2!", l1, l2);
	  return false;
      }
      else if ((size(l1) == 0))
      {
	  y2debug("OSRIsSubSet: %1 is empty -> l1 is subset of l2!", l1);
	  return true;
      }
      else if (size(l1) <= size(l2))
      {
	  y2debug("OSRIsSubSet: comparing the elements: %1, %2", l1, l2);

	  // this is the main subset-checker
	  while ((index >= 0) && (index < size(l1)))
	  {
	      if ( !contains(l2, select(l1, index)) )
	      {
		  y2debug("OSRIsSubSet: element %1 not contained in %2", select(l1, index), l2);
		  return false;
	      }
	      index = index + 1;
	  }
	  y2debug("OSRIsSubSet: %1 is a real subset of %2", l1, l2);	  
	  return true;
      }
      else
      {
	  y2error("ERROR OSRIsSubSet: something's wrong with %1 and %2", l1, l2);	  
	  return false;
      }
  }

  /**
   *  This method resolves the requirements and provides of the modules and computes
   *  the correct sequence of detection modules.
   *
   *  For internal use only.
   *
   *  @return boolean True if the module sequence was successfully created.
   */
  global define OSRComputeModuleSequence() ``{

      integer index                = 0;
      string  module_name          = "";
      list    global_provides_list = [];
      list    module_provides_list = [];
      list    module_requires_list = [];
      list    module_list          = [];
      list    module_sequence      = [];

      // get the lists from the global osr_map
      module_list     = lookup(osr_map, "module_list");
      module_sequence = lookup(osr_map, "module_sequence");

      while ((index >= 0) && (index < size(module_list)))
      {
	  // get the module name and its requirements
	  module_name          = select(module_list, index);
	  module_requires_list = lookup(lookup(osr_map, module_name), "requires");

	  // check if the requirements of the current module are resolved by the global provides
	  if (OSRIsSubSet(module_requires_list, global_provides_list))
	  {
	      // if true add this module as next module in the sequence list, remove it from the
	      // list of modules and decrease the size of the list
	      module_sequence  = add(module_sequence, module_name);
	      module_list      = remove(module_list, index);
	      index            = 0;

	      // get the module_provides_list from the osr_map, use maplist to only put the key-names to the list
	      module_provides_list = maplist(`k, `v, lookup(lookup(osr_map, module_name), "provides"), ``(k));

	      // concatenate, sort and remove duplicates of the global_provides_list and the module_provides_list
	      global_provides_list = toset(union(global_provides_list, module_provides_list));
	  }
	  else
	  {
	      index = index + 1;
	  }
      }

      // add the new module sequence and the global provides to the osr_map
      osr_map = add(osr_map, "module_sequence",      module_sequence);
      osr_map = add(osr_map, "module_list",          module_list);
      osr_map = add(osr_map, "global_provides_list", global_provides_list);

      if (size(module_list) != 0)
      {
	  y2error("ERROR OSRComputeModuleSequence: module(s) not added to the sequence list: %1", module_list);
	  return false;
      }
      return true;
  }

  /**
   *  Only for the testsuite.
   *
   *  For internal use only.
   *
   *  @return map The global osr_map.
   */
  global define OSRTestGetOsrMap() ``{

      return osr_map;
  }
}
